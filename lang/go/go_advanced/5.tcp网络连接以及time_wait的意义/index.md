# 

## 一. 三次握手

&gt;#### tcp在建立连接时需要三次握手:
&gt;    1.accept接受过程中等待客户端的连接,当客户端发起连接时,会发起一个syn连接请求,
&gt;    2.服务端收到该连接请求之后会立即响应一个ack的响应,与此同时还会向客户端发送一个syn连接请求
&gt;    3.当客户端收到服务端的ack响应请求和syn连接请求之后,再向服务端回应一个ack的响应请求就可以建立tcp连接了
&gt;#### tcp的四次挥手:
&gt;    1.再客户端和服务端的代码中都有一个close方法,当有一方主动断开时,也就是执行close方法时,就是一次fin断开请求,在发出断开连接请求之后,如果收到对方的断开确认ack请求之后,就可以结束一段段额断开了,这样就是两次请求;
&gt;    2.当客户端和服务端双方都执行close方法,就会有两次断开请求和两次断开确认,这样就完成了连接断开,四次挥手;
&gt;#### 为什么连接是三次,而握手需要四次:
&gt;因为在创建连接时,服务端收到客户端的连接请求后,会发送一个ack的响应和一个syn的请求,为了解决资源开销,这两个操作合并在了一起,就是三次握手了,但是在断开tcp连接的时候在一方断开请求的时候另一方可能还有数据正在传输,,为了确保数据传输的完整性,就需要四次挥手.

&lt;img src=&#34;https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/image-20211203162524588.png&#34; alt=&#34;image-20211203162524588&#34; style=&#34;zoom: 67%;&#34; /&gt;

- 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j&#43;1），同时自己也发送一个SYN包（syn=k），即SYN&#43;ACK包，此时服务器进入SYN_RECV状态；

- 第三次握手：客户端收到服务器的SYN&#43;ACK包，向服务器发送确认包ACK(ack=k&#43;1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

## 二. 四次挥手

&gt;#### tcp在建立连接时需要三次握手:
&gt;
&gt;    1.accept接受过程中等待客户端的连接,当客户端发起连接时,会发起一个syn连接请求,
&gt;    2.服务端收到该连接请求之后会立即响应一个ack的响应,与此同时还会向客户端发送一个syn连接请求
&gt;    3.当客户端收到服务端的ack响应请求和syn连接请求之后,再向服务端回应一个ack的响应请求就可以建立tcp连接了
&gt;
&gt;#### tcp的四次挥手:
&gt;
&gt;    1.再客户端和服务端的代码中都有一个close方法,当有一方主动断开时,也就是执行close方法时,就是一次fin断开请求,在发出断开连接请求之后,如果收到对方的断开确认ack请求之后,就可以结束一段段额断开了,这样就是两次请求;
&gt;    2.当客户端和服务端双方都执行close方法,就会有两次断开请求和两次断开确认,这样就完成了连接断开,四次挥手;
&gt;
&gt;#### 为什么连接是三次,而握手需要四次:
&gt;
&gt;因为在创建连接时,服务端收到客户端的连接请求后,会发送一个ack的响应和一个syn的请求,为了解决资源开销,这两个操作合并在了一起,就是三次握手了,但是在断开tcp连接的时候在一方断开请求的时候另一方可能还有数据正在传输,,为了确保数据传输的完整性,就需要四次挥手.

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
- 2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u&#43;1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
- 3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
- 4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u&#43;1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
- 5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w&#43;1，而自己的序列号是seq=u&#43;1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
- 6)服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

## 三. 经典问题

**【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？**

```
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN&#43;ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&#34;你发的FIN报文我收到了&#34;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
```

**【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

```
虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
```

**【问题3】为什么不能用两次握手进行连接？**

```
3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁
```



**【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？**

```
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
```



## 四. 什么是TIME_WAIT

&gt;TIME_WAIT是TCP协议中断开连接所经历的一种状态。

- 我们在日常做服务器的研发中、或者面试网络部分知识的时候，会经常问到TIME_WAIT这个词，这个词作为服务端的开发者尤为重要。

&lt;img src=&#34;https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/812172f0885aec0d164e02fe9983bd83_1920x1080.png&#34; alt=&#34;img&#34; style=&#34;zoom: 33%;&#34; /&gt;

- 上图是TCP连接的状态转换，包括了一些触发条件，如果不是很直观，可以对比看下面的简图。(三次握手四次挥手)

  ![image-20211203162333685](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/image-20211203162333685.png)

&lt;img src=&#34;https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/1454483-20190629132816032-2043402666.png&#34; alt=&#34;img&#34; style=&#34;zoom: 50%;&#34; /&gt;



 这里面作为主动关闭的一方(Client)出现了`TIME_WAIT`状态，目的是告诉Server端，**自己没有需要发送的数据**，但是它仍然**保持了接收对方数据的能力**，一个常见的关闭连接过程如下：

1、当客户端没有待发送的数据时，它会向服务端发送 `FIN` 消息，发送消息后会进入 `FIN_WAIT_1` 状态；

2、服务端接收到客户端的 `FIN` 消息后，会进入 `CLOSE_WAIT` 状态并向客户端发送 `ACK` 消息，客户端接收到 `ACK` 消息时会进入 `FIN_WAIT_2` 状态；

3、当服务端没有待发送的数据时，服务端会向客户端发送 `FIN` 消息；

4、客户端接收到 `FIN` 消息后，会进入 `TIME_WAIT` 状态并向服务端发送 `ACK` 消息，服务端收到后会进入 `CLOSED` 状态；

5、客户端等待**两个最大数据段生命周期**（Maximum segment lifetime，MSL）的时间后也会进入 `CLOSED` 状态；

## 五. 为什么需要TIME_WAIT

&gt;#### **TIME_WAIT 一定是发生在主动关闭一方**
&gt;
&gt;被动关闭一方，会直接进入`CLOSED`状态，而主动关闭一方需要等待2*MSL时间才会最终关闭。
&gt;
&gt;原因：
&gt;
&gt;1、防止被动关闭方的延迟数据被人窃取
&gt;
&gt;2、防止被动关闭方没有收到最后的ACK

#### 原因一：防止被动关闭方的延迟数据被人窃取

![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/fc1c51444d0640fedd14ccd29b528b88_1920x1080-20211203162028583.png)

如上图所示，

1、在①中，服务端发送`seq=1001`的消息，由于网络延迟或其他原因，没有及时到达`Client1`客户端，导致整个包一直存留在网络环境的传输过程中。

2、在②中，`Client1`收到server的`FIN`包之后，变成了`TIME_WAIT`状态，这里假设`TIME_WAIT`等待的时间很短暂，那么，还没等之前的那个延迟包`seq=1001`到来，就回复给了`Server`最后一个`ACK`包。那么`Server`就会变成`CLOSED`状态。

3、在③中，相同的端口号的`Client2`的TCP链接被重用后

4、在④中，`seq=1001`的延迟包消息才发送给客户端，而这个延迟的消息却被`Client2`正常接收，主要就会给Client2带来严重的问题。所以`TIME_WAIT`不要轻易的调整，或者缩小时间，可能就会出现这种问题。

#### 原因二：防止被动关闭方没有收到最后的ACK

- 该作用就是等待足够长的时间以确定远程的TCP链接收到了其发出的终止链接消息`FIN`包的回执消息`ACK`包。

  ![img](https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/e727114fc7c2fd539c14cf689479b5b0_1920x1080.png)

 如上图所示：

1、在①中，`CLient1`端主动发起关闭链接，`Server`针对`Client1`的`FIN`回执了`ACK`包，然后接着发送了自己的`FIN`包，等待`Client1`回执最终的`ACK`包。

2、在②中，这里假设`TIME_WAIT`的时间不足够充分，当`Server`还没有收到 `ACK` 消息时，`Client1`就主动变成`CLOSED`状态。

3、在③中，由于`Server`一直没有等到自己`FIN`包的`ACK`应答包，导致一直处于`LAST_ACK`状态。

4、在④中，因为 服务端因为没有收到 `ACK` 消息，当`Client2`重新与`Server`建立TCP链接，认为当前连接是合法的，`CLient2`重新发送 `SYN` 消息请求握手时会收到`Server`的 `RST` 消息，连接建立的过程就会被终止。

所以，我们在默认情况下，如果客户端等待足够长的时间就会遇到以下两种情况：

1. 服务端正常收到了 `ACK` 消息并关闭当前 TCP 连接；
2. 服务端没有收到 `ACK` 消息，重新发送 `FIN` 关闭连接并等待新的 `ACK` 消息；

只要客户端等待 2 MSL 的时间，客户端和服务端之间的连接就会正常关闭，新创建的 TCP 连接收到影响的概率也微乎其微，保证了数据传输的可靠性。

---

> 作者:   
> URL: http://localhost:1313/lang/go/go_advanced/5.tcp%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%BB%A5%E5%8F%8Atime_wait%E7%9A%84%E6%84%8F%E4%B9%89/  

