[{"categories":null,"content":"\rO、内存相关 下列程序为什么会卡死(测试不会被卡死) package main import ( \"fmt\" \"runtime\" ) func main() { var i byte go func() { for i = 0; i \u003c= 255; i++ {} }() fmt.Println(\"Dropping mic\") // Yield execution to force executing other goroutines runtime.Gosched() runtime.GC() fmt.Println(\"Done\") } 解析： Golang 中，byte 其实被 alias 到 uint8 上了。所以上⾯的 for 循环会始终成⽴，因为 i++ 到 i=255 的时候会溢出，i \u003c= 255 ⼀定成⽴。 也即是， for 循环永远⽆法退出，所以上⾯的代码其实可以等价于这样： go func() { for {} } 正在被执⾏的 goroutine 发⽣以下情况时让出当前 goroutine 的执⾏权，并调度后⾯的 goroutine 执⾏： IO 操作 Channel 阻塞 system call 运⾏较⻓时间 如果⼀个 goroutine 执⾏时间太⻓，scheduler 会在其 G 对象上打上⼀个标志（ preempt），当这个 goroutine 内部发⽣函数调⽤的时候，会先主动检查这个标志，如 果为 true 则会让出执⾏权。 main 函数⾥启动的 goroutine 其实是⼀个没有 IO 阻塞、没有 Channel 阻塞、没有 system call、没有函数调⽤的死循环。 也就是，它⽆法主动让出⾃⼰的执⾏权，即使已经执⾏很⻓时间，scheduler 已经标志 了 preempt。 ⽽ golang 的 GC 动作是需要所有正在运⾏ goroutine 都停⽌后进⾏的。因此，程序 会卡在 runtime.GC() 等待所有协程退出。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:1:0","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r一、数据定义","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:2:0","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(1).函数返回值问题 下面代码是否可以编译通过？ package main /* 下面代码是否编译通过? */ func myFunc(x,y int)(sum int,error){ return x+y,nil } func main() { num, err := myFunc(1, 2) fmt.Println(\"num = \", num) } 答案: 编译报错理由: # command-line-arguments ./test1.go:6:21: syntax error: mixed named and unnamed function parameters 考点：函数返回值命名 结果：编译出错。 在函数有多个返回值时，只要有一个返回值有指定命名，其他的也必须有命名。 如果返回值有有多个返回值必须加上括号； 如果只有一个返回值并且有命名也需要加上括号； 此处函数第一个返回值有sum名称，第二个未命名，所以错误。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:2:1","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(2).结构体比较问题 下面代码是否可以编译通过？为什么？ package main import \"fmt\" func main() { sn1 := struct { age int name string }{age: 11, name: \"qq\"} sn2 := struct { age int name string }{age: 11, name: \"qq\"} if sn1 == sn2 { fmt.Println(\"sn1 == sn2\") } sm1 := struct { age int m map[string]string }{age: 11, m: map[string]string{\"a\": \"1\"}} sm2 := struct { age int m map[string]string }{age: 11, m: map[string]string{\"a\": \"1\"}} if sm1 == sm2 { fmt.Println(\"sm1 == sm2\") } } 结果 编译不通过 ./test2.go:31:9: invalid operation: sm1 == sm2 (struct containing map[string]string cannot be compared) 考点:结构体比较 结构体比较规则注意1：只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关. 比如： sn1 := struct { age int name string }{age: 11, name: \"qq\"} sn3:= struct { name string age int }{age:11, name:\"qq\"} sn3与sn1就不是相同的结构体了，不能比较。 结构体比较规则注意2：结构体是相同的，但是结构体属性中有不可以比较的类型，如map,slice，则结构体不能用==比较。 可以使用reflect.DeepEqual进行比较 if reflect.DeepEqual(sm1, sm2) { fmt.Println(\"sm1 == sm2\") } else { fmt.Println(\"sm1 != sm2\") } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:2:2","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(3).string与nil类型 下面代码是否能够编译通过？为什么？ package main import ( \"fmt\" ) func GetValue(m map[int]string, id int) (string, bool) { if _, exist := m[id]; exist { return \"存在数据\", true } return nil, false } func main() { intmap:=map[int]string{ 1:\"a\", 2:\"bb\", 3:\"ccc\", } v,err:=GetValue(intmap,3) fmt.Println(v,err) } 考点：函数返回值类型 答案：编译不会通过。 分析： nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”。但是如果不特别指定的话，Go 语言不能识别类型，所以会报错。通常编译的时候不会报错，但是运行是时候会报:cannot use nil as type string in return argument. 所以将GetValue函数改成如下形式就可以了 func GetValue(m map[int]string, id int) (string, bool) { if _, exist := m[id]; exist { return \"存在数据\", true } return \"不存在数据\", false } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:2:3","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(4) 常量 下面函数有什么问题？ package main const cl = 100 var bl = 123 func main() { println(\u0026bl,bl) println(\u0026cl,cl) } 解析 考点:常量 常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用， cannot take the address of cl 内存四区概念： A.数据类型本质：固定内存大小的别名 B. 数据类型的作用：编译器预算对象(变量)分配的内存空间大小。 C. 内存四区 流程说明 1、操作系统把物理硬盘代码load到内存 2、操作系统把c代码分成四个区 3、操作系统找到main函数入口执行 栈区(Stack)： 空间较小，要求数据读写性能高，数据存放时间较短暂。由编译器自动分配和释放，存放函数的参数值、函数的调用流程方法地址、局部变量等(局部变量如果产生逃逸现象，可能会挂在在堆区) 堆区(heap): 空间充裕，数据存放时间较久。一般由开发者分配及释放(但是Golang中会根据变量的逃逸现象来选择是否分配到栈上或堆上)，启动Golang的GC由GC清除机制自动回收。 全局区-静态全局变量区: 全局变量的开辟是在程序在main之前就已经放在内存中。而且对外完全可见。即作用域在全部代码中，任何同包代码均可随时使用，在变量会搞混淆，而且在局部函数中如果同名称变量使用:=赋值会出现编译错误。 全局变量最终在进程退出时，由操作系统回收。 我们尽量减少使用全局变量的设计 全局区-常量区： 常量区也归属于全局区，常量为存放数值字面值单位，即不可修改。或者说的有的常量是直接挂钩字面值的。 比如: const cl = 10 cl是字面量10的对等符号。 所以在golang中，常量是无法取出地址的，因为字面量符号并没有地址而言。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:2:4","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(5) defer练习 package main import \"fmt\" func DeferFunc1(i int) (t int) { t = i defer func() { t += 3 }() return t } func DeferFunc2(i int) int { t := i defer func() { t += 3 }() return t } func DeferFunc3(i int) (t int) { defer func() { t += i }() return 2 } func DeferFunc4() (t int) { defer func(i int) { fmt.Println(i) fmt.Println(t) }(t) t = 1 return 2 } func main() { fmt.Println(DeferFunc1(1)) // 4 fmt.Println(DeferFunc2(1)) // 1 fmt.Println(DeferFunc3(1)) // 3 DeferFunc4() // 0 2 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:2:5","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r二、数组和切片","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:3:0","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(1) 切片的初始化与追加 1.1 package main import \"fmt\" func main() { s1 := []int{1, 2, 3} fmt.Println(len(s1), cap(s1), s1) //输出 3 3 [1 2 3] s2 := s1[1:] //索引从第二个元素截取开始 fmt.Println(len(s2), cap(s2), s2) //输出 2 2 [2 3] for i := range s2 { s2[i] += 20 } //仍然引用同一数组 fmt.Println(s1) //s1 在s2修改了后面2个元素，所以s1也是更新了。输出 [1 22 23] fmt.Println(s2) //输出 [22 23] s2 = append(s2, 4) // 注意s2的容量是2，追加新元素后将导致分配一个新的数组 [22 23 4] for i := range s2 { s2[i] += 10 } //s1 仍然是更新后的历史老数据 fmt.Println(s1) //输出 [1 22 23] fmt.Println(s2) //输出 [32 33 14] } 1.2 写出程序运行的结果 package main import ( \"fmt\" ) func main(){ s := make([]int, 10) s = append(s, 1, 2, 3) fmt.Println(s) } 考点 切片追加, make初始化均为0 结果 [0 0 0 0 0 0 0 0 0 0 1 2 3] ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:3:1","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(2) slice拼接问题 下面是否可以编译通过？ test6.go package main import \"fmt\" func main() { s1 := []int{1, 2, 3} s2 := []int{4, 5} s1 = append(s1, s2) fmt.Println(s1) } 结果 编译失败 两个slice在append的时候，记住需要进行将第二个slice进行...打散再拼接。 s1 = append(s1, s2...) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:3:2","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(3) slice中new的使用 下面代码是否可以编译通过？ package main import \"fmt\" func main() { list := new([]int) list = append(list, 1) fmt.Println(list) } 结果： 编译失败，./test9.go:9:15: first argument to append must be slice; have *[]int 分析： 切片指针的解引用。 可以使用list:=make([]int,0) list类型为切片 或使用*list = append(*list, 1) list类型为指针 new和make的区别： 二者都是内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零。所以在我们编写程序的时候，就可以根据自己的需要很好的选择了。 make返回的还是这三个引用类型本身；而new返回的是指向类型的指针。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:3:3","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r三、Map","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:4:0","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(1) Map的Value赋值 下面代码编译会出现什么结果？ package main import \"fmt\" type Student struct { Name string } var list map[string]Student func main() { list = make(map[string]Student) student := Student{\"Aceld\"} list[\"student\"] = student list[\"student\"].Name = \"LDB\" fmt.Println(list[\"student\"]) } 结果 编译失败，./test7.go:18:23: cannot assign to struct field list[\"student\"].Name in map 分析 map[string]Student 的value是一个Student结构值，所以当list[\"student\"] = student,是一个值拷贝过程。而list[\"student\"]则是一个值引用。那么值引用的特点是只读。所以对list[\"student\"].Name = \"LDB\"的修改是不允许的。 方法一： package main import \"fmt\" type Student struct { Name string } var list map[string]Student func main() { list = make(map[string]Student) student := Student{\"Aceld\"} list[\"student\"] = student //list[\"student\"].Name = \"LDB\" /* 方法1: */ tmpStudent := list[\"student\"] tmpStudent.Name = \"LDB\" list[\"student\"] = tmpStudent fmt.Println(list[\"student\"]) } 其中 /* 方法1: */ tmpStudent := list[\"student\"] tmpStudent.Name = \"LDB\" list[\"student\"] = tmpStudent 是先做一次值拷贝，做出一个tmpStudent副本,然后修改该副本，然后再次发生一次值拷贝复制回去，list[\"student\"] = tmpStudent,但是这种会在整体过程中发生2次结构体值拷贝，性能很差。 方法二： package main import \"fmt\" type Student struct { Name string } var list map[string]*Student func main() { list = make(map[string]*Student) student := Student{\"Aceld\"} list[\"student\"] = \u0026student list[\"student\"].Name = \"LDB\" fmt.Println(list[\"student\"]) } 我们将map的类型的value由Student值，改成Student指针。 var list map[string]*Student 这样，我们实际上每次修改的都是指针所指向的Student空间，指针本身是常指针，不能修改，只读属性，但是指向的Student是可以随便修改的，而且这里并不需要值拷贝。只是一个指针的赋值。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:4:1","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(2) map的遍历赋值 以下代码有什么问题，说明原因 package main import ( \"fmt\" ) type student struct { Name string Age int } func main() { //定义map m := make(map[string]*student) //定义student数组 stus := []student{ {Name: \"zhou\", Age: 24}, {Name: \"li\", Age: 23}, {Name: \"wang\", Age: 22}, } //将数组依次添加到map中 for _, stu := range stus { m[stu.Name] = \u0026stu } //打印map for k,v := range m { fmt.Println(k ,\"=\u003e\", v.Name) } } 结果 遍历结果出现错误，输出结果为 zhou =\u003e wang li =\u003e wang wang =\u003e wang map中的3个key均指向数组中最后一个结构体。 分析 foreach中，stu是结构体的一个拷贝副本，所以m[stu.Name]=\u0026stu实际上一致指向同一个指针， 最终该指针的值为遍历的最后一个struct的值拷贝。 正确写法 package main import ( \"fmt\" ) type student struct { Name string Age int } func main() { //定义map m := make(map[string]*student) //定义student数组 stus := []student{ {Name: \"zhou\", Age: 24}, {Name: \"li\", Age: 23}, {Name: \"wang\", Age: 22}, } // 遍历结构体数组，依次赋值给map for i := 0; i \u003c len(stus); i++ { m[stus[i].Name] = \u0026stus[i] } //打印map for k,v := range m { fmt.Println(k ,\"=\u003e\", v.Name) } } 运行结果 zhou =\u003e zhou li =\u003e li wang =\u003e wang ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:4:2","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r四、interface","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:5:0","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(1) interface的赋值问题 以下代码能编译过去吗？为什么？ package main import ( \"fmt\" ) type People interface { Speak(string) string } type Stduent struct{} func (stu *Stduent) Speak(think string) (talk string) { if think == \"love\" { talk = \"You are a good boy\" } else { talk = \"hi\" } return } func main() { var peo People = Stduent{} think := \"love\" fmt.Println(peo.Speak(think)) } 继承与多态的特点在golang中对多态的特点体现从语法上并不是很明显。 我们知道发生多态的几个要素： ​ 1、有interface接口，并且有接口定义的方法。 ​ 2、有子类去重写interface的接口。 ​ 3、有父类指针指向子类的具体对象 那么，满足上述3个条件，就可以产生多态效果，就是，父类指针可以调用子类的具体方法。 所以上述代码报错的地方在var peo People = Stduent{}这条语句， Student{}已经重写了父类People{}中的Speak(string) string方法，那么只需要用父类指针指向子类对象即可。 所以应该改成var peo People = \u0026Student{} 即可编译通过。（People为interface类型，就是指针类型） ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:5:1","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(2) interface的内部构造(非空接口iface情况) 以下代码打印出来什么内容，说出为什么。 package main import ( \"fmt\" ) type People interface { Show() } type Student struct{} func (stu *Student) Show() { } func live() People { var stu *Student return stu } func main() { if live() == nil { fmt.Println(\"AAAAAAA\") } else { fmt.Println(\"BBBBBBB\") } } 结果 BBBBBBB 分析： 我们需要了解interface的内部结构，才能理解这个题目的含义。 interface在使用的过程中，共有两种表现形式 一种为空接口(empty interface)，定义如下： var MyInterface interface{} 另一种为非空接口(non-empty interface), 定义如下： type MyInterface interface { function() } 这两种interface类型分别用两种struct表示，空接口为eface, 非空接口为iface. 空接口eface空接口eface结构，由两个属性构成，一个是类型信息_type，一个是数据信息。其数据结构声明如下： type eface struct { //空接口 _type *_type //类型信息 data unsafe.Pointer //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*) } _type属性：是GO语言中所有类型的公共描述，Go语言几乎所有的数据结构都可以抽象成 _type，是所有类型的公共描述，**type负责决定data应该如何解释和操作，**type的结构代码如下: type _type struct { size uintptr //类型大小 ptrdata uintptr //前缀持有所有指针的内存大小 hash uint32 //数据hash值 tflag tflag align uint8 //对齐 fieldalign uint8 //嵌入结构体时的对齐 kind uint8 //kind 有些枚举值kind等于0是无效的 alg *typeAlg //函数指针数组，类型实现的所有方法 gcdata *byte str nameOff ptrToThis typeOff } data属性: 表示指向具体的实例数据的指针，他是一个unsafe.Pointer类型，相当于一个C的万能指针void*。 非空接口ifaceiface 表示 non-empty interface 的数据结构，非空接口初始化的过程就是初始化一个iface类型的结构，其中data的作用同eface的相同，这里不再多加描述。 type iface struct { tab *itab data unsafe.Pointer } iface结构中最重要的是itab结构（结构如下），每一个 itab 都占 32 字节的空间。itab可以理解为pair\u003cinterface type, concrete type\u003e 。itab里面包含了interface的一些关键信息，比如method的具体实现。 type itab struct { inter *interfacetype // 接口自身的元信息 _type *_type // 具体类型的元信息 link *itab bad int32 hash int32 // _type里也有一个同样的hash，此处多放一个是为了方便运行接口断言 fun [1]uintptr // 函数指针，指向具体类型所实现的方法 } 其中值得注意的字段，个人理解如下： interface type包含了一些关于interface本身的信息，比如package path，包含的method。这里的interfacetype是定义interface的一种抽象表示。 type表示具体化的类型，与eface的 type类型相同。 hash字段其实是对_type.hash的拷贝，它会在interface的实例化时，用于快速判断目标类型和接口中的类型是否一致。另，Go的interface的Duck-typing机制也是依赖这个字段来实现。 fun字段其实是一个动态大小的数组，虽然声明时是固定大小为1，但在使用时会直接通过fun指针获取其中的数据，并且不会检查数组的边界，所以该数组中保存的元素数量是不确定的。 所以，People拥有一个Show方法的，属于非空接口，People的内部定义应该是一个iface结构体 type People interface { Show() } func live() People { var stu *Student return stu } stu是一个指向nil的空指针，但是最后return stu 会触发匿名变量 People = stu值拷贝动作，所以最后live()放回给上层的是一个People insterface{}类型，也就是一个iface struct{}类型。 stu为nil，只是iface中的data 为nil而已。 但是iface struct{}本身并不为nil. 所以如下判断的结果为BBBBBBB： func main() { if live() == nil { fmt.Println(\"AAAAAAA\") } else { fmt.Println(\"BBBBBBB\") } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:5:2","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(3) interface内部构造(空接口eface情况) 下面代码结果为什么？ func Foo(x interface{}) { if x == nil { fmt.Println(\"empty interface\") return } fmt.Println(\"non-empty interface\") } func main() { var p *int = nil Foo(p) } 结果 non-empty interface 分析 不难看出，Foo()的形参x interface{}是一个空接口类型eface struct{}。 在执行Foo(p)的时候，触发x interface{} = p语句，所以此时 x结构如下。 所以 x 结构体本身不为nil，而是data指针指向的p为nil。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:5:3","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(4) inteface{}与*interface ABCD中哪一行存在错误？ type S struct { } func f(x interface{}) { } func g(x *interface{}) { } func main() { s := S{} p := \u0026s f(s) //A g(s) //B f(p) //C g(p) //D } 结果 B、D两行错误 B错误为： cannot use s (type S) as type *interface {} in argument to g: *interface {} is pointer to interface, not interface D错误为：cannot use p (type *S) as type *interface {} in argument to g: *interface {} is pointer to interface, not interface ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:5:4","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r五、channel","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:6:0","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(1)Channel读写特性(15字口诀)首先，我们先复习一下Channel都有哪些特性？ 给一个 nil channel 发送数据，造成永远阻塞 从一个 nil channel 接收数据，造成永远阻塞 给一个已经关闭的 channel 发送数据，引起 panic 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值 无缓冲的channel是同步的，而有缓冲的channel是非同步的 以上5个特性是死东西，也可以通过口诀来记忆：“空读写阻塞，写关闭异常，读关闭空零”。 执行下面的代码发生什么？ package main import ( \"fmt\" \"time\" ) func main() { ch := make(chan int, 1000) go func() { for i := 0; i \u003c 10; i++ { ch \u003c- i } }() go func() { for { a, ok := \u003c-ch if !ok { fmt.Println(\"close\") return } fmt.Println(\"a: \", a) } }() close(ch) fmt.Println(\"ok\") time.Sleep(time.Second * 100) } 15字口诀：“空读写阻塞，写关闭异常，读关闭空零”，往已经关闭的channel写入数据会panic的。因为main在开辟完两个goroutine之后，立刻关闭了ch， 结果不唯一： // 第二个协程中的打印有可能输出 panic: send on closed channel ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:6:1","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r六、WaitGroup","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:7:0","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r(1) WaitGroup与goroutine的竞速问题 编译并运行如下代码会发生什么？ package main import ( \"sync\" //\"time\" ) const N = 10 var wg = \u0026sync.WaitGroup{} func main() { for i := 0; i \u003c N; i++ { go func(i int) { wg.Add(1) println(i) defer wg.Done() }(i) } wg.Wait() } 结果 结果不唯一，代码存在风险, 所有go未必都能执行到 这是使用WaitGroup经常犯下的错误！请各位同学多次运行就会发现输出都会不同甚至又出现报错的问题。 这是因为go执行太快了，导致wg.Add(1)还没有执行main函数就执行完毕了。 改为如下试试 package main import ( \"sync\" ) const N = 10 var wg = \u0026sync.WaitGroup{} func main() { for i:= 0; i\u003c N; i++ { wg.Add(1) go func(i int) { println(i) defer wg.Done() }(i) } wg.Wait() } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180343/:7:1","tags":null,"title":"100.习题练习","uri":"/lang/go/go_advanced/20250515180343/"},{"categories":null,"content":"\r网络代理","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:1:0","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r1. 网络代理\u0026网络转发 网络代理 用户通过代理请求信息 请求通过网络代理完成转发到达目标服务器 目标服务器相应后再通过网络代理回传给用户 用户不直接连接服务器，网络代理去连接。获取数据后返回给用户 网络转发 客户端访问公网服务器，数据包在网络上传输时会经过至少一个路由器，对于多个/多层路由，会进行网络转发，让客户端能够访问公网服务器并返回结果。网络传输中是通过IP来确定服务器（主机）的，通过端口来确定应用(或者说进程)，比如微信应用发消息，会有端口号来唯一标识该应用进程。 是路由器对报文的转发操作，中间可能对数据包修改 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:1:1","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r2. 网络代理类型 正向代理：是一种客户端的代理技术, 帮助客户端访问无法访问的代理服务资源, 可以隐藏真是的IP, 比如浏览器的web代理、vpn等； 监听中的代理服务器在接收到客户端的请求后，会创建一个上游的tcp连接，通过回调方法，复制原请求对象，并根据其中的数据配置新的请求中的各种参数 把新请求发送到真实的服务器，并接收到服务器端的返回 代理服务器对响应做一些处理后，返回给客户端 反向代理：是一种服务端的代理技术， 帮助服务端做负载均衡、缓存、提供安全校验等，可以隐藏服务器的真实IP。比如lvs技术、nginx反向代理proxy_pass等 代理接收客户端请求，更改请求结构体信息 通过一定的负载均衡算法获取下游服务器地址 把请求发送到下游服务器，并获取返回内容 对返回内容做一些处理，返回给客户端 透明代理：透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。透明代理实践的例子就是时下很多公司使用的行为管理软件。 ​ ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:1:2","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r3. 特殊请求头 Remote Address: Remote Address 来自 TCP 连接，表示与服务端建立 TCP 连接的设备 IP; 【不可伪造】 X-Forwarded-For: 一个 HTTP 扩展头部 X-Forwarded-For 是一个 HTTP 扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入 RFC 7239（Forwarded HTTP Extension）标准之中。 格式：X-Forwarded-For: client, proxy1, proxy2; 内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP;最前面的是客户端真实ip； PS：网上有些文章建议这样配置 Nginx，其实并不合理，这样配置之后，安全性确实提高了，但是也导致请求到达 Nginx 之前的所有代理信息都被抹掉，无法为真正使用代理的用户提供更好的服务。还是应该弄明白这中间的原理，具体场景具体分析。 proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; X-Real-IP：客户端实际请求的服务端IP【不可伪造】 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:1:3","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\rgo实现HTTP代理","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:2:0","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r1. 正向代理 步骤 代理接收客户端请求，复制原请求对象，并根据数 据配置新请求各种参数 把新请求发送到真实服务端，并接收到服务器端返回 代理服务器对相应做一些处理，然后返回给客户端 代码实现 package main import ( \"fmt\" \"io\" \"net\" \"net/http\" \"strings\" ) type Pxy struct{} func (p *Pxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) { fmt.Printf( \"Received request %s %s %s\\n\", req.Method, req.Host, req.RemoteAddr, ) transport := http.DefaultTransport // 1. 浅拷贝对象, 然后再新增属性数据 outReq := new(http.Request) *outReq = *req if clientIp, _, err := net.SplitHostPort(req.RemoteAddr); err == nil { if prior, ok := outReq.Header[\"X-Forwarded-For\"]; ok { clientIp = strings.Join(prior, \",\") + \", \" + clientIp } outReq.Header.Set(\"X-Forwarded-For\", clientIp) } // 2.请求下游 res, err := transport.RoundTrip(outReq) if err != nil { rw.WriteHeader(http.StatusBadGateway) return } // 3. 把下游请求内容返回给上游 for key, value := range res.Header { for _, v := range value { rw.Header().Add(key, v) } } rw.WriteHeader(res.StatusCode) io.Copy(rw, res.Body) res.Body.Close() } func main() { fmt.Println(\"server on :8080\") http.Handle(\"/\", \u0026Pxy{}) err := http.ListenAndServe(\":8080\", nil) if err != nil { panic(err) } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:2:1","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r2. 反向代理 简单版反向代理实现 代理接收客户端请求， 更改请求结构体信息 通过负载均衡算法获取下游服务地址 把请求发送到下游服务器，并获取返回内容 对返回内容做一些处理，然后返回给客户端 真是的服务代码实现 /* * @date: 2021/12/7 * @desc: ... */ package main import ( \"fmt\" \"io\" \"log\" \"net/http\" \"os\" \"os/signal\" \"syscall\" \"time\" ) type RealServer struct { Addr string } func (r *RealServer) Run() { log.Println(\"Starting httpserver at \" + r.Addr) mux := http.NewServeMux() mux.HandleFunc(\"/\", r.HelloHandler) mux.HandleFunc(\"/base/error\", r.ErrorHandler) mux.HandleFunc(\"/test_http_string/test_http_string/aaa\", r.TimeoutHandler) server := \u0026http.Server{ Addr: r.Addr, WriteTimeout: time.Second * 3, Handler: mux, } go func() { log.Fatal(server.ListenAndServe()) }() } func (r *RealServer) HelloHandler(w http.ResponseWriter, req *http.Request) { //127.0.0.1:8008/abc?sdsdsa=11 //r.Addr=127.0.0.1:8008 //req.URL.Path=/abc //fmt.Println(req.Host) upath := fmt.Sprintf(\"http://%s%s\\n\", r.Addr, req.URL.Path) realIP := fmt.Sprintf(\"RemoteAddr=%s,X-Forwarded-For=%v,X-Real-Ip=%v\\n\", req.RemoteAddr, req.Header.Get(\"X-Forwarded-For\"), req.Header.Get(\"X-Real-Ip\")) header := fmt.Sprintf(\"headers =%v\\n\", req.Header) io.WriteString(w, upath) io.WriteString(w, realIP) io.WriteString(w, header) } func (r *RealServer) ErrorHandler(w http.ResponseWriter, req *http.Request) { upath := \"error handler\" w.WriteHeader(500) io.WriteString(w, upath) } func (r *RealServer) TimeoutHandler(w http.ResponseWriter, req *http.Request) { time.Sleep(6 * time.Second) upath := \"timeout handler\" w.WriteHeader(200) io.WriteString(w, upath) } func main() { rs1 := \u0026RealServer{Addr: \"127.0.0.1:2003\"} rs1.Run() rs2 := \u0026RealServer{Addr: \"127.0.0.1:2004\"} rs2.Run() //监听关闭信号 quit := make(chan os.Signal) signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) \u003c-quit } 代理服务器代码实现 package main import ( \"bufio\" \"fmt\" \"log\" \"net/http\" \"net/url\" ) var ( proxyAddr = \"http://127.0.0.1:2003\" port = \"2002\" ) func handler(rw http.ResponseWriter, req *http.Request) { // 1. 解析代理IP地址, 更改请求体的协议和主机 proxy, err := url.Parse(proxyAddr) req.URL.Scheme = proxy.Scheme req.URL.Host = proxy.Host if err != nil { panic(err) } // 2. 请求下游 transport := http.DefaultTransport resp, err := transport.RoundTrip(req) if err != nil { panic(err) } // 3. 把下游请求内容返回给上游 for k, vv := range resp.Header { for _, v := range vv { rw.Header().Add(k, v) } } defer resp.Body.Close() bufio.NewReader(resp.Body).WriteTo(rw) } func main() { http.HandleFunc(\"/\", handler) log.Println(\"server on port \" + port) err := http.ListenAndServe(fmt.Sprintf(\":%v\", port), nil) if err != nil { log.Fatal(err) } } 上方原生HTTP实现正反向代理,可能存在一下问题: 没有错误回调及错误日志等处理 无法更改代理后返回的内容 没有负载均衡 没有url重写 没有熔断限流,降级,数据统计等功能 解决以上问题,go在标准库中提供了ReverseProxy实现http代理 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:2:2","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\rReverseProxy实现原理 ReverseProxy在net/http/httputil/包下 ReverseProxy 功能 提供了4种负载均衡的实现及接口封装,并且支持自定义负载均衡 通过中间件提供了: 限流, 熔断,降级, 权限,数据统计等功能 允许更改启动内容 可以设置错误信息回调 支持url重写 支持连接池功能 支持webSocket 支持https代理 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:3:0","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r1. ReverseProxy 结构 结构体详解 type ReverseProxy struct { //控制器必须是一个函数，通过该函数内部可以对请求进行修改，比如请求的路径，请求的参数 Director func(*http.Request) //连接池，如果为nil，则使用http.DefaultTransport Transport http.RoundTripper //刷新到客户端的刷新间隔,如果拿到一批数据，返回的间隔时间 FlushInterval time.Duration //错误记录器 ErrorLog *log.Logger //定义一个缓冲池，在复制http响应的时候使用，用以提高请求效率 BufferPool BufferPool //修改response返回内容的函数 //将函数格式定义为以下格式，就能对返回内容进行修改 ModifyResponse func(*http.Response) error //以上函数中出错时，会被该方法捕获 //错误回调函数，如果为nil，则默认为记录提供的错误并返回502状态错误网关响应, //当发生异常时(包括整个流程上某一部分发生异常)可以通过该函数进行处理 ErrorHandler func(http.ResponseWriter, *http.Request, error) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:3:1","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r2. 简单实现反向代理 通过httputil下的NewSingleHostReverseProxy()方法可以直接创建一个ReverseProxy ReverseProxy实现了Handler接口,所以可以直接当成路由处理器来使用 代码实现 import ( \"log\" \"net/http\" \"net/http/httputil\" \"net/url\" ) func main() { //1.真实需要访问的地址 rs1 := \"http://127.0.0.1:9999/base\" //通过url.Parse()解析地址 url1, err1 := url.Parse(rs1) if err1 != nil { log.Println(err1) } //2.获取到ReverseProxy proxy := httputil.NewSingleHostReverseProxy(url1) //3.ReverseProxy实现了Handler,可以直接当成处理器路由来使用 //通过ReverseProxy实现http代理,当访问当前服务8080端口时, //会被ReverseProxy代理到rs1 log.Fatal(http.ListenAndServe(\":8080\", proxy)) } // 假设访问当前服务\"127.0.0.1:8080/xxx\"在经过ReverseProxy代理后,实际会访问到\"127.0.0.1:2003/base/xxx\", 内部提供了一定的重写规则 2.1 NewSingleHostReverseProxy() 源码 NewSingleHostReverseProxy() 是默认提供的单一代理函数; 源码 //target url.URL:代理的目标服务,假设为\"http://127.0.0.1:2002/base?name=123\" func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy { //1.获取路径参数,根据上面假设的路径,当前targetQuery 就是\"name=123\" targetQuery := target.RawQuery //2.创建ReverseProxy需要的Director方法 //Director:用来改写请求路径,请求参数的函数 director := func(req *http.Request) { //2.1设置协议Scheme: http req.URL.Scheme = target.Scheme //2.2设置主机Host: 127.0.0.1:2002 req.URL.Host = target.Host //2.3设置path //设置规则:比如当前服务到此处的路径为\"http://ip:端口号/dir\" //上面要代理到target指向的path为\"/base\" //拼接后位\"/base/dir\" 也就是target.path后要拼接当前服务的path //joinURLPath()方法中会有一些合并校验等逻辑 req.URL.Path, req.URL.RawPath = joinURLPath(target, req.URL) //2.4 url参数的设置 if targetQuery == \"\" || req.URL.RawQuery == \"\" { req.URL.RawQuery = targetQuery + req.URL.RawQuery } else { req.URL.RawQuery = targetQuery + \"\u0026\" + req.URL.RawQuery } //2.4设置请求头 if _, ok := req.Header[\"User-Agent\"]; !ok { // explicitly disable User-Agent so it's not set to default value req.Header.Set(\"User-Agent\", \"\") } } //3.创建ReverseProxy设置Director并返回 return \u0026ReverseProxy{Director: director} } 2.2 自定义SingleHostReverseProxy NewMyReverseProxy() package main import ( \"bytes\" \"encoding/json\" \"errors\" \"fmt\" \"io/ioutil\" \"log\" \"net/http\" \"net/http/httputil\" \"net/url\" \"regexp\" \"strings\" ) // 1.模拟NewSingleHostReverseProxy创建ReverseProxy // target: 目标服务 func NewMySingleHostReverseProxy(target *url.URL) *httputil.ReverseProxy { // 1.获取path上的请求参数 targetQuery := target.RawQuery // 2.封装用来修改请求路径,请求参数的Director函数 director := func(req *http.Request) { // 2.1请求参数 re, _ := regexp.Compile(\"^/dir(.*)\") req.URL.Path = re.ReplaceAllString(req.URL.Path, \"$1\") // 2.2设置协议 req.URL.Scheme = target.Scheme // 2.3设置主机地址 req.URL.Host = target.Host // 2.4 设置path req.URL.Path = singleJoiningSlash(target.Path, req.URL.Path) // 2.5 设置path参数 if targetQuery == \"\" || req.URL.RawQuery == \"\" { req.URL.RawQuery = targetQuery + req.URL.RawQuery } else { req.URL.RawQuery = targetQuery + \"\u0026\" + req.URL.RawQuery } // 2.5设置请求头 if _, ok := req.Header[\"User-Agent\"]; !ok { req.Header.Set(\"User-Agent\", \"\") } // 读取body body, err := ioutil.ReadAll(req.Body) if err != nil { log.Println(\"Failed to read request body:\", err) return } fmt.Println(string(body)) defer req.Body.Close() data := map[string]int{ \"apple\": 2, \"banana\": 3, \"cherry\": 4, } jsonBytes, err := json.Marshal(data) if err != nil { fmt.Println(\"Failed to serialize map to JSON:\", err) return } // req.Body = ioutil.NopCloser(bytes.NewReader(body)) req.Body = ioutil.NopCloser(bytes.NewReader(jsonBytes)) // 注意如果修改Body内容,要同步修改req.ContentLength长度,否则会报错 req.ContentLength = int64(len(jsonBytes)) // 添加请求头 req.Header.Set(\"token\", \"ssss\") } // 3.封装可用用来改写响应的modifyFunc 函数 modifyFunc := func(res *http.Response) error { if res.StatusCode != 200 { // 3.1此处判断如果响应的http状态码为异常时,封装异常返回 return errors.New(\"error statusCode\") } // 3.2读取下游服务响应的body oldPayload, err := ioutil.ReadAll(res.Body) if err != nil { return err } // 3.3封装新的响应 newPayLoad := []byte(\"hello \" + string(oldPayload)) // 3.4将数据再次填充到resp中(ioutil.NopCloser()该函数直接将byte数据转换为Body中的read) res.Body = ioutil.NopCloser(bytes.NewBuffer(newPayLoad)) // 3.5重置响应数据长度 res.ContentLength = int64(len(newPayLoad)) res.Header.Set(\"Content-Length\", fmt.Sprint(len(newPayLoad))) return nil } // 4.设置异常回调,在上面几个步骤如果发送异常,返回的err不为nin, // 会执行该函数,执行指定业务","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:3:2","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r3. ReverseProxy的ServeHTTP() 源码 ServerHTTP做了哪些事 验证是否请求终止: 若请求终止,我们就不会把这个服务请求下游，例如关闭浏览器、网络断开等等，那么就会终止请求 设置请求context信息,如果上游传了部分context信息，那么我就会将这一部分的context信息做设置 深拷贝header 修改req: 这里的修改request信息就包含了请求到下游的特殊的head头信息的变更，比如X-Forwarded-For，X-Real-IP Upgrade头的特殊处理 追加ClientIP信息: 这里就是X-Forwarded-For，X-Real-IP这一块的设置 向下游请求数据: transport、roundtrip？方法 处理升级协议请求 移除逐段头部 修改返回数据 拷贝头部的数据 写入状态码 周期刷新内容到response code func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) { //验证结构体里面有没有设置过ReverseProxy的连接池，没有则使用默认连接池 transport := p.Transport if transport == nil { transport = http.DefaultTransport } //1、验证是否请求终止 //上下文取得信息，向下转型为CloseNotifier //（http.CloseNotifier是一个接口，只有一个方法CloseNotify() \u003c-chan bool，作用是检测连接是否断开） //取出里面通知的一个channel，即cn.CloseNotify()，紧接着开启一个协程，一直监听这个channel是否有请求终止的消息，如果有，便执行cancel()方法 ctx := req.Context() if ctx.Done() != nil { } else if cn, ok := rw.(http.CloseNotifier); ok { var cancel context.CancelFunc ctx, cancel = context.WithCancel(ctx) defer cancel() notifyChan := cn.CloseNotify() go func() { select { case \u003c-notifyChan: cancel() case \u003c-ctx.Done(): } }() } //2、设置context信息 //通过上游发送过来的req，重新拷贝新建一个outreq对外请求的request，可以理解为往下文请求的一个request outreq := req.Clone(ctx) //对outreq的信息做特殊处理 if req.ContentLength == 0 { outreq.Body = nil // Issue 16036: nil Body for http.Transport retries } if outreq.Body != nil { defer outreq.Body.Close() } //3、深拷贝Header if outreq.Header == nil { outreq.Header = make(http.Header) // Issue 33142: historical behavior was to always allocate } //4、修改request，也就是之前控制器Director那里，地址和请求信息的修改拼接 p.Director(outreq) //outreq.Close = false的意思是表示outreq请求到下游的链接是可以被复用的 outreq.Close = false //5、Upgrade头的特殊处理 //upgradeType(outreq.Header)取出upgrade的类型并判断是否存在 reqUpType := upgradeType(outreq.Header) if !ascii.IsPrint(reqUpType) { p.getErrorHandler()(rw, req, fmt.Errorf(\"client tried to switch to invalid protocol %q\", reqUpType)) return } //删除connection的head头信息 removeConnectionHeaders(outreq.Header) //逐段消息头：客户端和第一代理之间的消息头，与是否往下传递head消息头是没有关联的，往下传递的信息中不应该包含这些逐段消息头 //删除后端的逐段消息头 for _, h := range hopHeaders { outreq.Header.Del(h) } //这两个特殊消息头跳过，不进行删除 if httpguts.HeaderValuesContainsToken(req.Header[\"Te\"], \"trailers\") { outreq.Header.Set(\"Te\", \"trailers\") } if reqUpType != \"\" { outreq.Header.Set(\"Connection\", \"Upgrade\") outreq.Header.Set(\"Upgrade\", reqUpType) } //6、X-Forwarded-For追加ClientIP信息 //设置 X-Forwarded-For，以逗号+空格分隔 if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil { prior, ok := outreq.Header[\"X-Forwarded-For\"] omit := ok \u0026\u0026 prior == nil // Issue 38079: nil now means don't populate the header if len(prior) \u003e 0 { clientIP = strings.Join(prior, \", \") + \", \" + clientIP } if !omit { outreq.Header.Set(\"X-Forwarded-For\", clientIP) } } //7、向下游请求数据，拿到响应response res, err := transport.RoundTrip(outreq) if err != nil { p.getErrorHandler()(rw, outreq, err) return } //8、处理升级协议请求 //验证响应状态码是否为101，是才考虑升级 // Deal with 101 Switching Protocols responses: (WebSocket, h2c, etc) if res.StatusCode == http.StatusSwitchingProtocols { if !p.modifyResponse(rw, res, outreq) { return } //请求升级方法（具体源码步骤见补充） p.handleUpgradeResponse(rw, outreq, res) return } //9、移除逐段消息头，删除从下游返回的无用的数据 removeConnectionHeaders(res.Header) for _, h := range hopHeaders { res.Header.Del(h) } //10、修改response返回内容 if !p.modifyResponse(rw, res, outreq) { return } //11、拷贝头部数据 copyHeader(rw.Header(), res.Header) //处理Trailer头部 announcedTrailers := len(res.Trailer) if announcedTrailers \u003e 0 { trailerKeys := make([]string, 0, len(res.Trailer)) for k := range res.Trailer { trailerKeys = append(trailerKeys, k) } rw.Header().Add(\"Trailer\", strings.Join(trailerKeys, \", \")) } //12、写入状态码 rw.WriteHeader(res.StatusCode) //13、按周期刷新内容到response err = p.copyResponse(rw, res.Body, p.flushInterval(res)) if err != nil { defer res.Body.Close() if !shouldPanicOnCopyError(req) { p.logf(\"suppressing panic for copyResponse error in test; copy error: %v\", err) return } panic(http.ErrAbortHandler) } //读取完body内容后，对body进行关闭 res.Body.Close() //对Trailer逻辑处理 if len(res.Trailer) \u003e 0 { if f","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:3:3","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\rReverseProxy 负载均衡","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:4:0","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r1. 常见负载均衡算法\r1.1 随机负载均衡 package load_balance import ( \"errors\" \"fmt\" \"math/rand\" \"strings\" ) type RandomBalance struct { curIndex int rss []string //观察主体 conf LoadBalanceConf } func (r *RandomBalance) Add(params ...string) error { if len(params) == 0 { return errors.New(\"param len 1 at least\") } addr := params[0] r.rss = append(r.rss, addr) return nil } func (r *RandomBalance) Next() string { if len(r.rss) == 0 { return \"\" } r.curIndex = rand.Intn(len(r.rss)) return r.rss[r.curIndex] } func (r *RandomBalance) Get(key string) (string, error) { return r.Next(), nil } func (r *RandomBalance) SetConf(conf LoadBalanceConf) { r.conf = conf } func (r *RandomBalance) Update() { if conf, ok := r.conf.(*LoadBalanceZkConf); ok { fmt.Println(\"Update get conf:\", conf.GetConf()) r.rss = []string{} for _, ip := range conf.GetConf() { r.Add(strings.Split(ip, \",\")...) } } if conf, ok := r.conf.(*LoadBalanceCheckConf); ok { fmt.Println(\"Update get conf:\", conf.GetConf()) r.rss = nil for _, ip := range conf.GetConf() { r.Add(strings.Split(ip, \",\")...) } } } 1.2 轮询负载均衡 package load_balance import ( \"errors\" \"fmt\" \"strings\" ) type RoundRobinBalance struct { curIndex int rss []string //观察主体 conf LoadBalanceConf } func (r *RoundRobinBalance) Add(params ...string) error { if len(params) == 0 { return errors.New(\"param len 1 at least\") } addr := params[0] r.rss = append(r.rss, addr) return nil } func (r *RoundRobinBalance) Next() string { if len(r.rss) == 0 { return \"\" } lens := len(r.rss) //5 if r.curIndex \u003e= lens { r.curIndex = 0 } curAddr := r.rss[r.curIndex] r.curIndex = (r.curIndex + 1) % lens return curAddr } func (r *RoundRobinBalance) Get(key string) (string, error) { return r.Next(), nil } func (r *RoundRobinBalance) SetConf(conf LoadBalanceConf) { r.conf = conf } func (r *RoundRobinBalance) Update() { if conf, ok := r.conf.(*LoadBalanceZkConf); ok { fmt.Println(\"Update get conf:\", conf.GetConf()) r.rss = []string{} for _, ip := range conf.GetConf() { r.Add(strings.Split(ip, \",\")...) } } if conf, ok := r.conf.(*LoadBalanceCheckConf); ok { fmt.Println(\"Update get conf:\", conf.GetConf()) r.rss = nil for _, ip := range conf.GetConf() { r.Add(strings.Split(ip, \",\")...) } } } 1.3 加权负载均衡 参数详解 weight // 权重值 初始化时对接点约定的权重 currentWeight // 节点当前权重 节点临时权重，每轮都会变化 effectiveWeight // 有效权重 节点的有效权重，默认与weight相同, 当节点发生一次故障时，name该节点的 effectiveWeight=weight-1 ， totalWeight //所有节点的有效权重之和 sum(effectiveWeight) 算法流程 a. currentWeight = currentWeight+effectiveWeight b. 选中一个最大的currentWeight节点作为选中节点 c. 选中节点 currentWeight = currentWeight - totalWeight（4+3+2=9） package load_balance import ( \"errors\" \"fmt\" \"strconv\" \"strings\" ) type WeightRoundRobinBalance struct { curIndex int rss []*WeightNode rsw []int //观察主体 conf LoadBalanceConf } type WeightNode struct { addr string weight int //权重值 currentWeight int //节点当前权重 effectiveWeight int //有效权重 } func (r *WeightRoundRobinBalance) Add(params ...string) error { if len(params) != 2 { return errors.New(\"param len need 2\") } parInt, err := strconv.ParseInt(params[1], 10, 64) if err != nil { return err } node := \u0026WeightNode{addr: params[0], weight: int(parInt)} node.effectiveWeight = node.weight r.rss = append(r.rss, node) return nil } func (r *WeightRoundRobinBalance) Next() string { total := 0 var best *WeightNode for i := 0; i \u003c len(r.rss); i++ { w := r.rss[i] //step 1 统计所有有效权重之和 total += w.effectiveWeight //step 2 变更节点临时权重为的节点临时权重+节点有效权重 w.currentWeight += w.effectiveWeight //step 3 有效权重默认与权重相同，通讯异常时-1, 通讯成功+1，直到恢复到weight大小 if w.effectiveWeight \u003c w.weight { w.effectiveWeight++ } //step 4 选择最大临时权重点节点 if best == nil || w.currentWeight \u003e best.currentWeight { best = w } } if best == nil { return \"\" } //step 5 变更临时权重为 临时权重-有效权重之和 best.currentWeight -= total return best.addr } func (r *WeightRoundRobinBalance) Get(key string) (string, error) { return r.Next(), nil } func (r *WeightRoundRobinBalance) SetConf(conf LoadBalanceConf) { r.conf = conf } func (r *WeightRoundRobinBalance) Update() { if conf, ok := r.conf.(*LoadBalanceZkConf); o","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:4:1","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r2. ReverseProxy 集成负载均衡 main.go package main import ( \"bytes\" \"io/ioutil\" \"log\" \"net\" \"net/http\" \"net/http/httputil\" \"net/url\" \"picturePro/http/loadBalance\" \"strconv\" \"strings\" \"time\" ) var ( addr = \"127.0.0.1:2002\" transport = \u0026http.Transport{ DialContext: (\u0026net.Dialer{ Timeout: 30 * time.Second, //连接超时 KeepAlive: 30 * time.Second, //长连接超时时间 }).DialContext, MaxIdleConns: 100, //最大空闲连接 IdleConnTimeout: 90 * time.Second, //空闲超时时间 TLSHandshakeTimeout: 10 * time.Second, //tls握手超时时间 ExpectContinueTimeout: 1 * time.Second, //100-continue状态码超时时间 } ) func NewMultipleHostsReverseProxy(lb loadBalance.LoadBalance) *httputil.ReverseProxy { //请求协调者 director := func(req *http.Request) { nextAddr, err := lb.Get(req.RemoteAddr) if err != nil { log.Fatal(\"get next addr fail\") } target, err := url.Parse(nextAddr) if err != nil { log.Fatal(err) } targetQuery := target.RawQuery req.URL.Scheme = target.Scheme req.URL.Host = target.Host req.URL.Path = singleJoiningSlash(target.Path, req.URL.Path) if targetQuery == \"\" || req.URL.RawQuery == \"\" { req.URL.RawQuery = targetQuery + req.URL.RawQuery } else { req.URL.RawQuery = targetQuery + \"\u0026\" + req.URL.RawQuery } if _, ok := req.Header[\"User-Agent\"]; !ok { req.Header.Set(\"User-Agent\", \"user-agent\") } } //更改内容 modifyFunc := func(resp *http.Response) error { //请求以下命令：curl 'http://127.0.0.1:2002/error' if resp.StatusCode != 200 { //获取内容 oldPayload, err := ioutil.ReadAll(resp.Body) if err != nil { return err } //追加内容 newPayload := []byte(\"StatusCode error:\" + string(oldPayload)) resp.Body = ioutil.NopCloser(bytes.NewBuffer(newPayload)) resp.ContentLength = int64(len(newPayload)) resp.Header.Set(\"Content-Length\", strconv.FormatInt(int64(len(newPayload)), 10)) } return nil } //错误回调 ：关闭real_server时测试，错误回调 //范围：transport.RoundTrip发生的错误、以及ModifyResponse发生的错误 errFunc := func(w http.ResponseWriter, r *http.Request, err error) { //todo 如果是权重的负载则调整临时权重 http.Error(w, \"ErrorHandler error:\"+err.Error(), 500) } return \u0026httputil.ReverseProxy{Director: director, Transport: transport, ModifyResponse: modifyFunc, ErrorHandler: errFunc} } func singleJoiningSlash(a, b string) string { aslash := strings.HasSuffix(a, \"/\") bslash := strings.HasPrefix(b, \"/\") switch { case aslash \u0026\u0026 bslash: return a + b[1:] case !aslash \u0026\u0026 !bslash: return a + \"/\" + b } return a + b } func main() { rb := loadBalance.LoadBanlanceFactory(loadBalance.LbRoundRobin) if err := rb.Add(\"http://127.0.0.1:2003/base\", \"10\"); err != nil { log.Println(err) } if err := rb.Add(\"http://127.0.0.1:2004/base\", \"20\"); err != nil { log.Println(err) } proxy := NewMultipleHostsReverseProxy(rb) log.Println(\"Starting httpserver at \" + addr) log.Fatal(http.ListenAndServe(addr, proxy)) } factory.go package loadBalance type LbType int const ( LbRandom LbType = iota LbRoundRobin LbWeightRoundRobin LbConsistentHash ) func LoadBanlanceFactory(lbType LbType) LoadBalance { switch lbType { case LbRandom: return \u0026RandomBalance{} case LbConsistentHash: return NewConsistentHashBalance(10, nil) case LbRoundRobin: return \u0026RoundRobinBalance{} case LbWeightRoundRobin: return \u0026WeightRoundRobinBalance{} default: return \u0026RandomBalance{} } } func LoadBanlanceFactorWithConf(lbType LbType, mConf LoadBalanceConf) LoadBalance { //观察者模式 switch lbType { case LbRandom: lb := \u0026RandomBalance{} lb.SetConf(mConf) mConf.Attach(lb) lb.Update() return lb case LbConsistentHash: lb := NewConsistentHashBalance(10, nil) lb.SetConf(mConf) mConf.Attach(lb) lb.Update() return lb case LbRoundRobin: lb := \u0026RoundRobinBalance{} lb.SetConf(mConf) mConf.Attach(lb) lb.Update() return lb case LbWeightRoundRobin: lb := \u0026WeightRoundRobinBalance{} lb.SetConf(mConf) mConf.Attach(lb) lb.Update() return lb default: lb := \u0026RandomBalance{} lb.SetConf(mConf) mConf.Attach(lb) lb.Update() return lb } } Config.go package loadBalance import ( \"fmt\" \"picturePro/http/loadBalance/zookeeper\" ) // 配置主题 type LoadBalanceConf interface { Attach(o Observer) GetConf() []string WatchConf() UpdateConf(conf []string) } type LoadBalanceZkConf s","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180323/:4:2","tags":null,"title":"22.go与http代理","uri":"/lang/go/go_advanced/20250515180323/"},{"categories":null,"content":"\r什么是netgo Go语言的网络库是基于操作系统提供的系统调用(syscall)实现的。在大多数现代操作系统上，这些系统调用都是由C语言实现的，经过高度优化，性能非常好。但在某些特殊的架构或操作系统上，系统网络调用可能无法正常工作，或者效率较低。 为了解决这个可移植性问题，Go语言还提供了一个纯Go实现的网络库。这个网络库不依赖于操作系统的系统调用，而是使用Go语言的运行时(runtime)来处理网络通信。由于Go运行时本身就是跨平台的，因此纯Go网络库也就获得了良好的可移植性。 netgo是Go编译器的一个命令行标志，它控制编译产生的可执行文件所使用的网络库实现。Go语言的网络库默认是基于操作系统提供的系统调用(syscall)实现的，但也提供了一个纯Go语言实现的网络库作为可选方案，netgo标志就是用来选择使用哪种网络库实现。 不使用netgo标志时，编译器会链接并使用操作系统提供的系统网络调用库，这通常可以获得更好的网络性能。 使用netgo标志(go build -netgo)时，编译器会链接纯Go实现的网络库，虽然性能可能会略低，但提高了可移植性。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180316/:1:0","tags":null,"title":"21.go编译参数netgo","uri":"/lang/go/go_advanced/20250515180316/"},{"categories":null,"content":"\rnetgo使用场景 一般来说，只有在以下情况下才需要使用-netgo标志: 目标系统不支持Go默认网络库:某些特殊的架构或操作系统可能无法正常支持Go语言默认使用的基于系统调用的网络库实现，此时需要使用纯Go网络库来获得可移植性。比如我们项目从arm架构适配申威架构，出现网络调用程序panic，需要使用netgo； 需要跨平台可移植性:如果你需要在多个操作系统平台上运行你的Go程序，而这些平台的系统网络调用存在不兼容的情况，使用纯Go网络库就可以提高可移植性。 真实生产环境panic报错部分信息，最后通过使用netgo方式解决 系统架构 sw64 linux fatal error: unexpected signal during runtime execution [signal SIGSEGV: segmentation violation code=0x1 addr=0x46 pc=0x416263ca3ea4] runtime stack: runtime.throw({0x121da53a3, 0x2a}) /go/src/runtime/panic.go:992 +0x94 runtime.sigpanic() /go/src/runtime/signal_unix.go:802 +0x4e0 goroutine 1233 [syscall]: runtime.cgocall(0x1218d90b0, 0xc00be65c8) /go/src/runtime/cgocall.go:157 +0x60 fp=0xc00be6598 sp=0xc00be6568 pc=0x120005190 net._C2func_getaddrinfo(0xc003cc870, 0x0, 0xc00c457a0, 0xc01686180) _cgo_gotypes.go:94 +0x8c fp=0xc00be65c0 sp=0xc00be6598 pc=0x1202c825c net.cgoLookupIPCNAME.func1({0xc003cc870, 0x2f, 0x2f}, 0xc00c457a0, 0xc01686180) /go/src/net/cgo_unix.go:160 +0x140 fp=0xc00be6600 sp=0xc00be65c0 pc=0x1202caee0 net.cgoLookupIPCNAME({0x121d544ba, 0x3}, {0xc004be540, 0x2e}) /go/src/net/cgo_unix.go:160 +0x210 fp=0xc00be6710 sp=0xc00be6600 pc=0x1202ca420 net.cgoIPLookup(0xc02494720, {0x121d544ba, 0x3}, {0xc004be540, 0x2e}) /go/src/net/cgo_unix.go:217 +0x8c fp=0xc00be67a8 sp=0xc00be6710 pc=0x1202cafcc net.cgoLookupIP.func1() /go/src/net/cgo_unix.go:227 +0xac fp=0xc00be67d8 sp=0xc00be67a8 pc=0x1202cb62c runtime.goexit() /go/src/runtime/asm_sw64.s:363 +0x4 fp=0xc00be67d8 sp=0xc00be67d8 pc=0x1200b9c54 created by net.cgoLookupIP /go/src/net/cgo_unix.go:227 +0x208 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180316/:2:0","tags":null,"title":"21.go编译参数netgo","uri":"/lang/go/go_advanced/20250515180316/"},{"categories":null,"content":"\rnetgo使用方式 在Go命令中使用-netgo标志非常简单，只需在go build或go install等编译命令中加上该标志; 加上-netgo标志后，编译器会自动链接纯Go实现的网络库，而不是默认的基于系统调用的网络库实现 go build -netgo xxx ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180316/:3:0","tags":null,"title":"21.go编译参数netgo","uri":"/lang/go/go_advanced/20250515180316/"},{"categories":null,"content":"\rgo 调用dll","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180311/:1:0","tags":null,"title":"20.go调用lib和so动态库","uri":"/lang/go/go_advanced/20250515180311/"},{"categories":null,"content":"\r1. sysCall.LoadDll(推荐使用) 系统调用是程序向操作系统内核请求服务的过程，通常包含硬件相关的服务(例如访问硬盘),创建新进程等。系统调用提供了一个进程和操作系统之间的接口 fmt中的syscall func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) } Stdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\") 调用dll 示例 dll, err := syscall.LoadDLL(\"scan.dll\") //根据名称从dll中查找proc MemoryStream_Get = dll.FindProc(\"AllocateMemory\") MemoryStream_Get.Call() 此方式可以 也可以调用go 代码打包的dll ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180311/:1:1","tags":null,"title":"20.go调用lib和so动态库","uri":"/lang/go/go_advanced/20250515180311/"},{"categories":null,"content":"\r2. Cgo调用 项目目录结构如下 ├── include │ └── add.c │ └── add.h ├── lib │ └── libadd.dll └── main.go add.h #ifndef __ADD_H__ #define __ADD_H__ char* Add(char* src, int n); #endif add.c #include \u003cstring.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e char* Add(char* src, int n) { char str[20]; sprintf(str, \"%d\", n); char *result = malloc(strlen(src)+strlen(str)+1); strcpy(result, src); strcat(result, str); return result; } main.go func GetFinalStrategyString(request string) { dll, err := syscall.LoadDLL(\"./middleware_c.dll\") if err != nil { log.Fatal(\"Error loading DLL:\", err) } defer dll.Release() getFinalStrategyString, err := dll.FindProc(\"GetFinalStrategyString\") if err != nil { log.Fatal(\"Error finding GetFinalStrategyString:\", err) } freeFinalStrategyString, err := dll.FindProc(\"FreeFinalStrategyString\") if err != nil { log.Fatal(\"Error finding FreeFinalStrategyString:\", err) } // cRequest, err := syscall.UTF16PtrFromString(request) // if err != nil { // log.Fatal(\"Error converting request:\", err) // } var cResponse *uint16 var responseLen uint32 ret, _, _ := getFinalStrategyString.Call( uintptr(unsafe.Pointer(request)), uintptr(len(request)), uintptr(unsafe.Pointer(\u0026cResponse)), uintptr(unsafe.Pointer(\u0026responseLen)), ) if ret != 0 { log.Fatal(\"ret Error:\", ret) } fmt.Println(\"responseLen:\", responseLen) fmt.Println(\"cResponse:\", cResponse) cResponseBytes := (*[1 \u003c\u003c 20]byte)(unsafe.Pointer(cResponse))[:responseLen] fmt.Println(\"cResponseBytes:\", cResponseBytes) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180311/:1:2","tags":null,"title":"20.go调用lib和so动态库","uri":"/lang/go/go_advanced/20250515180311/"},{"categories":null,"content":"\r3. 动态调用 dll （推荐使用） 动态调用步骤 通过文件路径加载c/c++ 动态库中的 handle 在go代码中定义和c/c++ 动态库中对应的go func 使用库purego（底层是dlopen）或者sys/windows 将handle中对应的方法符号（Symbol）映射到 go func 地址上 逻辑调用 main.go import \"C\" import ( \"context\" \"fmt\" \"github.com/ebitengine/purego\" \"sync\" ) var ( getFinalStrategyString func(*C.char, C.uint, **C.char, *C.uint) C.int //2. 定义和c/c++ 动态库中对应的go func freeFinalStrategyString func(*C.char) // 2. 定义和c/c++ 动态库中对应的go func mcRunModeOnce sync.Once mcRunMode int ) func main(){ InitMC(libFilePath) } func InitMC(libFilePath string) (err error) { defer func() { if _err := recover(); _err != nil { logger.Errorf(\"RegisterLibFunc panic error: %v\", err) err = fmt.Errorf(\"RegisterLibFunc panic error: %v\", err.Error()) } }() ... mcHandle, err := LoadHandle(libFilePath) // 1. 通过路径加载c/c++ 动态库handle if err != nil { logger.Errorf(\"LoadHandle error:%v\", err.Error()) return err } // 找不到函数会panic purego.RegisterLibFunc(\u0026getFinalStrategyString, mcHandle, \"GetFinalStrategyString\") // 3. 使用库purego将handle中对应的方法映射到go func purego.RegisterLibFunc(\u0026freeFinalStrategyString, mcHandle, \"FreeFinalStrategyString\") // 3. 使用库purego将handle中对应的方法映射到go func return nil } load_linux.go //go:build !windows // +build !windows package main import \"github.com/ebitengine/purego\" const MCLibPath = \"c.so\" func LoadHandle(libPath string) (uintptr, error) { return purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL) } load_windows.go //go:build windows // +build windows package main import \"golang.org/x/sys/windows\" const MCLibPath = \"\" func LoadHandle(libPath string) (uintptr, error) { handle, err := windows.LoadLibrary(libPath) return uintptr(handle), err } 业务调用 c++ 头文件 #ifdef __cplusplus extern “C” { #endif MIDDLEWARE_C_EXPORT int GetFinalStrategyString( /::browserconsoleapiv3::middle_ware::GetUserStrategiesRequest request/ const char* request, unsigned request_len, /::browserconsoleapiv3::api::user::FinalGroupStrategy response/ char** response, unsigned* response_len); MIDDLEWARE_C_EXPORT void FreeFinalStrategyString(const char*); #ifdef __cplusplus } #endif package middleware /* #include \u003cstdlib.h\u003e // 要引入 */ import \"C\" import ( \"fmt\" \"unsafe\" ) type MiddlewareC struct { response *C.char } func (mc *MiddlewareC) GetFinalStrategyString(req string) (resByte []byte, err error) { cRequest := C.CString(req) defer C.free(unsafe.Pointer(cRequest)) var ( reqLen C.uint cResponse *C.char responseLen C.uint resCodeC C.int ) reqLen = C.uint(len(req)) resCodeC = getFinalStrategyString(cRequest, reqLen, \u0026cResponse, \u0026responseLen) //4. 真正的业务调用 resCode := int(resCodeC) if resCode != 0 { errMsg, ok := MCError[resCode] if !ok { err = fmt.Errorf( \"unknown error code, code:%v, cResponse: %v, cResponse len: %v\", resCode, cResponse, responseLen, ) } else { err = fmt.Errorf( \"middleware error msg: %v, error code: %v, cResponse: %v, cResponse len: %v\", errMsg, resCode, cResponse, responseLen, ) } return resByte, err } resByte = C.GoBytes(unsafe.Pointer(cResponse), C.int(responseLen)) mc.response = cResponse return resByte, nil } func (mc *MiddlewareC) MustFreeFinalStrategyString() { freeFinalStrategyString(mc.response) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180311/:1:3","tags":null,"title":"20.go调用lib和so动态库","uri":"/lang/go/go_advanced/20250515180311/"},{"categories":null,"content":"\rgo 调用so","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180311/:2:0","tags":null,"title":"20.go调用lib和so动态库","uri":"/lang/go/go_advanced/20250515180311/"},{"categories":null,"content":"\r1. Cgo调用 项目目录结构如下 ├── include │ └── add.c │ └── add.h ├── lib │ └── libadd.so └── main.go add.h #ifndef __ADD_H__ #define __ADD_H__ char* Add(char* src, int n); #endif add.c #include \u003cstring.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e char* Add(char* src, int n) { char str[20]; sprintf(str, \"%d\", n); char *result = malloc(strlen(src)+strlen(str)+1); strcpy(result, src); strcat(result, str); return result; } linux 下编译 会在当前目录下生成 libadd.so 文件, 在 Linux 下可用 nm -D libadd.so 查看其中的方法 gcc -fPIC -shared -o lib/libadd.so include/add.c main.go package main /* // 头文件的位置，相对于源文件是当前目录，所以是 .，头文件在多个目录时写多个 #cgo CFLAGS: ... #cgo CFLAGS: -I./include // 从哪里加载动态库，位置与文件名，-ladd 加载 libadd.so 文件 #cgo LDFLAGS: -L./lib -ladd -Wl,-rpath,lib #include \"add.h\" */ import \"C\" import \"fmt\" func main() { val := C.Add(C.CString(\"go\"), 2023) fmt.Println(\"run c: \", C.GoString(val)) } 注意： 如果把#cgo LDFLAGS: -L./lib -ladd -Wl,-rpath,lib 改为 cgo LDFLAGS: -L./lib -ladd编译不会报错，执行时会出错 error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory 设置了环境变量 LD_LIBRARY_PATH=/home/…/lib 也能让它跑起来 LD_LIBRARY_PATH=lib/ ./demo ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180311/:2:1","tags":null,"title":"20.go调用lib和so动态库","uri":"/lang/go/go_advanced/20250515180311/"},{"categories":null,"content":"\r2. 动态调用 so（推荐使用） 动态调用步骤 通过路径加载c/c++ 动态库 handle 定义和c/c++ 动态库中对应的go func 使用库purego 将handle中对应的方法映射到go func 逻辑调用 main.go import \"C\" import ( \"context\" \"fmt\" \"github.com/ebitengine/purego\" \"sync\" ) var ( getFinalStrategyString func(*C.char, C.uint, **C.char, *C.uint) C.int //2. 定义和c/c++ 动态库中对应的go func freeFinalStrategyString func(*C.char) // 2. 定义和c/c++ 动态库中对应的go func mcRunModeOnce sync.Once mcRunMode int ) func main(){ InitMC(libFilePath) } func InitMC(libFilePath string) (err error) { defer func() { if _err := recover(); _err != nil { logger.Errorf(\"RegisterLibFunc panic error: %v\", err) err = fmt.Errorf(\"RegisterLibFunc panic error: %v\", err.Error()) } }() ... mcHandle, err := LoadHandle(libFilePath) // 1. 通过路径加载c/c++ 动态库handle if err != nil { logger.Errorf(\"LoadHandle error:%v\", err.Error()) return err } // 找不到函数会panic purego.RegisterLibFunc(\u0026getFinalStrategyString, mcHandle, \"GetFinalStrategyString\") // 3. 使用库purego将handle中对应的方法映射到go func purego.RegisterLibFunc(\u0026freeFinalStrategyString, mcHandle, \"FreeFinalStrategyString\") // 3. 使用库purego将handle中对应的方法映射到go func return nil } load_linux.go //go:build !windows // +build !windows package main import \"github.com/ebitengine/purego\" const MCLibPath = \"c.so\" func LoadHandle(libPath string) (uintptr, error) { return purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL) } load_windows.go //go:build windows // +build windows package main import \"golang.org/x/sys/windows\" const MCLibPath = \"\" func LoadHandle(libPath string) (uintptr, error) { handle, err := windows.LoadLibrary(libPath) return uintptr(handle), err } 业务调用 c++ 头文件 #ifdef __cplusplus extern “C” { #endif MIDDLEWARE_C_EXPORT int GetFinalStrategyString( /::browserconsoleapiv3::middle_ware::GetUserStrategiesRequest request/ const char* request, unsigned request_len, /::browserconsoleapiv3::api::user::FinalGroupStrategy response/ char** response, unsigned* response_len); MIDDLEWARE_C_EXPORT void FreeFinalStrategyString(const char*); #ifdef __cplusplus } #endif package middleware /* #include \u003cstdlib.h\u003e // 要引入 */ import \"C\" import ( \"fmt\" \"unsafe\" ) type MiddlewareC struct { response *C.char } func (mc *MiddlewareC) GetFinalStrategyString(req string) (resByte []byte, err error) { cRequest := C.CString(req) defer C.free(unsafe.Pointer(cRequest)) var ( reqLen C.uint cResponse *C.char responseLen C.uint resCodeC C.int ) reqLen = C.uint(len(req)) resCodeC = getFinalStrategyString(cRequest, reqLen, \u0026cResponse, \u0026responseLen) //4. 真正的业务调用 resCode := int(resCodeC) if resCode != 0 { errMsg, ok := MCError[resCode] if !ok { err = fmt.Errorf( \"unknown error code, code:%v, cResponse: %v, cResponse len: %v\", resCode, cResponse, responseLen, ) } else { err = fmt.Errorf( \"middleware error msg: %v, error code: %v, cResponse: %v, cResponse len: %v\", errMsg, resCode, cResponse, responseLen, ) } return resByte, err } resByte = C.GoBytes(unsafe.Pointer(cResponse), C.int(responseLen)) mc.response = cResponse return resByte, nil } func (mc *MiddlewareC) MustFreeFinalStrategyString() { freeFinalStrategyString(mc.response) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180311/:2:2","tags":null,"title":"20.go调用lib和so动态库","uri":"/lang/go/go_advanced/20250515180311/"},{"categories":null,"content":"\r大坑！！！ 动态库中的崩溃会直接导致主程序崩溃！！！！！！！！！！ 崩溃测试 创建崩溃程序 package main import \"C\" import \"fmt\" //export PrintTest func PrintTest() int { defer func() { if err := recover(); err != nil { print(\"err\\n\") print(err) } }() print(\"hello world\\n\") var a []int a[0] = 1 print(\"hello world 2\\n\") return 1 } func main() { fmt.Println(\"call cpp test\") } 打包dll文件go build -o pt.dll -buildmode=c-shared main.go 主程序调用 package main import \"C\" import ( \"github.com/ebitengine/purego\" win \"golang.org/x/sys/windows\" \"log\" ) var PrintTest func() int func openLibrary(name string) (uintptr, error) { handle, err := win.LoadLibrary(name) return uintptr(handle), err } func main() { // recover无效了！ defer func() { if err := recover(); err != nil { log.Println(\"err\") log.Println(err) } }() lib, err := openLibrary(\"./dll/pt.dll\") if err != nil { log.Fatalln(err) } purego.RegisterLibFunc(\u0026PrintTest, lib, \"PrintTest\") res := PrintTest() log.Println(res) } // ！！！ 直接panic，recover无效 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180311/:3:0","tags":null,"title":"20.go调用lib和so动态库","uri":"/lang/go/go_advanced/20250515180311/"},{"categories":null,"content":" 官方文档： https://pkg.go.dev/cmd/cgo 参考：https://zhuanlan.zhihu.com/p/349197066、https://juejin.cn/post/7047405294107754533、https://pkg.go.dev/cmd/cgo ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:0:0","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r初识 cgo Cgo是Go语言中的一个工具，它允许在Go代码中直接调用C语言代码，并让C语言代码调用Go代码 demo package main /* #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void myprint(char* s) { printf(\"%s\\n\", s); } */ import \"C\" import \"unsafe\" func main() { cs := C.CString(\"Hello from stdio\") C.myprint(cs) C.free(unsafe.Pointer(cs)) } // 输出： Hello from stdio 灰常神奇 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:1:0","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r在go中使用cgo","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:2:0","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r1. 开启cgo 使用go env查看, 确保 CGO_ENABLED=1 导入伪包“C” import \"C\" ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:2:1","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r2. 在go里编写c代码 如果导入“C”之前紧跟着注释，则在编译包的 C 部分时，该注释（称为前导码）将用作标头; 如果使用 C 标头，那么 注释后面要紧跟着 import \"C\" // #include \u003cstdio.h\u003e // #include \u003cerrno.h\u003e import \"C\" 可以在Go文件中通过Cgo的注释块来编写C代码。使用/* */将C代码包裹起来，将C代码直接插入Go代码中； 然后可以从 Go 代码中引用这些，就好像它们是在包“C”中定义的一样。可以使用序言中声明的所有名称，即使它们以小写字母开头； 但是前导码中的静态变量不能从 Go 代码中引用; package main /* #cgo LDFLAGS: -L/usr/local/lib #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #define REPEAT_LIMIT 3 // CGO会保留C代码块中的宏定义 typedef struct{ // 自定义结构体 int repeat_time; char* str; }blob; int SayHello(blob* pblob) { // 自定义函数 for ( ;pblob-\u003erepeat_time \u003c REPEAT_LIMIT; pblob-\u003erepeat_time++){ puts(pblob-\u003estr); } return 0; } */ import \"C\" import ( \"fmt\" \"unsafe\" ) func main() { cblob := C.blob{} // 在GO程序中创建的C对象，存储在Go的内存空间 cblob.repeat_time = 0 cblob.str = C.CString(\"Hello, World\\n\") // C.CString 会在C的内存空间申请一个C语言字符串对象，再将Go字符串拷贝到C字符串 ret := C.SayHello(\u0026cblob) // \u0026cblob 取C语言对象cblob的地址 fmt.Println(\"ret\", ret) fmt.Println(\"repeat_time\", cblob.repeat_time) C.free(unsafe.Pointer(cblob.str)) // C.CString 申请的C空间内存不会自动释放，需要显示调用C中的free释放 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:2:2","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\rCGO 的 N 种用法","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:3:0","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r1. Go 调用自定义 C 程序 demo package main /* #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void myprint(char* s) { printf(\"%s\\n\", s); } */ import \"C\" import \"unsafe\" func main() { cs := C.CString(\"Hello from stdio\") C.myprint(cs) C.free(unsafe.Pointer(cs)) // 由于 C 的内存空间不受 Go 的 GC 管理，因此需要显示的调用 C 语言的 free 来进行回收 } // 输出： Hello from stdio ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:3:1","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r2. Go 调用 C 模块 hello.c 文件 #include \u003cstdio.h\u003e int SayHello() { puts(\"Hello World\"); return 0; } main.go main 中只对 SayHello 函数进行了声明，然后再通过链接 C 程序库的方式加载函数的实现 package main /* #include \"hello.c\" int SayHello(); */ import \"C\" import ( \"fmt\" ) func main() { ret := C.SayHello() // Hello World fmt.Println(ret) // 0 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:3:2","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r3. Go 调用 C++模块 通过链接 C++程序库的方式，来实现 Go 调用 C++程序 hello.h int SayHello(); hello.cpp #include \u003ciostream\u003e extern \"C\" { #include \"hello.h\" } int SayHello() { std::cout\u003c\u003c\"Hello World\"; return 0; } main.go CGO 提供的这种面向 C 语言接口的编程方式，使得开发者可以使用是任何编程语言来对接口进行实现，只要最终满足 C 语言接口即可。 package main /* #include \"hello.h\" */ import \"C\" import ( \"fmt\" ) func main() { ret := C.SayHello() fmt.Println(ret) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:3:3","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r4. go 调用C语言动态库 项目目录结构如下 ├── include │ └── add.c │ └── add.h ├── lib │ └── libadd.so └── main.go add.h #ifndef __ADD_H__ #define __ADD_H__ char* Add(char* src, int n); #endif add.c #include \u003cstring.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e char* Add(char* src, int n) { char str[20]; sprintf(str, \"%d\", n); char *result = malloc(strlen(src)+strlen(str)+1); strcpy(result, src); strcat(result, str); return result; } linux 下编译 会在当前目录下生成 libadd.so 文件, 在 Linux 下可用 nm -D libadd.so 查看其中的方法 gcc -fPIC -shared -o lib/libadd.so include/add.c main.go package main /* // 头文件的位置，相对于源文件是当前目录，所以是 .，头文件在多个目录时写多个 #cgo CFLAGS: ... #cgo CFLAGS: -I./include // 从哪里加载动态库，位置与文件名，-ladd 加载 libadd.so 文件 #cgo LDFLAGS: -L./lib -ladd -Wl,-rpath,lib #include \"add.h\" */ import \"C\" import \"fmt\" func main() { val := C.Add(C.CString(\"go\"), 2023) fmt.Println(\"run c: \", C.GoString(val)) } 注意： 如果把#cgo LDFLAGS: -L./lib -ladd -Wl,-rpath,lib 改为 cgo LDFLAGS: -L./lib -ladd编译不会报错，执行时会出错 error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory 设置了环境变量 LD_LIBRARY_PATH=/home/…/lib 也能让它跑起来 LD_LIBRARY_PATH=lib/ ./demo ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:3:4","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r5. C 调用 Go 模块 C 调用 Go 相对于 Go 调 C 来说要复杂多，可以分为两种情况 一是原生 Go 进程调用 C，C 中再反调 Go 程序。 另一种是原生 C 进程直接调用 Go。 5.1 go 实现c的函数 Go 程序先调用 C 的 SayHello 接口，由于 SayHello 接口链接在 Go 的实现上，又调到 Go。 看起来调起方和实现方都是 Go，但实际执行顺序是 Go 的 main 函数，调到 CGO 生成的 C 桥接函数，最后 C 桥接函数再调到 Go 的 SayHello demo/hello.h void SayHello(char* s); demo/hello.go CGO 的//export SayHello 指令将 Go 语言实现的 SayHello 函数导出为 C 语言函数。这样再 Go 中调用 C.SayHello 时，最终调用的是 hello.go 中定义的 Go 函数 SayHello package main // #include \u003chello.h\u003e import \"C\" import \"fmt\" //export SayHello func SayHello(str *C.char) { fmt.Println(C.GoString(str)) } demo/main.go go run ..\\demo\\ package main // #include \"hello.h\" import \"C\" func main() { C.SayHello(C.CString(\"Hello World\")) // Hello World } 5.2 原生 C 调用 Go hello.go package main import \"C\" //export hello func hello(value string)*C.char { // 如果函数有返回值，则要将返回值转换为C语言对应的类型;如果 Go 函数有多个返回值，会生成一个 C 结构体进行返回，结构体定义参考生成的.h 文件 return C.CString(\"hello\" + value) } func main(){ // 此处一定要有main函数，有main函数才能让cgo编译器去把包编译成C的库 } 生成c-shared文件 go build -buildmode=c-shared -o hello.so hello.go hello.c #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \"hello.h\" //此处为上一步生成的.h文件 int main(){ char c1[] = \"did\"; GoString s1 = {c1,strlen(c1)}; //构建Go语言的字符串类型 char *c = hello(s1); printf(\"r:%s\",c); return 0; } 编译gcc -o c_go main.c hello.so ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:3:5","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\rCFLAGS 与 LDFLAGS 参数含义 **CFLAGS ** : 头文件的位置，相对于源文件是当前目录;头文件在多个目录时写多个 #cgo CFLAGS: … LDFLAGS ：从哪里加载动态库，位置与文件名，e.g.: -ladd 加载 libadd.so 文件 /* // 头文件的位置，相对于源文件是当前目录，所以是 .，头文件在多个目录时写多个 #cgo CFLAGS: ... #cgo CFLAGS: -I./include // 从哪里加载动态库，位置与文件名，-ladd 加载 libadd.so 文件 #cgo LDFLAGS: -L./lib -ladd -Wl,-rpath,lib #include \"add.h\" */ 在指定目录找不到对应的文件或者库时会报错！！！ 软件包中的所有 cgo CPPFLAG 和 CFLAGS 指令都连接起来并用于编译该软件包中的 C 文件。包中的所有 CPPFLAGS 和 CXXFLAGS 指令都连接起来，用于编译该包中的C++文件 解析 cgo 指令时，任何出现的字符串 ${SRCDIR} 都将替换为包含源文件的目录的绝对路径。这允许将预编译的静态库包含在包目录中并正确链接。例如，如果 package foo 位于目录 /go/src/foo 中： // #cgo LDFLAGS: -L${SRCDIR}/libs -lfoo 将扩展到=\u003e // #cgo LDFLAGS: -L/go/src/foo/libs -lfoo ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:4:0","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\rCGO 与 Go类型转换 标准 Cgo 类型 C.char、C.schar（有符号 char）、C.uchar （无符号字符）、C.short、C.ushort （无符号短）、C.int、C.uint（无符号整数）、C.long、C.ulong （无符号长）、C.longlong（长长）、C.ulonglong（无符号长长）、C.float、C.double、C.complexfloat（复数浮点数）和 C.complexdouble（复数双精度） 对照关系 C类型 Cgo类型 go类型 字节数（byte） 数值范围 char C.char byte 1 -128~127 signed char C.schar int8 1 -128~127 unsigned char C.uchar uint8 1 0~255 short int C.short int16 2 -32768~32767 short unsigned int C.ushort uint16 2 0~65535 int C.int int 4 -2147483648~2147483647 unsigned int C.uint uint32 4 0~4294967295 long int C.long int32 or int64 4 -2147483648~2147483647 long unsigned int C.ulong uint32 or uint64 4 0~4294967295 long long int C.longlong int64 8 -9223372036854776001~9223372036854775999 long long unsigned int C.ulonglong uint64 8 0~18446744073709552000 float C.float float32 4 -3.4E-38~3.4E+38 double C.double float64 8 1.7E-308~1.7E+308 wchar_t C.wchar_t wchar_t 2 0~65535 void * unsafe.Pointer Go 语言的 int 和 uint 在 32 位和 64 位系统下分别是 4 个字节和 8 个字节大小。它在 C 语言中的导出类型 GoInt 和 GoUint 在不同位数系统下内存大小也不同。如下是 64 位系统中，Go 数值类型在 C 语言的导出列表 // _cgo_export.h typedef signed char GoInt8; typedef unsigned char GoUint8; typedef short GoInt16; typedef unsigned short GoUint16; typedef int GoInt32; typedef unsigned int GoUint32; typedef long long GoInt64; typedef unsigned long long GoUint64; typedef GoInt64 GoInt; typedef GoUint64 GoUint; typedef __SIZE_TYPE__ GoUintptr; typedef float GoFloat32; typedef double GoFloat64; typedef float _Complex GoComplex64; typedef double _Complex GoComplex128; 需要注意的是在 C 语言符号名前加上 *Ctype*， 便是其在 Go 中的导出名，因此在启用 CGO 特性后，Go 语言中禁止出现以*Ctype* 开头的自定义符号名，类似的还有*Cfunc*等 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:5:0","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r1. 切片 Go 中切片的使用方法类似 C 中的数组，但是内存结构并不一样 C 中的数组实际上指的是一段连续的内存，而 Go 的切片在存储数据的连续内存基础上，还有一个头结构体，其内存结构如下 因此 Go 的切片不能直接传递给 C 使用，而是需要取切片的内部缓冲区的首地址(即首个元素的地址)来传递给 C 使用。使用这种方式把 Go 的内存空间暴露给 C 使用，可以大大减少 Go 和 C 之间参数传递时内存拷贝的消耗。 demo package main /* int SayHello(char* buff, int len) { char hello[] = \"Hello Cgo!\"; int movnum = len \u003c sizeof(hello) ? len:sizeof(hello); memcpy(buff, hello, movnum); // go字符串没有'\\0'，所以直接内存拷贝 return movnum; } */ import \"C\" import ( \"fmt\" \"unsafe\" ) func main() { buff := make([]byte, 8) C.SayHello((*C.char)(unsafe.Pointer(\u0026buff[0])), C.int(len(buff))) a := string(buff) fmt.Println(a) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:5:1","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r2. 字符串 Go 的字符串与 C 的字符串在底层的内存模型不一样： Go 的字符串并没有以’\\0’ 结尾，因此使用类似切片的方式，直接将 Go 字符串的首元素地址传递给 C 是不可行的 cgo 给出的解决方案是标准库函数 C.CString()，它会在 C 内存空间内申请足够的空间，并将 Go 字符串拷贝到 C 空间中。因此 C.CString 申请的内存在 C 空间中，因此需要显式的调用 C.free 来释放空间 C.CString()的底层实现 func _Cfunc_CString(s string) *_Ctype_char { // 从Go string 到 C char* 类型转换 p := _cgo_cmalloc(uint64(len(s)+1)) pp := (*[1\u003c\u003c30]byte)(p) copy(pp[:], s) pp[len(s)] = 0 return (*_Ctype_char)(p) } //go:cgo_unsafe_args func _cgo_cmalloc(p0 uint64) (r1 unsafe.Pointer) { _cgo_runtime_cgocall(_cgo_bb7421b6328a_Cfunc__Cmalloc, uintptr(unsafe.Pointer(\u0026p0))) if r1 == nil { runtime_throw(\"runtime: C malloc failed\") } return } 更高效的字符串传递方法 C.CString 简单安全，但是它涉及了一次从 Go 到 C 空间的内存拷贝，对于长字符串而言这会是难以忽视的开销。 Go 官方文档中声称 string 类型是”不可改变的“，但是在实操中可以发现，除了常量字符串会在编译期被分配到只读段，其他的动态生成的字符串实际上都是在堆上。 因此如果能够获得 string 的内存缓存区地址，那么就可以使用类似切片传递的方式将字符串指针和长度直接传递给 C 使用。 查阅源码，可知 String 实际上是由缓冲区首地址 和 长度构成的。这样就可以通过一些方式拿到缓存区地址。 type stringStruct struct { str unsafe.Pointer //str首地址 len int //str长度 } test11.go 将 fmt 动态生成的 string 转为自定义类型 MyString 便可以获得缓冲区首地址，将地址传入 C 函数，这样就可以在 C 空间直接操作 Go-String 的内存空间了，这样可以免去内存拷贝的消耗。 // test11.go package main /* #include \u003cstring.h\u003e int SayHello(char* buff, int len) { char hello[] = \"Hello Cgo!\"; int movnum = len \u003c sizeof(hello) ? len:sizeof(hello); memcpy(buff, hello, movnum); return movnum; } */ import \"C\" import ( \"fmt\" \"unsafe\" ) type MyString struct { Str *C.char Len int } func main() { s := fmt.Sprintf(\" \") C.SayHello((*MyString)(unsafe.Pointer(\u0026s)).Str, C.int((*MyString)(unsafe.Pointer(\u0026s)).Len)) fmt.Print(s) } 这种方法背离了 Go 语言的设计理念，如非必要，不要把这种代码带入你的工程，这里只是作为一种“黑科技”进行分享。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:5:2","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r3. 结构体，联合，枚举 cgo 中结构体，联合，枚举的使用方式类似，可以通过 C.struct_XXX 来访问 C 语言中 struct XXX 类型。union,enum 也类似 3.1 结构体 如果结构体的成员名字中碰巧是 Go 语言的关键字，可以通过在成员名开头添加下划线来访问 如果有 2 个成员：一个是以 Go 语言关键字命名，另一个刚好是以下划线和 Go 语言关键字命名，那么以 Go 语言关键字命名的成员将无法访问（被屏蔽） C 语言结构体中位字段对应的成员无法在 Go 语言中访问，如果需要操作位字段成员，需要通过在 C 语言中定义辅助函数来完成。对应零长数组的成员(C 中经典的变长数组)，无法在 Go 语言中直接访问数组的元素，但同样可以通过在 C 中定义辅助函数来访问。 结构体的内存布局按照 C 语言的通用对齐规则，在 32 位 Go 语言环境 C 语言结构体也按照 32 位对齐规则，在 64 位 Go 语言环境按照 64 位的对齐规则。对于指定了特殊对齐规则的结构体，无法在 CGO 中访问。 demo package main /* struct Test { int a; float b; double type; int size:10; int arr1[10]; int arr2[]; }; int Test_arr2_helper(struct Test * tm ,int pos){ return tm-\u003earr2[pos]; } #pragma pack(1) struct Test2 { float a; char b; int c; }; */ import \"C\" import \"fmt\" func main() { test := C.struct_Test{} fmt.Println(test.a) fmt.Println(test.b) fmt.Println(test._type) //fmt.Println(test.size) // 位数据 fmt.Println(test.arr1[0]) //fmt.Println(test.arr) // 零长数组无法直接访问 //Test_arr2_helper(\u0026test, 1) test2 := C.struct_Test2{} fmt.Println(test2.c) //fmt.Println(test2.c) // 由于内存对齐，该结构体部分字段Go无法访问 } 3.2 联合 Go 语言中并不支持 C 语言联合类型，它们会被转为对应大小的字节数组。 如果需要操作 C 语言的联合类型变量，一般有三种方法：第一种是在 C 语言中定义辅助函数；第二种是通过 Go 语言的\"encoding/binary\"手工解码成员(需要注意大端小端问题)；第三种是使用unsafe包强制转型为对应类型(这是性能最好的方式)。 demo package main /* #include \u003cstdint.h\u003e union SayHello { int Say; float Hello; }; union SayHello init_sayhello(){ union SayHello us; us.Say = 100; return us; } int SayHello_Say_helper(union SayHello * us){ return us-\u003eSay; } */ import \"C\" import ( \"fmt\" \"unsafe\" \"encoding/binary\" ) func main() { SayHello := C.init_sayhello() fmt.Println(\"C-helper \",C.SayHello_Say_helper(\u0026SayHello)) // 通过C辅助函数 buff := C.GoBytes(unsafe.Pointer(\u0026SayHello), 4) Say2 := binary.LittleEndian.Uint32(buff) fmt.Println(\"binary \",Say2) // 从内存直接解码一个int32 fmt.Println(\"unsafe modify \", *(*C.int)(unsafe.Pointer(\u0026SayHello))) // 强制类型转换 } 3.3 枚举 对于枚举类型，可以通过C.enum_xxx来访问 C 语言中定义的enum xxx结构体类型, 使用方式和 C 相同 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:5:3","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\r4. 指针 如果一个指针类型是用 type 命令在另一个指针类型基础之上构建的，换言之两个指针底层是相同完全结构的指针，那么也可以通过直接强制转换语法进行指针间的转换。在 Go 语言中两个指针的类型完全一致则不需要转换可以直接通用。 但是 C 语言中，不同类型的指针是可以显式或隐式转换。cgo 经常要面对的是 2 个完全不同类型的指针间的转换，实现这一转换的关键就是 unsafe.Pointer,类似于 C 语言中的 Void*类型指针 使用这种方式就可以实现不同类型间的转换，如下是从 Go - int32 到 *C.char 的转换。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180308/:5:4","tags":null,"title":"19.cgo教程","uri":"/lang/go/go_advanced/20250515180308/"},{"categories":null,"content":"\rHeap - 堆","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:1:0","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r1. Heap - 堆 堆分为两种：最大堆和最小堆，两者的差别在于节点的排序方式 堆是一棵完全树（complete tree）：即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入 在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立 而对于最小堆，根节点中的元素总是树中的最小值。堆属性非常有用，因为堆常常被当做优先队列使用，因为可以快速地访问到“最重要”的元素 **注意：**堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。–唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:1:1","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r2. 堆与搜索二叉树的区别 堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别： **节点的顺序：**在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。 **内存占用：**普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。堆仅仅使用一个数据来存储数组，且不使用指针。 平衡：二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能 **搜索:**在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:1:2","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r3. container/heap 实现接口一共有五个（sort.Interface 3个 + heap.Interface 2个） // sort.Interface type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with index i must sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } // heap.Interface type Interface interface { sort.Interface Push(x any) // add x as element Len() Pop() any // remove and return element Len() - 1. } 其中heap包单独暴露了一些方法： 接口都需要传入上述接口的实例化对象 不要混淆heap.Push和自己slice实现的Push方法 开发者实现的Push方法仅仅是对slice操作 heap.Push调用了slice的Push操作，还需要额外的调整用以维护heap性质 // 建堆， 对heap进行初始化，生成小根堆（或大根堆） func Init(h Interface) // 插入元素 func Push(h Interface, x interface{}) // 弹出root元素 func Pop(h Interface) interface{} // Update元素(包括优先级)，从i位置数据发生改变后，对堆再平衡，优先级队列的实现会使用此方法 func Fix(h Interface, i int) // 删除，从指定位置删除数据，并返回删除的数据，同时亦涉及到堆的再平衡 func Remove(h Interface, i int) interface{} 3.1 Init Init 为初始化建立 heap 的方法, 该方法调用了heap.down 方法 在 Init 方法中，调整的位置，第 1 个的元素的位置是 n/2-1 个，符合最小堆的特性；最后一个位置是堆顶的位置 0 heap.down 方法的作用是，任选一个元素 i，将与其子节点 2i+1 和 2i+2 比较，如果 i 比它的子节点小，则将 i 与两个子节点中较小的节点交换（代码中的 j）；子节点 j 再与它的子节点，继续比较、交换，直到数组末尾、或者待比较的元素比它的两个子节点都小，跳出当前的 heap.down 循环 // A heap must be initialized before any of the heap operations // can be used. Init is idempotent with respect to the heap invariants // and may be called whenever the heap invariants may have been invalidated. // Its complexity is O(n) where n = h.Len(). // func Init(h Interface) { // heapify n := h.Len() //堆长度，下标从0 ~ n-1 for i := n/2 - 1; i \u003e= 0; i-- { // 从长度的一半开始，一直到第0个数据，每个位置都调用down方法，down方法实现的功能是保证从该位置往下保证形成堆 down(h, i, n) } } // 给定类型，需要调整的元素在数组中的索引以及 heap 的长度 // 将该元素下沉到该元素对应的子树合适的位置，从而满足该子树为最小堆 func down(h Interface, i0, n int) bool { i := i0 // 中间变量，初始化保存为：往下调整为heap所在的节点位置 for { j1 := 2*i + 1 // i节点的左子孩子 if j1 \u003e= n || j1 \u003c 0 { // j1 \u003c 0 after int overflow // 如果j1 越界了，说明已经调整完成了，可以退出循环 break } j := j1 // left child //中间变量j先赋值为左子孩子，之后j将被赋值为左右子孩子中最小（大）的一个孩子的位置 if j2 := j1 + 1; j2 \u003cn \u0026\u0026 h.Less(j2, j1) { j = j2 // = 2*i + 2 // right child } //j被赋值为两个孩子中的最小（大）孩子的位置（由开发者实现的Less方法决定） if !h.Less(j, i) { // 比较孩子和当前的父亲节点，如果满足堆的要求了，退出循环（注意：j在前，i在后，结果取非） break } h.Swap(i, j) // 否则交换i和j位置的值，继续比较 i = j // 保存j的位置，继续向下调整，保证j位置的子树是heap结构 } //这个结果有点意思：如果i\u003ei0，说明调整了，返回true；否则，未调整返回false return i \u003e i0 } 3.2 Push Push 方法保证插入新元素时，顺序数组 h 仍然是一个 heap；和上面的描述一致，将 x 元素插入到了数组的末尾位置，再调用 up 方法自下而上进行调整，使其满足 heap 的性质 heap.up 方法也较易理解：依此（for loop）查找元素 j 的父节点（i），如果 j 比父节点 i 要小，则交换这两个节点，并继续向再上一级的父节点比较，直到根节点，或者元素 j 大于 父节点 i（调整完毕，无需再继续进行） // Push pushes the element x onto the heap. The complexity is // O(log(n)) where n = h.Len(). func Push(h Interface, x interface{}) { // 将新插入进来的节点放到最后（调用开发者封装的Push） h.Push(x) // 自下而上调整 up(h, h.Len()-1) } func up(h Interface, j int) { for { i := (j - 1) / 2 // parent（j节点的父节点） if i == j || !h.Less(j, i) { // 如果越界，或者满足堆的条件（使用开发者实现的Less方法），则结束for循环 break } // 否则将该节点和父节点交换，继续下一轮比较 h.Swap(i, j) j = i // 交换当前位置，对父节点继续进行检查直到根节点 } } 3.3 Pop heap.Pop 方法是取出堆顶位置的数据（minheap 为最小），取完数据之后，heap 肯定不平衡。所以通常的做法是：将根节点（0 位置）与末尾节点的元素交换，并将新的根节点的元素（先前的最后一个元素）down 自上而下调整到合适的位置，满足最小堆的要求 最后再调用用户自定义的 Pop 函数获取最后一个元素即可; 这里需要区分 heap 包的 Pop 方法和用户自定义实现的 Pop 方法的根本区别，用户的 Pop 方法只是用来获取数据的 // Pop removes the minimum element (according to Less) from the heap // and returns it. The complexity is O(log(n)) where n = h.Len(). // It is equivalent to Remove(h, 0). func Pop(h Interface) interface{} { // 把最后一个节点和第一个节点进行交换，之后，从根节点开始重新保证堆结构，最后把最后那个节点数据丢出并返回 n := h.Len() - 1 h.Swap(0, n) down(h, 0, n) return h.Pop() } 3.4 Remove Remove 方法提供了删除指定位置 index 元素的实现，即先将要删除的节点 i 与末尾节点 n 交换，然后将新的节点 i 下沉或上浮到合适的位置（通俗的说，由于新数据调整，原先末尾的位置升到了它不该在的位置，需要调整这个元素，先一路 down 到底，然后再一路 up 到最终的位置） // Remove removes the element at index i from the heap. // The complexity is O(log(n)) where n = h.Len(). // func Remove(h Interface, i int) interface{} { n := h.Len() - 1 if n != i { //Pop只是Remove的特例 //Remove是把i位置的节点和最后一个节点进行交换，之后保证从i节点往下及往上都保证堆结构，最后把最后一个节点的数据返回 h.Swap(i, n) if !down(h, i, n) { up(h, i) } } return h.Po","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:1:3","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r4. 应用场景 定时器 优先级队列：比如kubernetes中的实现，FIFO-PriorityQueue heap排序 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:1:4","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r5. 代码示例\r5.1 IntHeap code // This example demonstrates an integer heap built using the heap interface. package heap_test import ( \"container/heap\" \"fmt\" ) // An IntHeap is a min-heap of ints. type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u003c h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x any) { // Push and Pop use pointer receivers because they modify the slice's length, // not just its contents. *h = append(*h, x.(int)) } func (h *IntHeap) Pop() any { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } // This example inserts several ints into an IntHeap, checks the minimum, // and removes them in order of priority. func Example_intHeap() { h := \u0026IntHeap{2, 1, 5} heap.Init(h) heap.Push(h, 3) fmt.Printf(\"minimum: %d\\n\", (*h)[0]) for h.Len() \u003e 0 { fmt.Printf(\"%d \", heap.Pop(h)) } // Output: // minimum: 1 // 1 2 3 5 } 5.2 PriorityQueue 优先队列 code // This example demonstrates a priority queue built using the heap interface. package heap_test import ( \"container/heap\" \"fmt\" ) // An Item is something we manage in a priority queue. type Item struct { value string // The value of the item; arbitrary. priority int // The priority of the item in the queue. // The index is needed by update and is maintained by the heap.Interface methods. index int // The index of the item in the heap. } // A PriorityQueue implements heap.Interface and holds Items. type PriorityQueue []*Item func (pq PriorityQueue) Len() int { return len(pq) } func (pq PriorityQueue) Less(i, j int) bool { // We want Pop to give us the highest, not lowest, priority so we use greater than here. return pq[i].priority \u003e pq[j].priority } func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] pq[i].index = i pq[j].index = j } func (pq *PriorityQueue) Push(x any) { n := len(*pq) item := x.(*Item) item.index = n *pq = append(*pq, item) } func (pq *PriorityQueue) Pop() any { old := *pq n := len(old) item := old[n-1] old[n-1] = nil // avoid memory leak item.index = -1 // for safety *pq = old[0 : n-1] return item } // update modifies the priority and value of an Item in the queue. func (pq *PriorityQueue) update(item *Item, value string, priority int) { item.value = value item.priority = priority heap.Fix(pq, item.index) } // This example creates a PriorityQueue with some items, adds and manipulates an item, // and then removes the items in priority order. func Example_priorityQueue() { // Some items and their priorities. items := map[string]int{ \"banana\": 3, \"apple\": 2, \"pear\": 4, } // Create a priority queue, put the items in it, and // establish the priority queue (heap) invariants. pq := make(PriorityQueue, len(items)) i := 0 for value, priority := range items { pq[i] = \u0026Item{ value: value, priority: priority, index: i, } i++ } heap.Init(\u0026pq) // Insert a new item and then modify its priority. item := \u0026Item{ value: \"orange\", priority: 1, } heap.Push(\u0026pq, item) pq.update(item, item.value, 5) // Take the items out; they arrive in decreasing priority order. for pq.Len() \u003e 0 { item := heap.Pop(\u0026pq).(*Item) fmt.Printf(\"%.2d:%s \", item.priority, item.value) } // Output: // 05:orange 04:pear 03:banana 02:apple } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:1:5","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\rList - 双向链表","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:2:0","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r0. 结构 type List struct { root Element // sentinel list element, only \u0026root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element } type Element struct { next, prev *Element list *List Value any } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:2:1","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r1. 代码示例 code func Example() { // Create a new list and put some numbers in it. l := list.New() e4 := l.PushBack(4) e1 := l.PushFront(1) l.InsertBefore(3, e4) l.InsertAfter(2, e1) // Iterate through list and print its contents. for e := l.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } // Output: // 1 // 2 // 3 // 4 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:2:2","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r2. Element的方法 func (e *Element) Next() *Element // 返回该元素的下一个元素，如果没有下一个元素则返回 nil func (e *Element) Prev() *Element // 返回该元素的前一个元素，如果没有前一个元素则返回 nil ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:2:3","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r3. List的方法 func New() *List // 构造一个初始化的list func (l *List) Back() *Element // 获取list l的最后一个元素 func (l *List) Front() *Element // 获取list l的最后一个元素 func (l *List) Init() *List // list l 初始化或者清除 list l func (l *List) InsertAfter(v interface{}, mark *Element) *Element // 在 list l 中元素 mark 之后插入一个值为 v 的元素，并返回该元素，如果 mark 不是list中元素，则 list 不改变 func (l *List) InsertBefore(v interface{}, mark *Element) *Element // 在 list l 中元素 mark 之前插入一个值为 v 的元素，并返回该元素，如果 mark 不是list中元素，则 list 不改变 func (l *List) Len() int // 获取 list l 的长度 func (l *List) MoveAfter(e, mark *Element) // 将元素 e 移动到元素 mark 之后，如果元素e 或者 mark 不属于 list l，或者 e==mark，则 list l 不改变 func (l *List) MoveBefore(e, mark *Element) // 将元素 e 移动到元素 mark 之前，如果元素e 或者 mark 不属于 list l，或者 e==mark，则 list l 不改变 func (l *List) MoveToBack(e *Element) // 将元素 e 移动到 list l 的末尾，如果 e 不属于list l，则list不改变 func (l *List) MoveToFront(e *Element) // 将元素 e 移动到 list l 的首部，如果 e 不属于list l，则list不改变 func (l *List) PushBack(v interface{}) *Element // 在 list l 的末尾插入值为 v 的元素，并返回该元素 func (l *List) PushBackList(other *List) // 在 list l 的尾部插入另外一个 list，其中l 和 other 可以相等 func (l *List) PushFront(v interface{}) *Element // 在 list l 的首部插入值为 v 的元素，并返回该元素 func (l *List) PushFrontList(other *List) // 在 list l 的首部插入另外一个 list，其中 l 和 other 可以相等 func (l *List) Remove(e *Element) interface{} // 如果元素 e 属于list l，将其从 list 中删除，并返回元素 e 的值 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:2:4","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r4. 应用场景 时间轮的任务链表定义 Cache中实现LRU机制的链式结构 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:2:5","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r5. 注意问题与坑\r5.1 注意问题 不要使用自己构造的Element结构，作为参数传入List的方法 Remove方法是传入指定位置的元素（list的Remove实现），复杂度是O(1)，需要开发者保存对应的element的指针（地址） 若在goroutine并发环境下使用container/list链表，那么需要加锁 List并未提供Pop类方法，需要自行组合实现，不过需要加锁 List包中大部分对于e *Element进行操作的元素都可能会导致程序崩溃，其根本原因是e是一个Element类型的指针，当然其也可能为nil，但是go中list包中函数没有对其进行是否为nil的检查，变默认其非nil进行操作，所以这种情况下，便可能出现程序崩溃 5.2 坑 遍历删除List中的所有元素, 遍历删除不安全 问题code:注意到返回被删除的Element时，会将e.next = nil func main() { l := list.New() l.PushBack(1) l.PushBack(2) l.PushBack(3) l.PushBack(4) // 遍历list，删除元素 for e := l.Front(); e != nil; e = e.Next() { fmt.Println(\"removing\", e.Value) l.Remove(e) } fmt.Println(\"After Removing...\") // 遍历删除完元素后的list for e := l.Front(); e != nil; e = e.Next() { fmt.Println(e.Value) } } List大部分方法不检查传入参数为nil 并发不安全 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:2:6","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\rRing - 环形链表","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:3:0","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r0. 结构 type Ring struct { next *Ring prev *Ring Value interface{} } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:3:1","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r1. 代码示例 code func main() { // 创建一个环, 包含 3 个元素 r := ring.New(3) fmt.Printf(\"ring: %+v\\n\", *r) // 初始化 for i := 1; i \u003c= 3; i++ { r.Value = i r = r.Next() } fmt.Printf(\"init ring: %+v\\n\", *r) // sum s := 0 r.Do(func(i interface{}) { fmt.Println(i) s += i.(int) }) fmt.Printf(\"sum ring: %d\\n\", s) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:3:2","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r2. Ring 方法 func New(n int) *Ring // 用于创建一个新的 Ring, 接收一个整形参数，用于初始化 Ring 的长度 func (r *Ring) Len() int // 环长度 func (r *Ring) Next() *Ring // 返回当前元素的下个元素 func (r *Ring) Prev() *Ring // 返回当前元素的上个元素 func (r *Ring) Move(n int) *Ring // 指针从当前元素开始向后移动或者向前(n 可以为负数) // Link \u0026 Unlink 组合起来可以对多个链表进行管理 func (r *Ring) Link(s *Ring) *Ring // 将两个 ring 连接到一起 (r 不能为空) func (r *Ring) Unlink(n int) *Ring // 从当前元素开始，删除 n 个元素 func (r *Ring) Do(f func(interface{})) // Do 会依次将每个节点的 Value 当作参数调用这个函数 f, 实际上这是策略方法的引用，通过传递不同的函数以在同一个 ring 上实现多种不同的操作。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:3:3","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r3. 应用场景 构造定长环回队列，如保存固定长度的数据等 用作固定长度的对象缓冲区（参见goim的数据结构分析） ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:3:4","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r4. ring 和 list的区别 Ring 类型的数据结构仅由它自身即可代表，而 List 类型则需要由它以及 Element 类型联合表示 一个 Ring 类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个 List 类型的值则代表了一个完整的链表 在创建并初始化一个 Ring 时，可以指定它包含的元素数量，但是对于一个 List 值来说却不需要。循环链表一旦被创建，其长度是不可变的 通过 var r ring.Ring 声明的 r 将会是一个长度为 1 的循环链表，而 List 类型的零值则是一个长度为 0 的链表。)（List 中的根元素不会持有实际元素的值） Ring 的 Len 方法的算法复杂度是 O(N)，而 List 的 Len 算法复杂度是 O(1) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180306/:3:5","tags":null,"title":"18. 标准库container三剑客：head、list、ring","uri":"/lang/go/go_advanced/20250515180306/"},{"categories":null,"content":"\r1 执行外部命令","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180303/:1:0","tags":null,"title":"17. go执行外部命令","uri":"/lang/go/go_advanced/20250515180303/"},{"categories":null,"content":"\r1.1 1. 方式一：run code func main() { cmd := exec.Command(\"ls\", \"-l\", \"/var/log/\") err := cmd.Run() if err != nil { log.Fatalf(\"cmd.Run() failed with %s\\n\", err) } } Run() 方法会启动命令并等待命令执行完毕。它会阻塞当前 goroutine 直到命令执行完毕，并返回一个 error 对象，该对象表示命令执行的错误信息。如果命令执行成功，Run() 方法会返回 nil 直接调用 Cmd 对象的 Run 函数，返回的只有成功和失败，获取不到任何输出的结果 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180303/:1:1","tags":null,"title":"17. go执行外部命令","uri":"/lang/go/go_advanced/20250515180303/"},{"categories":null,"content":"\r1.2 2. 方式二：start \u0026 wait code func main() { // 使用 Start() 方法启动命令 cmd = exec.Command(\"ping\", \"www.baidu.com\") if err := cmd.Start(); err != nil { fmt.Println(\"Error:\", err) } if err := cmd.Wait(); err != nil { fmt.Println(\"Error:\", err) } } Start() 方法会启动命令并立即返回。它不会等待命令执行完毕，而是会在后台异步执行命令。Start() 方法返回一个 error 对象，该对象表示启动命令的错误信息。如果命令启动成功，Start() 方法会返回 nil 在使用 Start() 方法启动命令后，我们可以使用 Wait() 方法等待命令执行完毕。Wait() 方法会阻塞当前 goroutine 直到命令执行完毕，并返回一个 error 对象，该对象表示命令执行的错误信息。如果命令执行成功，Wait() 方法会返回 nil ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180303/:1:2","tags":null,"title":"17. go执行外部命令","uri":"/lang/go/go_advanced/20250515180303/"},{"categories":null,"content":"\r2 输出日志 https://darjun.github.io/2022/11/01/godailylib/osexec/ ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180303/:2:0","tags":null,"title":"17. go执行外部命令","uri":"/lang/go/go_advanced/20250515180303/"},{"categories":null,"content":"\r2.1 1. 标准输出 code func main() { cmd := exec.Command(\"cal\") cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr err := cmd.Run() if err != nil { log.Fatalf(\"cmd.Run() failed: %v\\n\", err) } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180303/:2:1","tags":null,"title":"17. go执行外部命令","uri":"/lang/go/go_advanced/20250515180303/"},{"categories":null,"content":"\r2.2 2. 转存文件 code func main() { f, err := os.OpenFile(\"out.txt\", os.O_WRONLY|os.O_CREATE, os.ModePerm) if err != nil { log.Fatalf(\"os.OpenFile() failed: %v\\n\", err) } cmd := exec.Command(\"cal\") cmd.Stdout = f cmd.Stderr = f err = cmd.Run() if err != nil { log.Fatalf(\"cmd.Run() failed: %v\\n\", err) } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180303/:2:2","tags":null,"title":"17. go执行外部命令","uri":"/lang/go/go_advanced/20250515180303/"},{"categories":null,"content":"\r2.3 3. 发送到网络 code func cal(w http.ResponseWriter, r *http.Request) { year := r.URL.Query().Get(\"year\") month := r.URL.Query().Get(\"month\") cmd := exec.Command(\"cal\", month, year) cmd.Stdout = w cmd.Stderr = w err := cmd.Run() if err != nil { log.Fatalf(\"cmd.Run() failed: %v\\n\", err) } } func main() { http.HandleFunc(\"/cal\", cal) http.ListenAndServe(\":8080\", nil) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180303/:2:3","tags":null,"title":"17. go执行外部命令","uri":"/lang/go/go_advanced/20250515180303/"},{"categories":null,"content":"\r2.4 4. 手动捕获 code package middleware import ( \"bufio\" \"fmt\" \"git-biz.qianxin-inc.cn/upming/component/sdk-go-framework.git/log\" \"io\" \"os/exec\" ) type stdType int32 const ( stdTypeStdout stdType = iota + 1 stdTypeStderr ) func forkStdLog(cmd *exec.Cmd) error { // 捕获标准输出 stdout, err := cmd.StdoutPipe() if err != nil { return fmt.Errorf(\"cmd.StdoutPipe() failed with %v\", err) } go func() { printExecStd(bufio.NewReader(stdout)) }() // 捕获标准错误 stderr, err := cmd.StderrPipe() if err != nil { return fmt.Errorf(\"cmd.StderrPipe() failed with %v\", err) } go func() { // printExecStd(bufio.NewReader(stderr), stdTypeStderr) // TODO 中间件s的输出不标准，后期再处理，需要加上这个参数 printExecStd(bufio.NewReader(stderr)) }() return nil } func printExecStd(reader *bufio.Reader, std ...stdType) { logger := log.WithField(\"[ middleware_s ]\", \"printExecStd\") var s stdType if len(std) \u003e 0 { s = std[0] } else { s = stdTypeStdout } outputBytes := make([]byte, 1024) for { n, err := reader.Read(outputBytes) // 获取屏幕的实时输出(并不是按照回车分割) if err != nil { if err == io.EOF { break } logger.Errorf(\"read %s failed with %v\", std, err) } output := string(outputBytes[:n]) if s == stdTypeStdout { logger.Info(output) } else if s == stdTypeStderr { logger.Error(output) } } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180303/:2:4","tags":null,"title":"17. go执行外部命令","uri":"/lang/go/go_advanced/20250515180303/"},{"categories":null,"content":" runtime 包 提供了运行时与系统的交互，比如控制协程函数，触发垃圾立即回收等等底层操作; ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:0:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r1 runtime.GOARCH 获取 GOARCH 信息 fmt.Println(runtime.GOARCH) // arm64 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:1:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r2 runtime.GOOS 获取 GOOS 信息 fmt.Println(runtime.GOOS) // darwin ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:2:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r3 runtime.GOROOT() 获取goroot环境变量 func GOROOT() string package main import ( \"fmt\" \"runtime\" ) func main() { fmt.Println(runtime.GOROOT()) // /Users/liusaisai/.g/go fmt.Println(runtime.GOARCH) // arm64 fmt.Println(runtime.GOOS) // darwin } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:3:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r4 runtime.Version() 获取go版本 package main import ( \"fmt\" \"runtime\" ) func main() { fmt.Println(runtime.Version()) //go1.18 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:4:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r5 runtime.NumCPU() 获取机器cpu数量 package main import ( \"fmt\" \"runtime\" ) func main() { fmt.Println(runtime.NumCPU()) // 16 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:5:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r6 runtime.GOMAXPROCS(n int) GOMAXPROCS设置可同时执行的最大CPU数，并返回先前的设置。 若 n \u003c 1，它就不会更改当前设置。 package main import ( \"fmt\" \"runtime\" ) func main() { fmt.Println(runtime.GOMAXPROCS(16)) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:6:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r7 runtime.SetFinalizer() 给变量绑定方法,当垃圾回收的时候进行监听 SetFinalizer(x, f interface{}) package main import ( \"runtime\" \"time\" ) type Student struct { name string } func main() { var i *Student = new(Student) runtime.SetFinalizer(i, func(i interface{}) { println(\"垃圾回收了哦\") }) runtime.GC() time.Sleep(time.Second) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:7:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r8 runtime.GC() 进行垃圾回收 package main import ( \"runtime\" \"time\" ) type Student struct { name string } func main() { var i *Student = new(Student) runtime.SetFinalizer(i, func(i interface{}) { println(\"垃圾回收了哦\") }) runtime.GC() time.Sleep(time.Second) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:8:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r9 runtime.ReadMemStats() 查看内存申请和分配统计信息, package main import ( \"fmt\" \"runtime\" \"time\" ) type Student struct { name string } func main() { var list = make([]*Student, 0) for i := 0; i \u003c 100000; i++ { var s *Student = new(Student) list = append(list, s) } memStatus := runtime.MemStats{} runtime.ReadMemStats(\u0026memStatus) fmt.Printf(\"申请的内存:%d\\n\", memStatus.Mallocs) fmt.Printf(\"释放的内存次数:%d\\n\", memStatus.Frees) time.Sleep(time.Second) } memStatus中可以查看到的信息 type MemStats struct { // 一般统计 Alloc uint64 // 已申请且仍在使用的字节数 TotalAlloc uint64 // 已申请的总字节数（已释放的部分也算在内） Sys uint64 // 从系统中获取的字节数（下面XxxSys之和） Lookups uint64 // 指针查找的次数 Mallocs uint64 // 申请内存的次数 Frees uint64 // 释放内存的次数 // 主分配堆统计 HeapAlloc uint64 // 已申请且仍在使用的字节数 HeapSys uint64 // 从系统中获取的字节数 HeapIdle uint64 // 闲置span中的字节数 HeapInuse uint64 // 非闲置span中的字节数 HeapReleased uint64 // 释放到系统的字节数 HeapObjects uint64 // 已分配对象的总个数 // L低层次、大小固定的结构体分配器统计，Inuse为正在使用的字节数，Sys为从系统获取的字节数 StackInuse uint64 // 引导程序的堆栈 StackSys uint64 MSpanInuse uint64 // mspan结构体 MSpanSys uint64 MCacheInuse uint64 // mcache结构体 MCacheSys uint64 BuckHashSys uint64 // profile桶散列表 GCSys uint64 // GC元数据 OtherSys uint64 // 其他系统申请 // 垃圾收集器统计 NextGC uint64 // 会在HeapAlloc字段到达该值（字节数）时运行下次GC LastGC uint64 // 上次运行的绝对时间（纳秒） PauseTotalNs uint64 PauseNs [256]uint64 // 近期GC暂停时间的循环缓冲，最近一次在[(NumGC+255)%256] NumGC uint32 EnableGC bool DebugGC bool // 每次申请的字节数的统计，61是C代码中的尺寸分级数 BySize [61]struct { Size uint32 Mallocs uint64 Frees uint64 } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:9:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r10 runtime.InUseBytes() InUseBytes返回正在使用的字节数（AllocBytes – FreeBytes） ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:10:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r11 runtime.InUseObjects() InUseObjects返回正在使用的对象数（AllocObjects - FreeObjects） ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:11:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r12 runtime.Stack() Stack返回关联至此记录的调用栈踪迹，即r.Stack0的前缀。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:12:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r13 runtime.MemProfile() MemProfile返回当前内存profile中的记录数n。若len(p)\u003e=n，MemProfile会将此分析报告复制到p中并返回(n, true)；如果len(p)\u003cn，MemProfile则不会更改p，而只返回(n, false)。 如果inuseZero为真，该profile就会包含无效分配记录（其中r.AllocBytes\u003e0，而r.AllocBytes==r.FreeBytes。这些内存都是被申请后又释放回运行时环境的）。 大多数调用者应当使用runtime/pprof包或testing包的-test.memprofile标记，而非直接调用MemProfile ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:13:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r14 runtime.Breakpoint() 执行一个断点 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:14:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r15 runtime.Stack() Stack将调用其的go程的调用栈踪迹格式化后写入到buf中并返回写入的字节数。若all为true，函数会在写入当前go程的踪迹信息后，将其它所有go程的调用栈踪迹都格式化写入到buf中。 在调用Stack方法后,首先格式化当前go协程的信息，然后把其他正在运行的go协程也格式化后写入buf中 package main import ( \"fmt\" \"runtime\" \"time\" ) func main() { go showRecord() time.Sleep(time.Second) buf := make([]byte, 10000) runtime.Stack(buf, true) fmt.Println(string(buf)) } func showRecord() { tiker := time.Tick(time.Second) for t := range tiker { fmt.Println(t) } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:15:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r16 runtime.Caller() 获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号 package main import ( \"fmt\" \"runtime\" ) func main() { pc, file, line, ok := runtime.Caller(0) fmt.Println(pc) // 4308282211 fmt.Println(file) // /Users/liusaisai/workspace/goProject/src/picturePro/main.go fmt.Println(line) // 9 fmt.Println(ok) // ok } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:16:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r17 runtime.Callers() func Callers(skip int, pc []uintptr) int 函数把当前go程序调用栈上的调用栈标识符填入切片pc中，返回写入到pc中的项数。 实参skip为开始在pc中记录之前所要跳过的栈帧数，0表示Callers自身的调用栈，1表示Callers所在的调用栈。返回写入p的项数 package main import ( \"fmt\" \"runtime\" ) func main() { pcs := make([]uintptr, 10) i := runtime.Callers(1, pcs) fmt.Println(pcs[:i]) // [4371884917 4371531008 4371698004] 三个pc 其中有一个是main方法自身的 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:17:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r18 runtime.FuncForPC() func FuncForPC(pc uintptr) *Func 获取一个标识调用栈标识符pc对应的调用栈 package main import ( \"fmt\" \"runtime\" ) func main() { pcs := make([]uintptr, 10) i := runtime.Callers(1, pcs) fmt.Println(pcs[:i]) for _, pc := range pcs[:i] { p := runtime.FuncForPC(pc) file, line := p.FileLine(pc) println( fmt.Sprintf(\"调用栈:%v \", p), fmt.Sprintf(\"调用函数名称:%v \", p.Name()), fmt.Sprintf(\"文件名:%v 行号:%v \", file, line), fmt.Sprintf(\"调用栈标识符:%v \", p.Entry()), ) } } ``` [4305863597 4305503488 4305670692] 调用栈:\u0026{{}} 调用函数名称:main.main 文件名:/Users/liusaisai/workspace/goProject/src/picturePro/main.go 行号:10 调用栈标识符:4305863536 调用栈:\u0026{{}} 调用函数名称:runtime.main 文件名:/Users/liusaisai/.g/go/src/runtime/proc.go 行号:259 调用栈标识符:4305502896 调用栈:\u0026{{}} 调用函数名称:runtime.goexit 文件名:/Users/liusaisai/.g/go/src/runtime/asm_arm64.s 行号:1260 调用栈标识符:4305670688 ``` ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:18:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r19 runtime.NumCgoCall() 获取当前进程调用c方法的次数 package main import ( \"runtime\" ) /* #include \u003cstdio.h\u003e */ import \"C\" // import c 调用了c包中的init方法 func main() { println(runtime.NumCgoCall()) // 1 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:19:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r20 runtime.NumGoroutine() 获取当前存在的go协程数 package main import \"runtime\" func main() { go print() print() println(runtime.NumGoroutine()) } func print() { } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:20:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r21 runtime.Goexit() 终止掉当前的go协程 package main import ( \"runtime\" \"fmt\" ) func main() { print() // 1 fmt.Println(\"继续执行\") } func print(){ fmt.Println(\"准备结束go协程\") runtime.Goexit() defer fmt.Println(\"结束了\") } Goexit终止调用它的go协程,其他协程不受影响,Goexit会在终止该go协程前执行所有的defer函数，前提是defer必须在它前面定义,如果在main go协程调用本方法,会终止该go协程,但不会让main返回,因为main函数没有返回,程序会继续执行其他go协程,当其他go协程执行完毕后,程序就会崩溃 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:21:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r22 runtime.Gosched() 让出调度执行权限，让其他go协程优先执行, 等其他协程执行完后,在执行当前的协程 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:22:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r23 runtime.GoroutineProfile() 获取活跃的go协程的堆栈profile以及记录个数 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:23:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r24 runtime.LockOSThread() 将调用的go程绑定到它当前所在的操作系统线程。除非调用的go程退出或调用UnlockOSThread，否则它将总是在该线程中执行，而其它go程则不能进入该线程 如果有需要协程,但是有一项重要的功能需要占一个线程，就需要它 package main import ( \"fmt\" \"runtime\" \"time\" ) func main() { go calcSum1() go calcSum2() time.Sleep(time.Second*100) } func calcSum1(){ runtime.LockOSThread() start := time.Now() count := 0 for i := 0; i \u003c 10000000000 ; i++ { count += i } end := time.Now() fmt.Println(\"calcSum1耗时\") fmt.Println(end.Sub(start)) defer runtime.UnlockOSThread() } func calcSum2(){ start := time.Now() count := 0 for i := 0; i \u003c 10000000000 ; i++ { count += i } end := time.Now() fmt.Println(\"calcSum2耗时\") fmt.Println(end.Sub(start)) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:24:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r25 runitme.UnlockOSThread() 解除go协程与操作系统线程的绑定关系，将调用的go程解除和它绑定的操作系统线程。若调用的go程未调用LockOSThread，UnlockOSThread不做操作 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:25:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r26 runtime.ThreadCreateProfile() 获取线程创建profile中的记录个数， 返回线程创建profile中的记录个数。如果len(p)\u003e=n，本函数就会将profile中的记录复制到p中并返回(n, true)。若len(p)\u003cn，则不会更改p，而只返回(n, false)。 绝大多数使用者应当使用runtime/pprof包，而非直接调用ThreadCreateProfile。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:26:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r27 runtime.SetCPUProfileRate(hz int) 官方注释： SetCPUProfileRate设置CPU profile记录的速率为平均每秒hz次。如果hz\u003c=0，SetCPUProfileRate会关闭profile的记录。如果记录器在执行，该速率必须在关闭之后才能修改。 绝大多数使用者应使用runtime/pprof包或testing包的-test.cpuprofile选项而非直接使用SetCPUProfileRate ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:27:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r28 runtime.SetBlockProfileRate(rate int) 官方解释： SetBlockProfileRate控制阻塞profile记录go程阻塞事件的采样频率。对于一个阻塞事件，平均每阻塞rate纳秒，阻塞profile记录器就采集一份样本。 要在profile中包括每一个阻塞事件，需传入rate=1；要完全关闭阻塞profile的记录，需传入rate\u003c=0。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:28:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r29 runtime.BlockProfile() 返回当前阻塞profile中的记录个数 BlockProfile返回当前阻塞profile中的记录个数。如果len(p)\u003e=n，本函数就会将此profile中的记录复制到p中并返回(n, true)。如果len(p)\u003cn，本函数则不会修改p，而只返回(n, false)。 绝大多数使用者应当使用runtime/pprof包或testing包的-test.blockprofile标记， 而非直接调用 BlockProfile ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180259/:29:0","tags":null,"title":"16. Go runtime详解","uri":"/lang/go/go_advanced/20250515180259/"},{"categories":null,"content":"\r1 截取容量问题 切片截取子切片时，会造成临时内存泄露， 主要原因有两个 切片截取时，新旧切片会共用一个底层数组 切片的底层结构体指向数组的指针只是一个头指针 demo package main import \"fmt\" func main() { a := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} c := a[1:2] fmt.Println(len(c), cap(c)) // 1,9 c的数组头指针执行索引1，所以容量为9 } 解决办法 使用copy，不过要注意copy时的长度和容量问题 使用slice [1:2:3] 两个冒号语法截取：[startIndex:endIndex:max], 其中 max 的值一定要大于 endIndex 新切片的容量就是max - startIndex, 实际引用的数组时从数组startIndex索引开始到max索引为止，但不包括max索引处的元素, 新切片的长度就是endIndex - startIndex package main import \"fmt\" func main() { a := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} b := a[2:5:6] fmt.Println(len(b), cap(b)) // 3 ,4 len(b) = 5-2, cap(b) = 6-2 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180255/:1:0","tags":null,"title":"15. Go 切片的截取","uri":"/lang/go/go_advanced/20250515180255/"},{"categories":null,"content":"\r1 itoa 位运算 code-1 package main import \"fmt\" const ( i=1\u003c\u003ciota j=3\u003c\u003ciota k l ) func main() { fmt.Println(\"i=\",i) fmt.Println(\"j=\",j) fmt.Println(\"k=\",k) fmt.Println(\"l=\",l) } /* i= 1 j= 6 k= 12 l= 24 */ const 声明第一个常量必须指定一个表达式，后续的常量如果没有表达式，则继承上面的表达式。 iota 表示从 0 开始自动加 1，所以 i=1«0, j=3«1（« 表示左移的意思），即：i=1, j=6，这没问题，关键在 k 和 l，从输出结果看 k=3«2，l=3«3。 简单表述: i=1：左移 0 位,不变仍为 1; j=3：左移 1 位,变为二进制 110, 即 6; k=3：左移 2 位,变为二进制 1100, 即 12; l=3：左移 3 位,变为二进制 11000,即 24; 注：«n==*(2^n)。 // 左移运算符 \u003c\u003c 是双目运算符。左移 n 位就是乘以 2 的 n 次方。 其功能把 \u003c\u003c 左边的运算数的各二进位全部左移若干位，由 \u003c\u003c 右边的数指定移动的位数，高位丢弃，低位补 0。 //右移运算符 \u003e\u003e 是双目运算符。右移 n 位就是除以 2 的 n 次方。 其功能是把 \u003e\u003e 左边的运算数的各二进位全部右移若干位， \u003e\u003e 右边的数指定移动的位数。 code-2 const ( bit0, mask0 = 1 \u003c\u003c iota, 1\u003c\u003ciota - 1 //const声明第0行，即iota==0 bit1, mask1 //const声明第1行，即iota==1, 表达式继承上面的语句 _, _ //const声明第2行，即iota==2 bit3, mask3 //const声明第3行，即iota==3 ) 第0行的表达式展开即bit0, mask0 = 1 \u003c\u003c 0, 1\u003c\u003c0 - 1，所以bit0 == 1，mask0 == 0； 第1行没有指定表达式继承第一行，即bit1, mask1 = 1 \u003c\u003c 1, 1\u003c\u003c1 - 1，所以bit1 == 2，mask1 == 1； 第2行没有定义常量 第3行没有指定表达式继承第一行，即bit3, mask3 = 1 \u003c\u003c 3, 1\u003c\u003c3 - 1，所以bit0 == 8，mask0 == 7； ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180251/:1:0","tags":null,"title":"14.位运算","uri":"/lang/go/go_advanced/20250515180251/"},{"categories":null,"content":"\r2 简单位运算","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180251/:2:0","tags":null,"title":"14.位运算","uri":"/lang/go/go_advanced/20250515180251/"},{"categories":null,"content":"\r2.1 1. 左偏移 左偏移就是数字乘以2的偏移量次方 3 \u003c\u003c 4 ==\u003e 3*math.Pow(2,4) ==\u003e 48 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180251/:2:1","tags":null,"title":"14.位运算","uri":"/lang/go/go_advanced/20250515180251/"},{"categories":null,"content":"\r2.2 2. 右偏移 右偏移就是数字除以2的偏移量次方 16 \u003e\u003e 3 ==\u003e 16/math.Pow(2,3) ==\u003e2 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180251/:2:2","tags":null,"title":"14.位运算","uri":"/lang/go/go_advanced/20250515180251/"},{"categories":null,"content":"\r1 什么是接口型函数？ 某一函数类型实现了接口，该函数类型调用接口实现方法时再调用该函数类型本体，这种函数叫做接口型函数。 示例代码 // 调用器接口 type Invoker interface { Call(interface{}) error } // 定义函数为类型 type FuncCaller func(interface{}) error // 接口实现 func (f FuncCaller) Call(i interface{}) error { return f(i) // 调用函数f本体 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180247/:1:0","tags":null,"title":"13-2. go 接口型函数","uri":"/lang/go/go_advanced/20250515180247/"},{"categories":null,"content":"\r2 优点 可以完美使用接口优点，不必将某个接口函数附在某个type上面 可以直接调用函数或者使用该接口，非常灵活 code demo // interface_func project main.go 接口型函数基本使用 package main import \"fmt\" type Handler interface { Do(k, v interface{}) } type HandlerFunc func(k, v interface{}) func (f HandlerFunc) Do(k, v interface{}) { f(k, v) } func Each(m map[interface{}]interface{}, h Handler) { if m != nil \u0026\u0026 len(m) \u003e 0 { for k, v := range m { h.Do(k, v) } } } func SelfInfo(k, v interface{}) { fmt.Printf(\"我是%s,今年%d岁了\\n\", k, v) } func EachFunc(m map[interface{}]interface{}, f func(k, v interface{})) { Each(m, HandlerFunc(f)) } func main() { SelfInfo(\"chaozhou\", 23) //单独调用 SelfInfo(\"lisi\", 24) //单独调用 person := make(map[interface{}]interface{}) person[\"chaozhou\"] = 23 person[\"lisi\"] = 24 EachFunc(person, SelfInfo) //函数接口参数调用 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180247/:2:0","tags":null,"title":"13-2. go 接口型函数","uri":"/lang/go/go_advanced/20250515180247/"},{"categories":null,"content":"\r3 应用场景 net/http 库中handler和handlerFunc ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180247/:3:0","tags":null,"title":"13-2. go 接口型函数","uri":"/lang/go/go_advanced/20250515180247/"},{"categories":null,"content":"\r1 1. sync.Pool sync.Pool 除了最常见的池化提升性能的思路，最重要的是减少 GC 。 常用于一些对象实例创建昂贵的场景。注意，Pool 是 Goroutine 并发安全的。 可以作为保存临时取还对象的一个“池子”。 特点 Goroutine 并发安全的 存储的都是临时对象 自动移除, 清理完全是由runtime控制的, 随时都可能被无通知清除 当这个对象的引用只有sync.Pool持有时，这个对象内存会被释放 目的就是缓存并重用对象，减少GC的压力 自动扩容、缩容 不能对 Pool.Get 出来的对象做预判，有可能是新的（新分配的），有可能是旧的（之前人用过，然后 Put 进去的） 当用完一个从 Pool 取出的实例时候，一定要记得调用 Put，否则 Pool 无法复用这个实例，通常这个用 defer 完成； 应用场景 当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。 对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 sync.Pool 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。 标准库中 encoding/json 也用到了 sync.Pool 来提升性能。 著名的 gin 框架，对 context 取用也到了 sync.Pool。 fasthttp 大量使用sync.Pool ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:1:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r2 2. string相关","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:2:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r2.1 2.1 字符串拼接使用 strings.Builder 官网说: A Builder is used to efficiently build a string using Write methods. It minimizes memory copying. 字符串拼接方法 使用 + 使用fmt.Sprintf 使用strings.Builder 使用strings.Buffer 使用bytes.Buffer 从基准测试的结果来看，使用 + 和 fmt.Sprintf 的效率是最低的，和其余的方式相比，性能相差约 1000 倍，而且消耗了超过 1000 倍的内存。当然 fmt.Sprintf 通常是用来格式化字符串的，一般不会用来拼接字符串。 strings.Builder、bytes.Buffer 和 []byte 的性能差距不大，而且消耗的内存也十分接近，性能最好且消耗内存最小的是 preByteConcat，这种方式预分配了内存，在字符串拼接的过程中，不需要进行字符串的拷贝，也不需要分配新的内存，因此性能最好，且内存消耗最小。 string.Builder 和 + 字符串在 Go 语言中是不可变类型，占用内存大小是固定的，当使用 + 拼接 2 个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和。拼接第三个字符串时，再开辟一段新空间，新空间大小是三个字符串大小之和，以此类推。假设一个字符串大小为 10 byte，拼接 1w 次，需要申请的内存大小为： 10 + 2 * 10 + 3 * 10 + ... + 10000 * 10 byte = 500 MB 而 strings.Builder，bytes.Buffer，包括切片 []byte 的内存是以倍数申请的。例如，初始大小为 0，当第一次写入大小为 10 byte 的字符串时，则会申请大小为 16 byte 的内存（恰好大于 10 byte 的 2 的指数），第二次写入 10 byte 时，内存不够，则申请 32 byte 的内存，第三次写入内存足够，则不申请新的，以此类推。在实际过程中，超过一定大小，比如 2048 byte 后，申请策略上会有些许调整。 2048 以前按倍数申请，2048 之后，以 640 递增，最后一次递增 24576 到 122880。总共申请的内存大小约 0.52 MB，约为上一种方式的千分之一。 strings.Builder 和 bytes.Buffer strings.Builder 和 bytes.Buffer 底层都是 []byte 数组，但 strings.Builder 性能比 bytes.Buffer 略快约 10% 。一个比较重要的区别在于，bytes.Buffer 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 strings.Builder 直接将底层的 []byte 转换成了字符串类型返回了回来。 bytes.Buffer // To build strings more efficiently, see the strings.Builder type. func (b *Buffer) String() string { if b == nil { // Special case, useful in debugging. return \"\u003cnil\u003e\" } return string(b.buf[b.off:]) } strings.Builder // String returns the accumulated string. func (b *Builder) String() string { return *(*string)(unsafe.Pointer(\u0026b.buf)) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:2:1","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r2.2 2.2 字符串截取 strings.Repeat\r2.2.1 一个子字符串表达式的结果（子）字符串和基础字符共享一个承载底层字节序列的内存块。不仅节省内存，而且还减少了CPU消耗。 但是有时候它会造成暂时性的内存泄露。 demo var s0 string // 一个包级变量 // 一个演示目的函数。 func f(s1 string) { s0 = s1[:50] // 目前，s0和s1共享着承载它们的字节序列的同一个内存块。 // 虽然s1到这里已经不再被使用了，但是s0仍然在使用中， // 所以它们共享的内存块将不会被回收。虽然此内存块中 // 只有50字节被真正使用，而其它字节却无法再被使用。 } func demo() { s := createStringWithLengthOnHeap(1 \u003c\u003c 20) // 1M bytes f(s) } 解决办法 将子字符串表达式的结果转换为一个字节切片，然后再转换回来。此种防止临时性内存泄露的方法不是很高效，因为在此过程中底层的字节序列被复制了两次，其中一次是不必要的。 func f(s1 string) { s0 = string([]byte(s1[:50])) } [推荐]使用strings.Builder类型来防止一次不必要的复制。 import \"strings\" func f(s1 string) { var b strings.Builder b.Grow(50) b.WriteString(s1[:50]) s0 = b.String() } 使用strings.Repeat, 此方法底层也是strings.Builder的封装 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:2:2","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r3 3. 使用协程池 协程池作用 可以限制goroutine数量，避免无限制的增长。 减少栈扩容的次数。 频繁创建goroutine的场景下，资源复用，节省内存。（需要一定规模。一般场景下，效果不太明显。） 推荐第三方库 ants go对goroutine有一定的复用能力。所以要根据场景选择是否使用协程池，不恰当的场景不仅得不到收益，反而增加系统复杂性。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:3:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r4 4. for 和 range 选择 range 在迭代过程中返回的是迭代值的拷贝 如果每次迭代的元素的内存占用很低，那么 for 和 range 的性能几乎是一样，例如 []int。 如果迭代的元素内存占用较高，例如一个包含很多属性的 struct 结构体，那么 for 的性能将显著地高于 range，有时候甚至会有上千倍的性能差异。对于这种场景，建议使用 for，如果使用 range，建议只迭代下标，通过下标访问迭代值，这种使用方式和 for 就没有区别了。 如果想使用 range 同时迭代下标和值，则需要将切片/数组的元素改为指针，才能不影响性能。 尽量使用for,而不是range ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:4:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r5 5. 减小锁的资源消耗 对临界区加锁比较常见, 性能损耗也是非常严重的 标准库中sync.map针对读操作的优化消除了rwlock，是一个标准的案例. 用原子操作代替互斥锁也是一种经典的lock-free技巧。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:5:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r6 6. 不要使用反射, 除非忍不住 反射可以帮助抽象和简化代码，提高开发效率。但是go语言反射效率不高. 反射创建对象效率相差不大, 但是动态修改字段的值效率极低! ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:6:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r7 7. 结构体声明考虑内存对齐 CPU 访问内存时并不是逐个字节访问，而是以字长（word size）为单位访问，例如 32位的CPU 字长是4字节，64位的是8字节。如果变量的地址没有对齐，可能需要多次访问才能完整读取到变量内容，而对齐后可能就只需要一次内存访问，因此内存对齐可以减少CPU访问内存的次数，加大CPU访问内存的吞吐量。 在实际开发中，我们可以通过调整变量位置，优化内存占用（一般按照变量内存大小顺序排列，整体占用内存更小） ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:7:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r8 8. slice 相关","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:8:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r8.1 8.1 创建slice和map声明cap 尽可能的声明容量 使用append向Slice追加元素时，如果Slice空间不足，将会触发Slice扩容，扩容实际上是重新分配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。 扩容容量的选择遵循以下规则： 如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍； 如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍； 扩容消耗资源 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:8:1","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r8.2 8.2 slice 的截取[::]和拷贝 slice 使用方式不对容易造成内存的伪泄露、数据篡改等问题 切片截取子切片时，会造成临时内存泄露， 主要原因有两个 切片截取时，新旧切片会共用一个底层数组 切片的底层结构体指向数组的指针只是一个头指针 demo package main import \"fmt\" func main() { a := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} c := a[1:2] fmt.Println(len(c), cap(c)) // 1,9 c的数组头指针执行索引1，所以容量为9 } 解决办法 使用copy，不过要注意copy时的长度和容量问题 使用slice [1:2:3] 两个冒号语法截取：[startIndex:endIndex:max], 其中 max 的值一定要大于 endIndex 新切片的容量就是max - startIndex, 实际引用的数组时从数组startIndex索引开始到max索引为止，但不包括max索引处的元素, 新切片的长度就是endIndex - startIndex ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:8:2","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r9 9. 空占位符使用struct 空结构体在内存中不占用空间 用法 与map结合实现set Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间 将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。 制造伪迭代器 for range make([]struct{}, 100) { fmt.Println(\"迭代器\") } 不发送数据的channel func worker(ch chan struct{}) { \u003c-ch fmt.Println(\"do something\") close(ch) } func main() { ch := make(chan struct{}) go worker(ch) ch \u003c- struct{}{} } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:9:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r10 10. 考虑内存逃逸 控制变量不发生逃逸，将其控制在栈上，减少堆变量的分配，降低GC成本，提高程序性能。 变量逃逸一般发生在如下几种情况： 变量较大（栈空间不足） 变量大小不确定（如slice长度或容量不定） 返回地址 返回引用（引用变量的底层是指针） 返回值类型不确定（不能确定大小） 闭包 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:10:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r11 11. 返回值VS返回指针 值传递会拷贝整个对象，而指针传递只会拷贝地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收（GC）的负担。在对象频繁创建和删除的场景下，返回指针导致的GC开销可能会严重影响性能。 一般情况下，对于需要修改原对象，或占用内存比较大的对象，返回指针。对于只读或占用内存较小的对象，返回值能够获得更好的性能。 持续完善… ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180244/:11:0","tags":null,"title":"13-1.go语言代码优化技巧","uri":"/lang/go/go_advanced/20250515180244/"},{"categories":null,"content":"\r1 什么是信号量 信号量是并发编程中常见的一种同步机制，在需要控制访问资源的线程数量时就会用到信号量 维基百科 信号量的概念是计算机科学家 Dijkstra （Dijkstra算法的发明者）提出来的，广泛应用在不同的操作系统中。系统中，会给每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。 如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量（binary semaphore）又称互斥锁（Mutex） 计数信号量具备两种操作动作，称为V（signal()）与P（wait()）（即部分参考书常称的“PV操作”）。V操作会增加信号量S的数值，P操作会减少它。 运行方式： 初始化信号量，给与它一个非负数的整数值。 运行P（wait()），信号量S的值将被减少。企图进入临界区的进程，需要先运行P（wait()）。当信号量S减为负值时，进程会被阻塞住，不能继续；当信号量S不为负值时，进程可以获准进入临界区。 运行V（signal()），信号量S的值会被增加。结束离开临界区段的进程，将会运行V（signal()）。当信号量S不为负值时，先前被阻塞住的其他进程，将可获准进入临界区。 一般用信号量保护一组资源，比如数据库连接池、一组客户端的连接等等。**每次获取资源时都会将信号量中的计数器减去对应的数值，在释放资源时重新加回来。当信号量没资源时尝试获取信号量的线程就会进入休眠，等待其他线程释放信号量。如果信号量是只有0和1的二进位信号量，那么，它的 P/V 就和互斥锁的 Lock/Unlock 就一样了。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180240/:1:0","tags":null,"title":"12-2. go 信号量","uri":"/lang/go/go_advanced/20250515180240/"},{"categories":null,"content":"\r2 在Go语言中的应用 实际应用Go语言开发程序时，有哪些场景适合使用信号量呢？在需要控制访问资源的线程数量时就会需要信号量 Go 内部使用信号量来控制goroutine的阻塞和唤醒，比如互斥锁sync.Mutex结构体定义的第二个字段就是一个信号量。 type Mutex struct { state int32 sema uint32 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180240/:2:0","tags":null,"title":"12-2. go 信号量","uri":"/lang/go/go_advanced/20250515180240/"},{"categories":null,"content":"\r3 信号量使用 使用信号量前，需先在项目里安装golang.org/x/sync/包 安装方法：go get -u http://golang.org/x/sync 方法 semaphore.NewWeighted 用于创建新的信号量，通过参数(n int64) 指定信号量的初始值。 semaphore.Weighted.Acquire 阻塞地获取指定权重的资源，如果当前没有空闲资源，就会陷入休眠等待；相当于 P 操作，你可以一次获取多个资源，如果没有足够多的资源，调用者就会被阻塞。它的第一个参数是 Context，这就意味着，你可以通过 Context 增加超时或者 cancel 的机制。如果是正常获取了资源，就返回 nil；否则，就返回ctx.Err()，信号量不改变。 semaphore.Weighted.Release 用于释放指定权重的资源；相当于 V 操作，可以将 n 个资源释放，返还给信号量。 semaphore.Weighted.TryAcquire 非阻塞地获取指定权重的资源，如果当前没有空闲资源，就会直接返回 false； demo 假设有一组要抓取的页面，资源有限最多允许同时执行三个抓取任务，当同时有三个抓取任务在执行时，在执行完一个抓取任务后才能执行下一个排队等待的任务。当然这个问题用Channel也能解决，不过这次我们使用Go提供的信号量原语来解决这个问题，代码如下： package main import ( \"context\" \"fmt\" \"sync\" \"time\" \"golang.org/x/sync/semaphore\" ) func doSomething(u string) {// 模拟抓取任务的执行 fmt.Println(u) time.Sleep(2 * time.Second) } const ( Limit = 3 // 同時并行运行的goroutine上限 Weight = 1 // 每个goroutine获取信号量资源的权重 ) func main() { urls := []string{ \"http://www.example.com\", \"http://www.example.net\", \"http://www.example.net/foo\", \"http://www.example.net/bar\", \"http://www.example.net/baz\", } s := semaphore.NewWeighted(Limit) var w sync.WaitGroup for _, u := range urls { w.Add(1) go func(u string) { s.Acquire(context.Background(), Weight) doSomething(u) s.Release(Weight) w.Done() }(u) } w.Wait() fmt.Println(\"All Done\") } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180240/:3:0","tags":null,"title":"12-2. go 信号量","uri":"/lang/go/go_advanced/20250515180240/"},{"categories":null,"content":"\r4 实现原理","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180240/:4:0","tags":null,"title":"12-2. go 信号量","uri":"/lang/go/go_advanced/20250515180240/"},{"categories":null,"content":"\r4.1 1. 数据结构 信号量semaphore.Weighted的数据结构 type Weighted struct { size int64 // 最大资源数 cur int64 // 当前已被使用的资源 mu sync.Mutex // 互斥锁，对字段的保护 waiters list.List // 等待队列 } size字段用来记录信号量拥有的最大资源数。 cur标识当前已被使用的资源数。 mu是一个互斥锁用来提供对其他字段的临界区保护。 waiters表示申请资源时由于可使用资源不够而陷入阻塞等待的调用者列表。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180240/:4:1","tags":null,"title":"12-2. go 信号量","uri":"/lang/go/go_advanced/20250515180240/"},{"categories":null,"content":"\r4.2 2. Acquire请求信号量资源 Acquire方法会监控资源是否可用，而且还要检测传递进来的context.Context对象是否发送了超时过期或者取消的信号，我们来看一下它的代码实现： func (s *Weighted) Acquire(ctx context.Context, n int64) error { s.mu.Lock() // 如果恰好有足够的资源，也没有排队等待获取资源的goroutine， // 将cur加上n后直接返回 if s.size-s.cur \u003e= n \u0026\u0026 s.waiters.Len() == 0 { s.cur += n s.mu.Unlock() return nil } // 请求的资源数大于能提供的最大的资源数 // 这个任务处理不了，走错误处理逻辑 if n \u003e s.size { s.mu.Unlock() // 依赖ctx的状态返回，否则一直等待 \u003c-ctx.Done() return ctx.Err() } // 现存资源不够, 需要把调用者加入到等待队列中 // 创建了一个ready chan,以便被通知唤醒 ready := make(chan struct{}) w := waiter{n: n, ready: ready} elem := s.waiters.PushBack(w) s.mu.Unlock() // 等待 select { case \u003c-ctx.Done(): // context的Done被关闭 err := ctx.Err() s.mu.Lock() select { case \u003c-ready: // 如果被唤醒了，忽略ctx的状态 err = nil default: // 通知waiter isFront := s.waiters.Front() == elem s.waiters.Remove(elem) // 通知其它的waiters,检查是否有足够的资源 if isFront \u0026\u0026 s.size \u003e s.cur { s.notifyWaiters() } } s.mu.Unlock() return err case \u003c-ready: // 等待者被唤醒了 return nil } } 如果调用者请求不到信号量的资源就会被加入等待者列表里，这里等待者列表的结构体定义是： type waiter struct { n int64 ready chan\u003c- struct{} // 当调用者可以获取到信号量资源时, close调这个chan } 包含了两个字段，调用者请求的资源数，以及一个ready 通道。ready通道会在调用者可以被重新唤醒的时候被close调，从而起到通知正在阻塞读取ready通道的等待者的作用。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180240/:4:2","tags":null,"title":"12-2. go 信号量","uri":"/lang/go/go_advanced/20250515180240/"},{"categories":null,"content":"\r4.3 3. NotifyWaiters 通知等待者 notifyWaiters方法会逐个检查队列里等待的调用者，如果现存资源够等待者请求的数量n，或者是没有等待者了，就返回： func (s *Weighted) notifyWaiters() { for { next := s.waiters.Front() if next == nil { break // 没有等待者了，直接返回 } w := next.Value.(waiter) if s.size-s.cur \u003c w.n { // 如果现有资源不够队列头调用者请求的资源数，就退出所有等待者会继续等待 // 这里还是按照先入先出的方式处理是为了避免饥饿 break } s.cur += w.n s.waiters.Remove(next) close(w.ready) } } notifyWaiters方法是按照先入先出的方式唤醒调用者。当释放 100 个资源的时候，如果第一个等待者需要 101 个资源，那么，队列中的所有等待者都会继续等待，即使队列后面有的等待者只需要 1 个资源。这样做的目的是避免饥饿，否则的话，资源可能总是被那些请求资源数小的调用者获取，这样一来，请求资源数巨大的调用者，就没有机会获得资源了。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180240/:4:3","tags":null,"title":"12-2. go 信号量","uri":"/lang/go/go_advanced/20250515180240/"},{"categories":null,"content":"\r4.4 4. Release归还信号量资源 Release方法就很简单了，它将当前计数值减去释放的资源数 n，并调用notifyWaiters方法，尝试唤醒等待队列中的调用者，看是否有足够的资源被获取。 func (s *Weighted) Release(n int64) { s.mu.Lock() s.cur -= n if s.cur \u003c 0 { s.mu.Unlock() panic(\"semaphore: released more than held\") } s.notifyWaiters() s.mu.Unlock() } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180240/:4:4","tags":null,"title":"12-2. go 信号量","uri":"/lang/go/go_advanced/20250515180240/"},{"categories":null,"content":"\r5 总结 在Go语言中信号量有时候也会被Channel类型所取代，因为一个 buffered chan 也可以代表 n 个资源。不过既然Go语言通过golang.orgx/sync扩展库对外提供了semaphore.Weight这一种信号量实现，遇到使用信号量的场景时还是尽量使用官方提供的实现。在使用的过程中我们需要注意以下的几个问题： Acquire和 TryAcquire方法都可以用于获取资源，前者会阻塞地获取信号量。后者会非阻塞地获取信号量，如果获取不到就返回false。 Release归还信号量后，会以先进先出的顺序唤醒等待队列中的调用者。如果现有资源不够处于等待队列前面的调用者请求的资源数，所有等待者会继续等待。 如果一个goroutine申请较多的资源，由于上面说的归还后唤醒等待者的策略，它可能会等待比较长的时间。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180240/:5:0","tags":null,"title":"12-2. go 信号量","uri":"/lang/go/go_advanced/20250515180240/"},{"categories":null,"content":"\r1 区别 unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算； 而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收； unsafe.Pointer 可以和 普通指针 进行相互转换； unsafe.Pointer 可以和 uintptr 进行相互转换。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180234/:1:0","tags":null,"title":"12-1. unsafe.Pointer和 uintptr","uri":"/lang/go/go_advanced/20250515180234/"},{"categories":null,"content":"\r2 示例 通过一个例子加深理解，接下来尝试用指针的方式给结构体赋值。 package main import ( \"fmt\" \"unsafe\" ) type W struct { b int32 c int64 } func main() { var w *W = new(W) //这时w的变量打印出来都是默认值0，0 fmt.Println(w.b,w.c) //现在我们通过指针运算给b变量赋值为10 b := unsafe.Pointer(uintptr(unsafe.Pointer(w)) + unsafe.Offsetof(w.b)) *((*int)(b)) = 10 //此时结果就变成了10，0 fmt.Println(w.b,w.c) } uintptr(unsafe.Pointer(w)) 获取了 w 的指针起始值 unsafe.Offsetof(w.b) 获取 b 变量的偏移量 两个相加就得到了 b 的地址值，将通用指针 Pointer 转换成具体指针 ((*int)(b))，通过 * 符号取值，然后赋值。*((*int)(b)) 相当于把 (*int)(b) 转换成 int 了，最后对变量重新赋值成 10，这样指针运算就完成了。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180234/:2:0","tags":null,"title":"12-1. unsafe.Pointer和 uintptr","uri":"/lang/go/go_advanced/20250515180234/"},{"categories":null,"content":"\r1 设计原则 单一职责原则：一个方法只完成一件事，实现高内聚低耦合。 开闭原则：对扩展开发，对修改关闭（常见做法：多态、基于接口实现、依赖注入）。 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 接口隔离原则：尽量将臃肿庞大的接口拆分成更小的和更具体的接口；单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。 迪米特原则： 只与你的直接朋友交谈，不跟“陌生人”说话，从依赖者的角度来说，只依赖应该依赖的对象。从被依赖者的角度说，只暴露应该暴露的方法。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180231/:1:0","tags":null,"title":"11.Go语言设计模式","uri":"/lang/go/go_advanced/20250515180231/"},{"categories":null,"content":"\r2 设计模式 大类： 创建型模式： 它提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。 结构性模式 行为型模式 序号 模式 \u0026 描述 包括 1 创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 **工厂模式（**Factory Pattern） 抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 2 结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 3 行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 举例 单例模式 once.Do 工厂模式 : 自定义一个结构体构造方法 options模式: 把函数生成可选参数 代理模式: 字符串占位符 生产者消费者模式: 单向channel 建造者模式: Gorm 大量用了建造者模式， 例如创建一个new方法，生成某个结构体实例 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180231/:2:0","tags":null,"title":"11.Go语言设计模式","uri":"/lang/go/go_advanced/20250515180231/"},{"categories":null,"content":"\r2.1 1. 单例模式（创建型） 单例模式（Singleton Pattern），是最简单的一个模式。在Go中，单例模式指的是全局只有一个实例，并且它负责创建自己的对象。单例模式不仅有利于减少内存开支，还有减少系统性能开销、防止多个实例产生冲突等优点。 因为单例模式保证了实例的全局唯一性，而且只被初始化一次，所以比较适合全局共享一个实例，且只需要被初始化一次的场景，例如数据库实例、全局配置、全局任务池等。 2.1.1 1.1 饿汉模式 懒汉方式指全局的单例实例在第一次被使用时创建。因为实例是在包被导入时初始化的，所以如果初始化耗时，会导致程序加载时间比较长。 实现方式 package singleton type singleton struct { } var ins *singleton = \u0026singleton{} func GetInsOr() *singleton { return ins } 饿汉模式可以将问题及早暴露，懒汉式虽然支持延迟加载，但是这只是把冷启动时间放到了第一次使用的时候，并没有本质上解决问题，并且为了实现懒汉式还不可避免的需要加锁 2.1.2 1.2 懒汉模式 懒汉方式真正使用的时候才会创建实例，运用较广，但它的缺点是非并发安全，在实际使用时需要加锁。 代码实现 package singleton type singleton struct { } var ins *singleton func GetInsOr() *singleton { if ins == nil { ins = \u0026singleton{} } return ins } 非并发安全，在实际使用时需要加锁。 2.1.3 1.3 双重锁定 双重锁检查是在懒汉模式的基础上加锁实现，保证并发安全 代码实现 package singleton import \"sync\" type singleton struct { } var ins *singleton var mu sync.Mutex func GetIns() *singleton { if ins == nil { mu.Lock() defer mu.Unlock() ins = \u0026singleton{} } return ins } sync.Once 就是基于双重锁定的封装 代码实现 package singleton import ( \"sync\" ) type singleton struct { } var ins *singleton var once sync.Once func GetInsOr() *singleton { once.Do(func() { ins = \u0026singleton{} }) return ins } 实现原理 package sync import ( \"sync/atomic\" ) type Once struct { done uint32 m Mutex } func (o *Once) Do(f func()) { if atomic.LoadUint32(\u0026o.done) == 0 { // Outlined slow-path to allow inlining of the fast-path. o.doSlow(f) } } func (o *Once) doSlow(f func()) { o.m.Lock() defer o.m.Unlock() if o.done == 0 { defer atomic.StoreUint32(\u0026o.done, 1) f() } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180231/:2:1","tags":null,"title":"11.Go语言设计模式","uri":"/lang/go/go_advanced/20250515180231/"},{"categories":null,"content":"\r2.2 2. 工厂模式（创建型） 工厂模式（Factory Pattern）是面向对象编程中的常用模式。在Go项目开发中，你可以通过使用多种不同的工厂模式，来使代码更简洁明了。Go中的结构体，可以理解为面向对象编程中的类，例如 Person结构体（类）实现了Greet方法。 结构体定义 type Person struct { Name string Age int } func (p Person) Greet() { fmt.Printf(\"Hi! My name is %s\", p.Name) } 2.2.1 2.1 简单工厂模式 简单工厂模式是最常用、最简单的。它就是一个接受一些参数，然后返回Person实例的函数 type Person struct { Name string Age int } func (p Person) Greet() { fmt.Printf(\"Hi! My name is %s\", p.Name) } func NewPerson(name string, age int) *Person { return Person{ Name: name, Age: age } } 2.2.2 2.2 抽象工厂模式 和简单工厂模式的唯一区别，就是它返回的是接口而不是结构体。通过返回接口，可以在你不公开内部实现的情况下，让调用者使用你提供的各种功能 type Person interface { Greet() } type person struct { name string age int } func (p person) Greet() { fmt.Printf(\"Hi! My name is %s\", p.name) } // Here, NewPerson returns an interface, and not the person struct itself func NewPerson(name string, age int) Person { return person{ name: name, age: age } } 2.2.3 2.3 工厂方法模式 在简单工厂模式中，依赖于唯一的工厂对象，如果我们需要实例化一个产品，就要向工厂中传入一个参数，获取对应对象；如果要增加一种产品，就要在工厂中修改创建产品的函数。这会导致耦合性过高，这时我们就可以使用工厂方法模式。 在工厂方法模式中，依赖工厂接口，我们可以通过实现工厂接口来创建多种工厂，将对象创建从由一个对象负责所有具体类的实例化，变成由一群子类来负责对具体类的实例化，从而将过程解耦。 代码实现 type Person struct { name string age int } func NewPersonFactory(age int) func(name string) Person { return func(name string) Person { return Person{ name: name, age: age, } } } newBaby := NewPersonFactory(1) baby := newBaby(\"john\") newTeenager := NewPersonFactory(16) teen := newTeenager(\"jill\") ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180231/:2:2","tags":null,"title":"11.Go语言设计模式","uri":"/lang/go/go_advanced/20250515180231/"},{"categories":null,"content":"\r2.3 3. 建造者模式（创建型） Gorm 大量用了建造者模式， 例如创建一个new方法，生成某个结构体实例 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180231/:2:3","tags":null,"title":"11.Go语言设计模式","uri":"/lang/go/go_advanced/20250515180231/"},{"categories":null,"content":"\r2.4 4. 策略模式（行为型） 策略模式（Strategy Pattern）定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。 在什么时候，我们需要用到策略模式呢？ 在项目开发中，我们经常要根据不同的场景，采取不同的措施，也就是不同的策略。比如，假设我们需要对a、b 这两个整数进行计算，根据条件的不同，需要执行不同的计算方式。我们可以把所有的操作都封装在同一个函数中，然后通过 if ... else ... 的形式来调用不同的计算方式，这种方式称之为硬编码。 在实际应用中，随着功能和体验的不断增长，我们需要经常添加/修改策略，这样就需要不断修改已有代码，不仅会让这个函数越来越难维护，还可能因为修改带来一些bug。所以为了解耦，需要使用策略模式，定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法（即策略）。 代码实现 package strategy // 策略模式 // 定义一个策略类 type IStrategy interface { do(int, int) int } // 策略实现：加 type add struct{} func (*add) do(a, b int) int { return a + b } // 策略实现：减 type reduce struct{} func (*reduce) do(a, b int) int { return a - b } // 具体策略的执行者 type Operator struct { strategy IStrategy } // 设置策略 func (operator *Operator) setStrategy(strategy IStrategy) { operator.strategy = strategy } // 调用策略中的方法 func (operator *Operator) calculate(a, b int) int { return operator.strategy.do(a, b) } //// 在上述代码中，我们定义了策略接口 IStrategy，还定义了 add 和 reduce 两种策略。最后定义了一个策略执行者，可以设置不同的策略，并执行; 我们可以随意更换策略，而不影响Operator的所有实现。 func TestStrategy(t *testing.T) { operator := Operator{} operator.setStrategy(\u0026add{}) result := operator.calculate(1, 2) fmt.Println(\"add:\", result) operator.setStrategy(\u0026reduce{}) result = operator.calculate(2, 1) fmt.Println(\"reduce:\", result) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180231/:2:4","tags":null,"title":"11.Go语言设计模式","uri":"/lang/go/go_advanced/20250515180231/"},{"categories":null,"content":"\r2.5 5. 观察者模式（行为型） 观察者模式 (Observer Pattern)，定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知，依赖对象在收到通知后，可自行调用自身的处理程序，实现想要干的事情，比如更新自己的状态。 观察者模式也经常被叫做发布 - 订阅（Publish/Subscribe）模式、上面说的定义对象间的一种一对多依赖关系，一 - 指的是发布变更的主体对象，多 - 指的是订阅变更通知的订阅者对象。 代码实现 package main import \"fmt\" // Subject 接口，它相当于是发布者的定义 type Subject interface { Subscribe(observer Observer) // 添加订阅者 Notify(msg string) // 发布通知 } // Observer 观察者接口 相当于订阅者 type Observer interface { Update(msg string) } // Subject 实现 type SubjectImpl struct { observers []Observer } // Subscribe 添加观察者（订阅者） func (sub *SubjectImpl) Subscribe(observer Observer) { sub.observers = append(sub.observers, observer) } // Notify 发布通知 func (sub *SubjectImpl) Notify(msg string) { for _, o := range sub.observers { o.Update(msg) } } // Observer1 Observer1 type Observer1 struct{} // Update 实现观察者接口 func (Observer1) Update(msg string) { fmt.Printf(\"Observer1: %s\\n\", msg) } // Observer2 Observer2 type Observer2 struct{} // Update 实现观察者接口 func (Observer2) Update(msg string) { fmt.Printf(\"Observer2: %s\\n\", msg) } func main(){ sub := \u0026SubjectImpl{} sub.Subscribe(\u0026Observer1{}) sub.Subscribe(\u0026Observer2{}) sub.Notify(\"Hello\") } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180231/:2:5","tags":null,"title":"11.Go语言设计模式","uri":"/lang/go/go_advanced/20250515180231/"},{"categories":null,"content":"\r2.6 6. 代理模式（结构型） 字符串占位符 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180231/:2:6","tags":null,"title":"11.Go语言设计模式","uri":"/lang/go/go_advanced/20250515180231/"},{"categories":null,"content":"\r2.7 7. 选项模式（行为型） 在Python语言中，创建一个对象时，可以给参数设置默认值，这样在不传入任何参数时，可以返回携带默认值的对象，并在需要时修改对象的属性。这种特性可以大大简化开发者创建一个对象的成本，尤其是在对象拥有众多属性时。 代码实现 package options import ( \"time\" ) type Connection struct { addr string cache bool timeout time.Duration } const ( defaultTimeout = 10 defaultCaching = false ) type options struct { timeout time.Duration caching bool } // Option overrides behavior of Connect. type Option interface { apply(*options) } type optionFunc func(*options) func (f optionFunc) apply(o *options) { f(o) } func WithTimeout(t time.Duration) Option { return optionFunc(func(o *options) { o.timeout = t }) } func WithCaching(cache bool) Option { return optionFunc(func(o *options) { o.caching = cache }) } // Connect creates a connection. func Connect(addr string, opts ...Option) (*Connection, error) { options := options{ timeout: defaultTimeout, caching: defaultCaching, } for _, o := range opts { o.apply(\u0026options) } return \u0026Connection{ addr: addr, cache: options.caching, timeout: options.timeout, }, nil } 另外一种实现默认参数的方法 package options import ( \"time\" ) const ( defaultTimeout = 10 defaultCaching = false ) type Connection struct { addr string cache bool timeout time.Duration } // NewConnect creates a connection. func NewConnect(addr string) (*Connection, error) { return \u0026Connection{ addr: addr, cache: defaultCaching, timeout: defaultTimeout, }, nil } // NewConnectWithOptions creates a connection with options. func NewConnectWithOptions(addr string, cache bool, timeout time.Duration) (*Connection, error) { return \u0026Connection{ addr: addr, cache: cache, timeout: timeout, }, nil } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180231/:2:7","tags":null,"title":"11.Go语言设计模式","uri":"/lang/go/go_advanced/20250515180231/"},{"categories":null,"content":"\r2.8 8. 生产者消费者模式（行为型） 单向channel 是经典的生产者消费者模型 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180231/:2:8","tags":null,"title":"11.Go语言设计模式","uri":"/lang/go/go_advanced/20250515180231/"},{"categories":null,"content":" Go语言项目中的性能优化主要有以下几个方面： CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据 Memory Profile（Heap Profile）：报告程序的内存使用情况 Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈 Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:0:0","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r采集性能数据Go语言内置了获取程序的运行数据的工具，包括以下两个标准库： runtime/pprof：采集工具型应用运行数据进行分析 net/http/pprof：采集服务型应用运行时数据进行分析 pprof开启后，每隔一段时间（10ms）就会收集下当前的堆栈信息，获取各个函数占用的CPU以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。 注意，我们只应该在性能测试的时候才在代码中引入pprof。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:1:0","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r工具型应用如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling 的报告保存到文件中，进行分析。对于这种情况，可以使用runtime/pprof库。 首先在代码中导入runtime/pprof工具： import \"runtime/pprof\" ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:2:0","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r1. CPU性能分析开启CPU性能分析： pprof.StartCPUProfile(w io.Writer) 停止CPU性能分析： pprof.StopCPUProfile() 应用执行结束后，就会生成一个文件，保存了我们的 CPU profiling 数据。得到采样数据之后，使用go tool pprof工具进行CPU性能分析。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:2:1","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r2. 内存性能优化记录程序的堆栈信息 pprof.WriteHeapProfile(w io.Writer) 得到采样数据之后，使用go tool pprof工具进行内存性能分析。 go tool pprof默认是使用-inuse_space进行统计，还可以使用-inuse-objects查看分配对象的数量。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:2:2","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r服务型应用如果你的应用程序是一直运行的，比如 web 应用，那么可以使用net/http/pprof库，它能够在提供 HTTP 服务进行分析。 如果使用了默认的http.DefaultServeMux（通常是代码直接使用 http.ListenAndServe(“0.0.0.0:8000”, nil)），只需要在你的web server端代码中按如下方式导入net/http/pprof import _ \"net/http/pprof\" 如果你使用自定义的 Mux，则需要手动注册一些路由规则： r.HandleFunc(\"/debug/pprof/\", pprof.Index) r.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline) r.HandleFunc(\"/debug/pprof/profile\", pprof.Profile) r.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol) r.HandleFunc(\"/debug/pprof/trace\", pprof.Trace) 如果你使用的是gin框架，那么推荐使用github.com/gin-contrib/pprof，在代码中通过以下命令注册pprof相关路由。 pprof.Register(router) 不管哪种方式，你的 HTTP 服务都会多出/debug/pprof endpoint，访问它会得到类似下面的内容： 这个路径下还有几个子页面： /debug/pprof/profile：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载 /debug/pprof/heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件 /debug/pprof/block：block Profiling 的路径 /debug/pprof/goroutines：运行的 goroutines 列表，以及调用关系 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:3:0","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\rgo tool pprof命令不管是工具型应用还是服务型应用，我们使用相应的pprof库获取数据之后，下一步的都要对这些数据进行分析，我们可以使用go tool pprof命令行工具。 go tool pprof最简单的使用方式为: go tool pprof [binary] [source] 其中： binary 是应用的二进制文件，用来解析各种符号； source 表示 profile 数据的来源，可以是本地的文件，也可以是 http 地址。 注意事项： 获取的 Profiling 数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:4:0","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r具体示例首先我们来写一段有问题的代码： // runtime_pprof/main.go package main import ( \"flag\" \"fmt\" \"os\" \"runtime/pprof\" \"time\" ) // 一段有问题的代码 func logicCode() { var c chan int for { select { case v := \u003c-c: fmt.Printf(\"recv from chan, value:%v\\n\", v) default: } } } func main() { var isCPUPprof bool var isMemPprof bool flag.BoolVar(\u0026isCPUPprof, \"cpu\", false, \"turn cpu pprof on\") flag.BoolVar(\u0026isMemPprof, \"mem\", false, \"turn mem pprof on\") flag.Parse() if isCPUPprof { file, err := os.Create(\"./cpu.pprof\") if err != nil { fmt.Printf(\"create cpu pprof failed, err:%v\\n\", err) return } pprof.StartCPUProfile(file) defer pprof.StopCPUProfile() } for i := 0; i \u003c 8; i++ { go logicCode() } time.Sleep(20 * time.Second) if isMemPprof { file, err := os.Create(\"./mem.pprof\") if err != nil { fmt.Printf(\"create mem pprof failed, err:%v\\n\", err) return } pprof.WriteHeapProfile(file) file.Close() } } 通过flag我们可以在命令行控制是否开启CPU和Mem的性能分析。 将上面的代码保存并编译成runtime_pprof可执行文件，执行时加上-cpu命令行参数如下： ./runtime_pprof -cpu 等待30秒后会在当前目录下生成一个cpu.pprof文件。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:5:0","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r1. 命令行交互界面我们使用go工具链里的pprof来分析一下。 go tool pprof cpu.pprof 执行上面的代码会进入交互界面如下： runtime_pprof $ go tool pprof cpu.pprof Type: cpu Time: Jun 28, 2019 at 11:28am (CST) Duration: 20.13s, Total samples = 1.91mins (568.60%) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) 我们可以在交互界面输入top3来查看程序中占用CPU前3位的函数： (pprof) top3 Showing nodes accounting for 100.37s, 87.68% of 114.47s total Dropped 17 nodes (cum \u003c= 0.57s) Showing top 3 nodes out of 4 flat flat% sum% cum cum% 42.52s 37.15% 37.15% 91.73s 80.13% runtime.selectnbrecv 35.21s 30.76% 67.90% 39.49s 34.50% runtime.chanrecv 22.64s 19.78% 87.68% 114.37s 99.91% main.logicCode 其中： flat：当前函数占用CPU的耗时 flat：:当前函数占用CPU的耗时百分比 sun%：函数占用CPU的耗时累计百分比 cum：当前函数加上调用当前函数的函数占用CPU的总耗时 cum%：当前函数加上调用当前函数的函数占用CPU的总耗时百分比 最后一列：函数名称 在大多数的情况下，我们可以通过分析这五列得出一个应用程序的运行情况，并对程序进行优化。 我们还可以使用list 函数名命令查看具体的函数分析，例如执行list logicCode查看我们编写的函数的详细分析。 (pprof) list logicCode Total: 1.91mins ROUTINE ================ main.logicCode in .../runtime_pprof/main.go 22.64s 1.91mins (flat, cum) 99.91% of Total . . 12:func logicCode() { . . 13: var c chan int . . 14: for { . . 15: select { . . 16: case v := \u003c-c: 22.64s 1.91mins 17: fmt.Printf(\"recv from chan, value:%v\\n\", v) . . 18: default: . . 19: . . 20: } . . 21: } . . 22:} 通过分析发现大部分CPU资源被17行占用，我们分析出select语句中的default没有内容会导致上面的case v:=\u003c-c:一直执行。我们在default分支添加一行time.Sleep(time.Second)即可。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:5:1","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r2. 图形化或者可以直接输入web，通过svg图的方式查看程序中详细的CPU占用情况。 想要查看图形化的界面首先需要安装graphviz图形化工具。 Mac： brew install graphviz Windows: 下载graphviz 将graphviz安装目录下的bin文件夹添加到Path环境变量中。 在终端输入dot -version查看是否安装成功。 关于图形的说明： 每个框代表一个函数，理论上框的越大表示占用的CPU资源越多。 方框之间的线条代表函数之间的调用关系。 线条上的数字表示函数调用的次数。 方框中的第一行数字表示当前函数占用CPU的百分比，第二行数字表示当前函数累计占用CPU的百分比。 除了分析CPU性能数据，pprof也支持分析内存性能数据。比如，使用下面的命令分析http服务的heap性能数据，查看当前程序的内存占用以及热点内存对象使用的情况。 # 查看内存占用数据 go tool pprof -inuse_space http://127.0.0.1:8080/debug/pprof/heap go tool pprof -inuse_objects http://127.0.0.1:8080/debug/pprof/heap # 查看临时内存分配数据 go tool pprof -alloc_space http://127.0.0.1:8080/debug/pprof/heap go tool pprof -alloc_objects http://127.0.0.1:8080/debug/pprof/heap ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:5:2","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\rgo-torch和火焰图火焰图（Flame Graph）是 Bredan Gregg 创建的一种性能分析图表，因为它的样子近似 🔥而得名。上面的 profiling 结果也转换成火焰图，如果对火焰图比较了解可以手动来操作，不过这里我们要介绍一个工具：go-torch。这是 uber 开源的一个工具，可以直接读取 golang profiling 数据，并生成一个火焰图的 svg 文件。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:6:0","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r1. 安装go-torch go get -v github.com/uber/go-torch 火焰图 svg 文件可以通过浏览器打开，它对于调用图的最优点是它是动态的：可以通过点击每个方块来 zoom in 分析它上面的内容。 火焰图的调用顺序从下到上，每个方块代表一个函数，它上面一层表示这个函数会调用哪些函数，方块的大小代表了占用 CPU 使用的长短。火焰图的配色并没有特殊的意义，默认的红、黄配色是为了更像火焰而已。 go-torch 工具的使用非常简单，没有任何参数的话，它会尝试从http://localhost:8080/debug/pprof/profile获取 profiling 数据。它有三个常用的参数可以调整： -u –url：要访问的 URL，这里只是主机和端口部分 -s –suffix：pprof profile 的路径，默认为 /debug/pprof/profile –seconds：要执行 profiling 的时间长度，默认为 30s ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:6:1","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r2. 安装 FlameGraph要生成火焰图，需要事先安装 FlameGraph工具，这个工具的安装很简单（需要perl环境支持），只要把对应的可执行文件加入到环境变量中即可。 下载安装perl：https://www.perl.org/get.html 下载FlameGraph：git clone https://github.com/brendangregg/FlameGraph.git 将FlameGraph目录加入到操作系统的环境变量中。 Windows平台的同学，需要把go-torch/render/flamegraph.go文件中的GenerateFlameGraph按如下方式修改，然后在go-torch目录下执行go install即可。 // GenerateFlameGraph runs the flamegraph script to generate a flame graph SVG. func GenerateFlameGraph(graphInput []byte, args ...string) ([]byte, error) { flameGraph := findInPath(flameGraphScripts) if flameGraph == \"\" { return nil, errNoPerlScript } if runtime.GOOS == \"windows\" { return runScript(\"perl\", append([]string{flameGraph}, args...), graphInput) } return runScript(flameGraph, args, graphInput) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:6:2","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r3. 压测工具wrk推荐使用https://github.com/wg/wrk 或 https://github.com/adjust/go-wrk ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:6:3","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\r4. 使用go-torch使用wrk进行压测: go-wrk -n 50000 http://127.0.0.1:8080/book/list 在上面压测进行的同时，打开另一个终端执行: go-torch -u http://127.0.0.1:8080 -t 30 30秒之后终端会初夏如下提示：Writing svg to torch.svg 然后我们使用浏览器打开torch.svg就能看到如下火焰图了。 火焰图的y轴表示cpu调用方法的先后，x轴表示在每个采样调用时间内，方法所占的时间百分比，越宽代表占据cpu时间越多。通过火焰图我们就可以更清楚的找出耗时长的函数调用，然后不断的修正代码，重新采样，不断优化。 此外还可以借助火焰图分析内存性能数据： go-torch -inuse_space http://127.0.0.1:8080/debug/pprof/heap go-torch -inuse_objects http://127.0.0.1:8080/debug/pprof/heap go-torch -alloc_space http://127.0.0.1:8080/debug/pprof/heap go-torch -alloc_objects http://127.0.0.1:8080/debug/pprof/heap ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:6:4","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\rpprof与性能测试结合go test命令有两个参数和 pprof 相关，它们分别指定生成的 CPU 和 Memory profiling 保存的文件： -cpuprofile：cpu profiling 数据要保存的文件地址 -memprofile：memory profiling 数据要报文的文件地址 我们还可以选择将pprof与性能测试相结合，比如： 比如下面执行测试的同时，也会执行 CPU profiling，并把结果保存在 cpu.prof 文件中： go test -bench . -cpuprofile=cpu.prof 比如下面执行测试的同时，也会执行 Mem profiling，并把结果保存在 cpu.prof 文件中： go test -bench . -memprofile=./mem.prof 需要注意的是，Profiling 一般和性能测试一起使用，这个原因在前文也提到过，只有应用在负载高的情况下 Profiling 才有意义。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180223/:7:0","tags":null,"title":"9.Go性能调优 pprof","uri":"/lang/go/go_advanced/20250515180223/"},{"categories":null,"content":"\rsync.Cond 的使用场景 一句话总结：sync.Cond 条件变量用来协调想要访问共享资源的那些 goroutine，当共享资源的状态发生变化的时候，它可以用来通知被互斥锁阻塞的 goroutine。 sync.Cond 基于互斥锁/读写锁，它和互斥锁的区别是什么呢？ 互斥锁 sync.Mutex 通常用来保护临界区和共享资源，条件变量 sync.Cond 用来协调想要访问共享资源的 goroutine。 sync.Cond 经常用在多个 goroutine 等待，一个 goroutine 通知（事件发生）的场景。如果是一个通知，一个等待，使用互斥锁或 channel 就能搞定了。 我们想象一个非常简单的场景： 有一个协程在异步地接收数据，剩下的多个协程必须等待这个协程接收完数据，才能读取到正确的数据。在这种情况下，如果单纯使用 chan 或互斥锁，那么只能有一个协程可以等待，并读取到数据，没办法通知其他的协程也读取数据。 这个时候，就需要有个全局的变量来标志第一个协程数据是否接受完毕，剩下的协程，反复检查该变量的值，直到满足要求。或者创建多个 channel，每个协程阻塞在一个 channel 上，由接收数据的协程在数据接收完毕后，逐个通知。总之，需要额外的复杂度来完成这件事。 Go 语言在标准库 sync 中内置一个 sync.Cond 用来解决这类问题。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180217/:1:0","tags":null,"title":"8-6. sync.Cond 条件变量","uri":"/lang/go/go_advanced/20250515180217/"},{"categories":null,"content":"\rsync.Cond 的四个方法 sync.Cond 的定义如下： type Cond struct { noCopy noCopy // L is held while observing or changing the condition L Locker notify notifyList checker copyChecker } 每个 Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，必须加锁。 sync.Cond 相关的有如下几个方法： NewCond() 创建实例 Wait() 等待 Signal() 唤醒任意一个协程 Broadcast() 广播唤醒所有协程 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180217/:2:0","tags":null,"title":"8-6. sync.Cond 条件变量","uri":"/lang/go/go_advanced/20250515180217/"},{"categories":null,"content":"\r1. NewCond 创建实例 NewCond 创建 Cond 实例时，需要关联一个锁。 func NewCond(l Locker) *Cond ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180217/:2:1","tags":null,"title":"8-6. sync.Cond 条件变量","uri":"/lang/go/go_advanced/20250515180217/"},{"categories":null,"content":"\r2. Broadcast 广播唤醒所有 Broadcast 唤醒所有等待条件变量 c 的 goroutine，无需锁保护。 // Broadcast wakes all goroutines waiting on c. // // It is allowed but not required for the caller to hold c.L // during the call. func (c *Cond) Broadcast() ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180217/:2:2","tags":null,"title":"8-6. sync.Cond 条件变量","uri":"/lang/go/go_advanced/20250515180217/"},{"categories":null,"content":"\r3. Signal 唤醒一个协程 Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护。 // Signal wakes one goroutine waiting on c, if there is any. // // It is allowed but not required for the caller to hold c.L // during the call. func (c *Cond) Signal() ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180217/:2:3","tags":null,"title":"8-6. sync.Cond 条件变量","uri":"/lang/go/go_advanced/20250515180217/"},{"categories":null,"content":"\r4. Wait 等待 调用 Wait 会自动释放锁 c.L，并挂起调用者所在的 goroutine，因此当前协程会阻塞在 Wait 方法调用的地方。如果其他协程调用了 Signal 或 Broadcast 唤醒了该协程，那么 Wait 方法在结束阻塞时，会重新给 c.L 加锁，并且继续执行 Wait 后面的代码。 对条件的检查，使用了 for !condition() 而非 if，是因为当前协程被唤醒时，条件不一定符合要求，需要再次 Wait 等待下次被唤醒。为了保险起见，使用 for 能够确保条件符合要求后，再执行后续的代码。 c.L.Lock() for !condition() { c.Wait() } ... make use of condition ... c.L.Unlock() ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180217/:2:4","tags":null,"title":"8-6. sync.Cond 条件变量","uri":"/lang/go/go_advanced/20250515180217/"},{"categories":null,"content":"\r使用示例 接下来我们实现一个简单的例子，三个协程调用 Wait() 等待，另一个协程调用 Broadcast() 唤醒所有等待的协程。 var done = false func read(name string, c *sync.Cond) { c.L.Lock() for !done { c.Wait() } log.Println(name, \"starts reading\") c.L.Unlock() } func write(name string, c *sync.Cond) { log.Println(name, \"starts writing\") time.Sleep(time.Second) c.L.Lock() done = true c.L.Unlock() log.Println(name, \"wakes all\") c.Broadcast() } func main() { cond := sync.NewCond(\u0026sync.Mutex{}) go read(\"reader1\", cond) go read(\"reader2\", cond) go read(\"reader3\", cond) write(\"writer\", cond) time.Sleep(time.Second * 3) } done 即互斥锁需要保护的条件变量 read() 调用 Wait() 等待通知，直到 done 为 true。 write() 接收数据，接收完成后，将 done 置为 true，调用 Broadcast() 通知所有等待的协程。 write() 中的暂停了 1s，一方面是模拟耗时，另一方面是确保前面的 3 个 read 协程都执行到 Wait()，处于等待状态。main 函数最后暂停了 3s，确保所有操作执行完毕。 运行结果如下： $ go run main.go 2021/01/14 23:18:20 writer starts writing 2021/01/14 23:18:21 writer wakes all 2021/01/14 23:18:21 reader2 starts reading 2021/01/14 23:18:21 reader3 starts reading 2021/01/14 23:18:21 reader1 starts reading writer 接收数据花费了 1s，同步通知所有等待的协程。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180217/:3:0","tags":null,"title":"8-6. sync.Cond 条件变量","uri":"/lang/go/go_advanced/20250515180217/"},{"categories":null,"content":"\r使用场景 sync.Once 是 Go 标准库提供的使函数只执行一次的实现，常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。 init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。 sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。 在多数情况下，sync.Once 被用于控制变量的初始化，这个变量的读写满足如下三个条件： 当且仅当第一次访问某个变量时，进行初始化（写）； 变量初始化过程中，所有读都被阻塞，直到初始化完成； 变量仅初始化一次，初始化完成后驻留在内存里。 sync.Once 仅提供了一个方法 Do，参数 f 是对象初始化函数。 func (o *Once) Do(f func()) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180215/:1:0","tags":null,"title":"8-5. sync.Once 单例模式","uri":"/lang/go/go_advanced/20250515180215/"},{"categories":null,"content":"\r使用示例 一个简单的 Demo 考虑一个简单的场景，函数 ReadConfig 需要读取环境变量，并转换为对应的配置。环境变量在程序执行前已经确定，执行过程中不会发生改变。ReadConfig 可能会被多个协程并发调用，为了提升性能（减少执行时间和内存占用），使用 sync.Once 是一个比较好的方式。 标准库中 sync.Once 的使用 path.Cwd() // Cwd returns the current working directory at the time of the first call. func Cwd() string { cwdOnce.Do(func() { var err error cwd, err = os.Getwd() if err != nil { Fatalf(\"cannot determine current directory: %v\", err) } }) return cwd } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180215/:2:0","tags":null,"title":"8-5. sync.Once 单例模式","uri":"/lang/go/go_advanced/20250515180215/"},{"categories":null,"content":"\rsync.Once 的原理 首先：保证变量仅被初始化一次，需要有个标志来判断变量是否已初始化过，若没有则需要初始化。 其次：线程安全，支持并发，无疑需要互斥锁来实现。 源码 package sync import ( \"sync/atomic\" ) type Once struct { done uint32 m Mutex } func (o *Once) Do(f func()) { if atomic.LoadUint32(\u0026o.done) == 0 { // Outlined slow-path to allow inlining of the fast-path. o.doSlow(f) } } func (o *Once) doSlow(f func()) { o.m.Lock() defer o.m.Unlock() if o.done == 0 { defer atomic.StoreUint32(\u0026o.done, 1) f() } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180215/:3:0","tags":null,"title":"8-5. sync.Once 单例模式","uri":"/lang/go/go_advanced/20250515180215/"},{"categories":null,"content":"\rsync.Pool sync.Pool 除了最常见的池化提升性能的思路，最重要的是减少 GC 。 常用于一些对象实例创建昂贵的场景。注意，Pool 是 Goroutine 并发安全的。 可以作为保存临时取还对象的一个“池子”。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180211/:1:0","tags":null,"title":"8-4. sync.Pool 复用对象","uri":"/lang/go/go_advanced/20250515180211/"},{"categories":null,"content":"\r特点 Goroutine 并发安全的 存储的都是临时对象 自动移除, 清理完全是由runtime控制的, 随时都可能被无通知清除 当这个对象的引用只有sync.Pool持有时，这个对象内存会被释放 目的就是缓存并重用对象，减少GC的压力 自动扩容、缩容 不能对 Pool.Get 出来的对象做预判，有可能是新的（新分配的），有可能是旧的（之前人用过，然后 Put 进去的） 当用完一个从 Pool 取出的实例时候，一定要记得调用 Put，否则 Pool 无法复用这个实例，通常这个用 defer 完成； ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180211/:2:0","tags":null,"title":"8-4. sync.Pool 复用对象","uri":"/lang/go/go_advanced/20250515180211/"},{"categories":null,"content":"\r源码解析","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180211/:3:0","tags":null,"title":"8-4. sync.Pool 复用对象","uri":"/lang/go/go_advanced/20250515180211/"},{"categories":null,"content":"\r1.结构 type Pool struct { noCopy noCopy local unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal localSize uintptr // size of the local array victim unsafe.Pointer // local from previous cycle victimSize uintptr // size of victims array // New optionally specifies a function to generate // a value when Get would otherwise return nil. // It may not be changed concurrently with calls to Get. New func() interface{} } // Local per-P Pool appendix. type poolLocalInternal struct { private interface{} // Can be used only by the respective P. shared poolChain // Local P can pushHead/popHead; any P can popTail. } type poolLocal struct { poolLocalInternal // Prevents false sharing on widespread platforms with // 128 mod (cache line size) = 0 . pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte } local这里面真正的是[P]poolLocal其中P就是GPM模型中的P，有多少个P数组就有多大，也就是每个P维护了一个本地的poolLocal。 poolLocal里面维护了一个private一个shared，看名字其实就很明显了，private是给自己用的，而shared的是一个队列，可以给别人用的。注释写的也很清楚，自己可以从队列的头部存然后从头部取，而别的P可以从尾部取。 victim这个从字面上面也可以知道，幸存者嘛，当进行gc的stw时候，会将local中的对象移到victim中去，也就是说幸存了一次gc， ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180211/:3:1","tags":null,"title":"8-4. sync.Pool 复用对象","uri":"/lang/go/go_advanced/20250515180211/"},{"categories":null,"content":"\r2. Get func (p *Pool) Get() interface{} { ...... l, pid := p.pin() x := l.private l.private = nil if x == nil { // Try to pop the head of the local shard. We prefer // the head over the tail for temporal locality of // reuse. x, _ = l.shared.popHead() if x == nil { x = p.getSlow(pid) } } runtime_procUnpin() ...... if x == nil \u0026\u0026 p.New != nil { x = p.New() } return x } func (p *Pool) getSlow(pid int) interface{} { // See the comment in pin regarding ordering of the loads. size := atomic.LoadUintptr(\u0026p.localSize) // load-acquire locals := p.local // load-consume // Try to steal one element from other procs. for i := 0; i \u003c int(size); i++ { l := indexLocal(locals, (pid+i+1)%int(size)) if x, _ := l.shared.popTail(); x != nil { return x } } // Try the victim cache. We do this after attempting to steal // from all primary caches because we want objects in the // victim cache to age out if at all possible. size = atomic.LoadUintptr(\u0026p.victimSize) if uintptr(pid) \u003e= size { return nil } locals = p.victim l := indexLocal(locals, pid) if x := l.private; x != nil { l.private = nil return x } for i := 0; i \u003c int(size); i++ { l := indexLocal(locals, (pid+i)%int(size)) if x, _ := l.shared.popTail(); x != nil { return x } } // Mark the victim cache as empty for future gets don't bother // with it. atomic.StoreUintptr(\u0026p.victimSize, 0) return nil } 如果 private 不是空的，那就直接拿来用 如果 private 是空的，那就先去本地的shared队列里面从头 pop 一个 如果本地的 shared 也没有了，那 getSlow 去拿，其实就是去别的P的 shared 里面偷，偷不到回去 victim 幸存者里面找 如果最后都没有，那就只能调用 New 方法创建一个了 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180211/:3:2","tags":null,"title":"8-4. sync.Pool 复用对象","uri":"/lang/go/go_advanced/20250515180211/"},{"categories":null,"content":"\r3. Put // Put adds x to the pool. func (p *Pool) Put(x interface{}) { if x == nil { return } ...... l, _ := p.pin() if l.private == nil { l.private = x x = nil } if x != nil { l.shared.pushHead(x) } runtime_procUnpin() ...... } 如果 private 没有，就放在 private 如果 private 有了，那么就放到 shared 队列的头部 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180211/:3:3","tags":null,"title":"8-4. sync.Pool 复用对象","uri":"/lang/go/go_advanced/20250515180211/"},{"categories":null,"content":"\r应用场景 当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。 对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 sync.Pool 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。 标准库中 encoding/json 也用到了 sync.Pool 来提升性能。 著名的 gin 框架，对 context 取用也到了 sync.Pool。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180211/:4:0","tags":null,"title":"8-4. sync.Pool 复用对象","uri":"/lang/go/go_advanced/20250515180211/"},{"categories":null,"content":"\rdemo","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180211/:5:0","tags":null,"title":"8-4. sync.Pool 复用对象","uri":"/lang/go/go_advanced/20250515180211/"},{"categories":null,"content":"\r1. 未使用sync.Pool package main import ( \"fmt\" \"sync\" \"sync/atomic\" ) var createNum int32 func createBuffer() interface{} { atomic.AddInt32(\u0026createNum, 1) buffer := make([]byte, 1024) return buffer } func main() { workerPool := 1024 * 1024 var wg sync.WaitGroup wg.Add(workerPool) for i := 0; i \u003c workerPool; i++ { go func() { defer wg.Done() buffer := createBuffer() _ = buffer.([]byte) }() } wg.Wait() fmt.Printf(\" %d buffer objects were created.\\n\", createNum) } 输出结果: 1048576 buffer objects were created., 对象被创建了1048576次 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180211/:5:1","tags":null,"title":"8-4. sync.Pool 复用对象","uri":"/lang/go/go_advanced/20250515180211/"},{"categories":null,"content":"\r2. 使用sync.Pool package main import ( \"fmt\" \"sync\" \"sync/atomic\" ) var createNum int32 func createBuffer() interface{} { atomic.AddInt32(\u0026createNum, 1) buffer := make([]byte, 1024) return buffer } func main() { bufferPool := \u0026sync.Pool{New: createBuffer} workerPool := 1024 * 1024 var wg sync.WaitGroup wg.Add(workerPool) for i := 0; i \u003c workerPool; i++ { go func() { defer wg.Done() buffer := bufferPool.Get() _ = buffer.([]byte) defer bufferPool.Put(buffer) }() } wg.Wait() fmt.Printf(\" %d buffer objects were created.\\n\", createNum) } 最终输出结果: 8 buffer objects were create. 也就是对象创建了8次 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180211/:5:2","tags":null,"title":"8-4. sync.Pool 复用对象","uri":"/lang/go/go_advanced/20250515180211/"},{"categories":null,"content":"\r分布式ID的特点 全局唯一性：不能出现有重复的ID标识，这是基本要求。 递增性：确保生成ID对于用户或业务是递增的。 高可用性：确保任何时候都能生成正确的D。 高性能性：在高并发的环境下依然表现良好。 不仅仅是用于用户ID，实际互联网中有很多场景需要能够生成类似MySQL自增ID这样不断增大，同时又不会重复的id。以支持业务中的高并发场景。比较典型的场景有： 电商促销时短时间内会有大量的订单涌入到系统，比如每秒10w+； 明星出轨时微博短时间内会产生大量的相关微博转发和评论消息。 在这些业务场景下将数据插入数据库之前，我们需要给这些订单和消息先分配一个唯一ID，然后再保存到数据库中。对这个id的要求是希望其中能带有一些时间信息，这样即使我们后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进行排序。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180208/:1:0","tags":null,"title":"8-3.分布式id 库snowflake和sonyflake","uri":"/lang/go/go_advanced/20250515180208/"},{"categories":null,"content":"\rsnowflake","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180208/:2:0","tags":null,"title":"8-3.分布式id 库snowflake和sonyflake","uri":"/lang/go/go_advanced/20250515180208/"},{"categories":null,"content":"\r1. 原理 Twitter 的 Snowflake 算法规范 整个ID是存储在int64中的63位整数 41位用于存储收到请求的时间戳 - 单位毫秒 10位用于存储节点 - 范围从0到1023 12位用于存储序列号 - 范围从0到4095 由于最高位是标识位，为1表示为负数，因此最高位不使用。 41bit 保存时间戳，精确到毫秒。也就是说最大可以使用的年限是69年。 10bit 的机器位，能部属在1024台机器节点来生成ID。 12bit 的序列号，一毫秒最大生成惟一ID的数量为4096个。 1 bit：不用，为啥呢？因为二进制里第一个bit为如果是1，那么都是负数，但是我们生成的id都是正数，所以第一个bit统一都是0 41 bit：41 bit可以表示的数字多达2^41 - 1，也就是可以标识2 ^ 41 - 1个毫秒值，换算成年就是表示69年的时间。 10 bit：代表的是这个服务最多可以部署在2^10台机器上哪，也就是1024台机器。但是10 bit里5个bit代表机房id，5个bit代表机器id。意思就是最多代表2 ^ 5个机房（32个机房），每个机房里可以代表2 ^ 5个机器（32台机器）。 12 bit：这个是用来记录同一个毫秒内产生的不同id，12 bit可以代表的最大正整数是2 ^ 12 - 1 = 4096，也就是说可以用这个12bit代表的数字来区分同一个毫秒内的4096个不同的id 同一台机器上，同一毫秒内可以产生4096个id，一秒共400w个id，理论完全够用。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180208/:2:1","tags":null,"title":"8-3.分布式id 库snowflake和sonyflake","uri":"/lang/go/go_advanced/20250515180208/"},{"categories":null,"content":"\r2. demo 推特开源库: https://github.com/bwmarrin/snowflake package main import ( \"fmt\" \"github.com/bwmarrin/snowflake\" \"log\" \"time\" ) func BuildSnowFlakeId(starTime string, machineID int64) (id int64, err error) { var st time.Time st, err = time.Parse(\"2006-01-02\", starTime) if err != nil { return 0, err } snowflake.Epoch = st.UnixNano() / 1000000 node, err := snowflake.NewNode(machineID) if err != nil { return 0, err } id = node.Generate().Int64() return id, err } func main() { startTime := time.Now().Format(\"2006-01-02\") snowFlakeId, err := BuildSnowFlakeId(startTime, 1) if err != nil { log.Fatalln(err) } fmt.Println(snowFlakeId) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180208/:2:2","tags":null,"title":"8-3.分布式id 库snowflake和sonyflake","uri":"/lang/go/go_advanced/20250515180208/"},{"categories":null,"content":"\rsonyflake","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180208/:3:0","tags":null,"title":"8-3.分布式id 库snowflake和sonyflake","uri":"/lang/go/go_advanced/20250515180208/"},{"categories":null,"content":"\r1. 原理 Snowflake算法是相当灵活的，我们可以根据自己的业务需要，对63 bit的的各个部分进行增减。索尼公司的Sonyflake对原生的Snowflake进行改进，重新分配了各部分的bit位: 由于最高位是标识位，为1表示为负数，因此最高位不使用. 39bit 来保存时间戳，与原生的Snowflake不同的地方是，Sonyflake是以10毫秒为单位来保存时间的。这样的话，可以使用的年限为 174年 比Snowflake长太多了。 8bit 做为序列号，每10毫最大生成256个，1秒最多生成25600个，比原生的Snowflake少好多，如果感觉不够用，目前的解决方案是跑多个实例生成同一业务的ID来弥补。 16bit 做为机器号，默认的是当前机器的私有IP的最后两位 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180208/:3:1","tags":null,"title":"8-3.分布式id 库snowflake和sonyflake","uri":"/lang/go/go_advanced/20250515180208/"},{"categories":null,"content":"\r2. demo package main import ( \"fmt\" \"time\" \"github.com/sony/sonyflake\" ) func BuildSonyFlakeID(starTime string, machineID uint16) (id int64, err error) { var sf *sonyflake.Sonyflake var st sonyflake.Settings st.MachineID = func() (uint16, error) { return machineID, nil } starT, err := time.Parse(\"2006-01-02\", starTime) if err != nil { return 0, err } st.StartTime = starT sf = sonyflake.NewSonyflake(st) if sf == nil { panic(\"sonyflake not created\") } idUint64, err := sf.NextID() if err != nil { return 0, err } return int64(idUint64), err } func main() { id, err := BuildSonyFlakeID(time.Now().Format(\"2006-01-02\"), 1) if err != nil { panic(err) } fmt.Println(id) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180208/:3:2","tags":null,"title":"8-3.分布式id 库snowflake和sonyflake","uri":"/lang/go/go_advanced/20250515180208/"},{"categories":null,"content":" 在项目中我们通常可能会使用database/sql连接MySQL数据库。本文借助使用sqlx实现批量插入数据的例子，介绍了sqlx中可能被你忽视了的sqlx.In和DB.NamedExec方法。 一. 基本操作","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:0:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r1. sqlx介绍 在项目中我们通常可能会使用database/sql连接MySQL数据库。sqlx可以认为是Go语言内置database/sql的超集，它在优秀的内置database/sql基础上提供了一组扩展。这些扩展中除了大家常用来查询的Get(dest interface{}, ...) error和Select(dest interface{}, ...) error外还有很多其他强大的功能。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:1:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r2. 安装sqlx go get github.com/jmoiron/sqlx // 拉取master分支最新代码 go get github.com/jmoiron/sqlx@master ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:2:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r3. 连接数据库 package main import ( \"fmt\" \"github.com/jmoiron/sqlx\" ) var DbSqlx *sqlx.DB func InitDbSqlx() (err error) { //用户:密码@tcp(ip:端口)/数据库?charset=utf8mb4\u0026parseTime=True dsn := \"root:@tcp(127.0.0.1:3306)/go_mysql_test?charset=utf8mb4\u0026parseTime=True\" // 也可以使用MustConnect连接不成功就panic DbSqlx, err = sqlx.Connect(\"mysql\", dsn) if err != nil { fmt.Printf(\"connect DB failed, err:%v\\n\", err) return } DbSqlx.SetMaxOpenConns(20) DbSqlx.SetMaxIdleConns(10) return } func main() { // sqlx使用 err := InitDbSqlx() if err != nil { fmt.Printf(\"init db failed, err: %v\\n\", err) return } fmt.Printf(\"init db success db%v\\n\", DbSqlx) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:3:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r4. 查询查询单行数据和查询多行数据示例代码如下： package main import \"fmt\" // 查询单条数据示例 func QueryRowSqlxDemo(id int) { sqlStr := \"select id, name, age from user where id=?\" var u User err := DbSqlx.Get(\u0026u, sqlStr, id) if err != nil { fmt.Printf(\"get failed, err:%v\\n\", err) return } fmt.Printf(\"id:%d name:%s age:%d\\n\", u.Id, u.Name, u.Age) } // 查询多条数据示例 func QueryMultiRowSqlxDemo(id int) { sqlStr := \"select id, name, age from user where id \u003e ?\" var users []User err := DbSqlx.Select(\u0026users, sqlStr, id) if err != nil { fmt.Printf(\"query failed, err:%v\\n\", err) return } fmt.Printf(\"users:%#v\\n\", users) } func main() { // sqlx使用 err := InitDbSqlx() if err != nil { fmt.Printf(\"init db failed, err: %v\\n\", err) return } fmt.Printf(\"init db success db%v\\n\", DbSqlx) // 查询单条数据示例 QueryRowSqlxDemo(1) // 查询多条数据示例 QueryMultiRowSqlxDemo(1) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:4:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r5. 插入sqlx中的exec方法与原生sql中的exec使用基本一致： package main import \"fmt\" // 插入数据示例 func InsertRowSqlxDemo(name string, age int) { sqlStr := \"insert into user(name, age) values (?,?)\" ret, err := DbSqlx.Exec(sqlStr, name, age) if err != nil { fmt.Printf(\"insert failed, err:%v\\n\", err) return } theID, err := ret.LastInsertId() // 新插入数据的id if err != nil { fmt.Printf(\"get lastinsert ID failed, err:%v\\n\", err) return } fmt.Printf(\"insert success, the id is %d.\\n\", theID) } func main() { // sqlx使用 err := InitDbSqlx() if err != nil { fmt.Printf(\"init db failed, err: %v\\n\", err) return } fmt.Printf(\"init db success db%v\\n\", DbSqlx) // 插入数据 InsertRowSqlxDemo(\"RandySunSqlx\", 18) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:5:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r6. 更新 package main import \"fmt\" // 更新数据示例 func UpdateRowSqlxDemo(id, age int) { sqlStr := \"update user set age=? where id = ?\" ret, err := DbSqlx.Exec(sqlStr, age, id) if err != nil { fmt.Printf(\"update failed, err:%v\\n\", err) return } n, err := ret.RowsAffected() // 操作影响的行数 if err != nil { fmt.Printf(\"get RowsAffected failed, err:%v\\n\", err) return } fmt.Printf(\"update success, affected rows:%d\\n\", n) } func main() { // sqlx使用 err := InitDbSqlx() if err != nil { fmt.Printf(\"init db failed, err: %v\\n\", err) return } fmt.Printf(\"init db success db%v\\n\", DbSqlx) // 更新数据 UpdateRowSqlxDemo(7, 20) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:6:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r7. 删除 package main import \"fmt\" // 删除数据示例 func DeleteRowSqlxDemo(id int) { sqlStr := \"delete from user where id = ?\" ret, err := DbSqlx.Exec(sqlStr, id) if err != nil { fmt.Printf(\"delete failed, err:%v\\n\", err) return } n, err := ret.RowsAffected() // 操作影响的行数 if err != nil { fmt.Printf(\"get RowsAffected failed, err:%v\\n\", err) return } fmt.Printf(\"delete success, affected rows:%d\\n\", n) } func main() { // sqlx使用 err := InitDbSqlx() if err != nil { fmt.Printf(\"init db failed, err: %v\\n\", err) return } fmt.Printf(\"init db success db%v\\n\", DbSqlx) // 删除数据 DeleteRowSqlxDemo(7) } 二. 特殊方法","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:7:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r1. NamedExecDB.NamedExec方法用来绑定SQL语句与结构体或map中的同名字段。 package main // 指定map同名字段 func InsertUserSqlxDemo() (err error) { sqlStr := \"INSERT INTO user (name,age) VALUES (:name,:age)\" _, err = DbSqlx.NamedExec(sqlStr, map[string]interface{}{ \"name\": \"RandySun2\", \"age\": 18, }) return } func main() { // sqlx使用 err := InitDbSqlx() if err != nil { fmt.Printf(\"init db failed, err: %v\\n\", err) return } fmt.Printf(\"init db success db%v\\n\", DbSqlx) // 删除数据 InsertUserSqlxDemo() } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:8:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r2. NamedQuery与DB.NamedExec同理，这里是支持查询。 package main import \"fmt\" /* @create 2021-08-31-8:34 */ func NamedQuerySqlxDemo() { sqlStr := \"SELECT * FROM user WHERE name=:name\" // 使用map做命名查询 rows, err := DbSqlx.NamedQuery(sqlStr, map[string]interface{}{\"name\": \"Barry\"}) if err != nil { fmt.Printf(\"db.NamedQuery failed, err:%v\\n\", err) return } defer rows.Close() for rows.Next() { var u User // 放到结构体中 err := rows.StructScan(\u0026u) // 放到map //err := rows.MapScan(\u0026u) // 放到切片 //err := rows.SliceScan(\u0026u) if err != nil { fmt.Printf(\"scan failed, err:%v\\n\", err) continue } fmt.Printf(\"user:%#v\\n\", u) } u := User{ Name: \"Randy\", } // 使用结构体命名查询，根据结构体字段的 db tag进行映射 rows, err = DbSqlx.NamedQuery(sqlStr, u) if err != nil { fmt.Printf(\"db.NamedQuery failed, err:%v\\n\", err) return } defer rows.Close() for rows.Next() { var u User err := rows.StructScan(\u0026u) if err != nil { fmt.Printf(\"scan failed, err:%v\\n\", err) continue } fmt.Printf(\"user:%#v\\n\", u) } } func main() { // sqlx使用 err := InitDbSqlx() if err != nil { fmt.Printf(\"init db failed, err: %v\\n\", err) return } fmt.Printf(\"init db success db%v\\n\", DbSqlx) NamedQuerySqlxDemo() } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:9:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r1 3. 事务操作对于事务操作，我们可以使用sqlx中提供的db.Beginx()和tx.Exec()方法。示例代码如下： package main import ( \"errors\" \"fmt\" ) // 事务 func TransactionSqlxDemo() (err error) { tx, err := DbSqlx.Beginx() // 开启事务 if err != nil { fmt.Printf(\"begin trans failed, err:%v\\n\", err) return err } defer func() { if p := recover(); p != nil { tx.Rollback() panic(p) // re-throw panic after Rollback } else if err != nil { fmt.Println(\"rollback\") tx.Rollback() // err is non-nil; don't change it } else { err = tx.Commit() // err is nil; if Commit returns error update err fmt.Println(\"commit\") } }() sqlStr1 := \"Update user set age=20 where id=?\" rs, err := tx.Exec(sqlStr1, 1) if err != nil { return err } n, err := rs.RowsAffected() if err != nil { return err } if n != 1 { return errors.New(\"exec sqlStr1 failed\") } sqlStr2 := \"Update user set age=50 where i=?\" rs, err = tx.Exec(sqlStr2, 5) if err != nil { return err } n, err = rs.RowsAffected() if err != nil { return err } if n != 1 { return errors.New(\"exec sqlStr1 failed\") } return err } func main() { // sqlx使用 err := InitDbSqlx() if err != nil { fmt.Printf(\"init db failed, err: %v\\n\", err) return } fmt.Printf(\"init db success db%v\\n\", DbSqlx) TransactionSqlxDemo() } 三. sqlx.In sqlx.In是sqlx提供的一个非常方便的函数。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:10:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r1 0. 表结构为了方便演示插入数据操作，这里创建一个user表，表结构如下： CREATE TABLE `user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT '', `age` INT(11) DEFAULT '0', PRIMARY KEY(`id`) )ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:11:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r2 0. 结构体定义一个user结构体，字段通过tag与数据库中user表的列一致。 type User struct { Name string `db:\"name\"` Age int `db:\"age\"` } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:12:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r3 1. sqlx.In的批量插入示例","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:13:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r3.1 1.2 bindvars（绑定变量）查询占位符?在内部称为bindvars（查询占位符）,它非常重要。你应该始终使用它们向数据库发送值，因为它们可以防止SQL注入攻击。database/sql不尝试对查询文本进行任何验证；它与编码的参数一起按原样发送到服务器。除非驱动程序实现一个特殊的接口，否则在执行之前，查询是在服务器上准备的。因此bindvars是特定于数据库的: MySQL中使用? PostgreSQL使用枚举的$1、$2等bindvar语法 SQLite中?和$1的语法都支持 Oracle中使用:name的语法 bindvars的一个常见误解是，它们用来在sql语句中插入值。它们其实仅用于参数化，不允许更改SQL语句的结构。例如，使用bindvars尝试参数化列或表名将不起作用： // ？不能用来插入表名（做SQL语句中表名的占位符） db.Query(\"SELECT * FROM ?\", \"mytable\") // ？也不能用来插入列名（做SQL语句中列名的占位符） db.Query(\"SELECT ?, ? FROM people\", \"name\", \"location\") ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:13:1","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r3.2 1.3 自己拼接语句实现批量插入比较笨，但是很好理解。就是有多少个User就拼接多少个(?, ?)。 // BatchInsertUsers 自行构造批量插入的语句 func BatchInsertUsersSqlxDemo(users []*User) error { // 存放 (?, ?) 的slice valueStrings := make([]string, 0, len(users)) // 存放values的slice valueArgs := make([]interface{}, 0, len(users)*2) // 遍历users准备相关数据 for _, u := range users { // 此处占位符要与插入值的个数对应 valueStrings = append(valueStrings, \"(?, ?)\") valueArgs = append(valueArgs, u.Name) valueArgs = append(valueArgs, u.Age) } // 自行拼接要执行的具体语句 stmt := fmt.Sprintf(\"INSERT INTO user (name, age) VALUES %s\",strings.Join(valueStrings, \",\")) fmt.Println(\"手动拼接sql语句sql:\", stmt, valueArgs) // 手动拼接sql _, err := DbSqlx.Exec(stmt, valueArgs...) return err } package main import \"fmt\" func main() { u1 := User{Name: \"RandySun1\", Age: 18} u2 := User{Name: \"RandySun2\", Age: 28} u3 := User{Name: \"RandySun3\", Age: 38} // //// 方法1 users := []*User{\u0026u1, \u0026u2, \u0026u3} err = BatchInsertUsersSqlxDemo(users) if err != nil { fmt.Printf(\"BatchInsertUsers failed, err:%v\\n\", err) } } 手动拼接sql语句sql: INSERT INTO user (name, age) VALUES (?, ?),(?, ?),(?, ?) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:13:2","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r3.3 1.4 使用sqlx.In实现批量插入前提是需要我们的结构体实现driver.Valuer接口： // BatchInsertInUsersSqlxDemo 使用sqlx.In帮我们拼接语句和参数, 注意传入的参数是[]interface{} func (u User) Value() (driver.Value, error) { return []interface{}{u.Name, u.Age}, nil } 使用sqlx.In实现批量插入代码如下： package main import \"fmt\" // BatchInsertInUsersSqlxDemo 使用sqlx.In帮我们拼接语句和参数, 注意传入的参数是[]interface{} func BatchInsertInUsersSqlxDemo(users []interface{}) error { query, args, _ := sqlx.In( \"INSERT INTO user (name, age) VALUES (?), (?), (?)\", // 有几个数据，就要有几个占位符 users..., // 如果arg实现了 driver.Valuer, sqlx.In 会通过调用 Value()来展开它 ) fmt.Println(query) // 查看生成的querystring fmt.Println(args) // 查看生成的args _, err := DbSqlx.Exec(query, args...) return err } func main() { u1 := User{Name: \"RandySun1\", Age: 18} u2 := User{Name: \"RandySun2\", Age: 28} u3 := User{Name: \"RandySun3\", Age: 38} // 方法2 users2 := []interface{}{u1, u2, u3} err = BatchInsertInUsersSqlxDemo(users2) if err != nil { fmt.Printf(\"BatchInsertUsers2 failed, err:%v\\n\", err) } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:13:3","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r3.4 1.5 使用NamedExec实现批量插入注意 ：该功能需1.3.1版本以上，并且1.3.1版本目前还有点问题，sql语句最后不能有空格和; 使用NamedExec实现批量插入的代码如下： package main import \"fmt\" // BatchInsertNamedExecUsersSqlxDemo 使用NamedExec实现批量插入 func BatchInsertNamedExecUsersSqlxDemo(users []*User) error { _, err := DbSqlx.NamedExec(\"INSERT INTO user (name, age) VALUES (:name, :age)\", users) return err } func main() { u1 := User{Name: \"RandySun1\", Age: 18} u2 := User{Name: \"RandySun2\", Age: 28} u3 := User{Name: \"RandySun3\", Age: 38} // 方法3 users3 := []*User{\u0026u1, \u0026u2, \u0026u3} err = BatchInsertNamedExecUsersSqlxDemo(users3) if err != nil { fmt.Printf(\"BatchInsertUsers3 failed, err:%v\\n\", err) } } 把上面三种方法综合起来试一下： func main() { err := initDB() if err != nil { panic(err) } defer DB.Close() // 方法1 users := []*User{\u0026u1, \u0026u2, \u0026u3} err = BatchInsertUsersSqlxDemo(users) if err != nil { fmt.Printf(\"BatchInsertUsers failed, err:%v\\n\", err) } // 方法2 users2 := []interface{}{u1, u2, u3} err = BatchInsertInUsersSqlxDemo(users2) if err != nil { fmt.Printf(\"BatchInsertUsers2 failed, err:%v\\n\", err) } // 方法3 users3 := []*User{\u0026u1, \u0026u2, \u0026u3} err = BatchInsertNamedExecUsersSqlxDemo(users3) if err != nil { fmt.Printf(\"BatchInsertUsers3 failed, err:%v\\n\", err) } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:13:4","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r4 2. sqlx.In的查询示例关于sqlx.In这里再补充一个用法，在sqlx查询语句中实现In查询和FIND_IN_SET函数。即实现SELECT * FROM user WHERE id in (3, 2, 1);和SELECT * FROM user WHERE id in (3, 2, 1) ORDER BY FIND_IN_SET(id, '3,2,1');。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:14:0","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r4.1 2.1 in查询查询id在给定id集合中的数据。 package main import ( \"fmt\" \"github.com/jmoiron/sqlx\" \"strings\" ) // QueryByIds 根据给定ID查询 func QueryByIds(ids []int) (users []User, err error) { // 动态填充id query, args, err := sqlx.In(\"SELECT name, age FROM user WHERE id IN (?)\", ids) if err != nil { return } // sqlx.In 返回带 `?` bindvar的查询语句, 我们使用Rebind()重新绑定它 fmt.Println(query, args, err) query = DbSqlx.Rebind(query) // SELECT name, age FROM user WHERE id IN (?, ?, ?) fmt.Println(query) err = DbSqlx.Select(\u0026users, query, args...) return } func main() { // sqlx使用 err := InitDbSqlx() if err != nil { fmt.Printf(\"init db failed, err: %v\\n\", err) return } fmt.Printf(\"init db success db%v\\n\", DbSqlx) //init db success db\u0026{0xc000020ea0 mysql false 0xc00007ea50} Ids := []int{3,1,2} userList, err := QueryByIds(Ids) fmt.Println(userList) // [{1 18 Randy} {2 30 Jack} {3 200 Barry}] } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:14:1","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":"\r4.2 2.2 in查询和FIND_IN_SET函数查询id在给定id集合的数据并维持给定id集合的顺序。 package main import ( \"fmt\" \"github.com/jmoiron/sqlx\" \"strings\" ) // QueryAndOrderByIds 按照指定id查询并维护顺序 func QueryAndOrderByIds(ids []int) (users []User, err error) { // 动态填充id strIDs := make([]string, 0, len(ids)) for _, id := range ids { strIDs = append(strIDs, fmt.Sprintf(\"%d\", id)) } fmt.Println(strIDs) query, args, err := sqlx.In(\"SELECT id, name, age FROM user WHERE id IN (?) ORDER BY FIND_IN_SET(id, ?)\", ids, strings.Join(strIDs, \",\")) if err != nil { return } fmt.Println(query, args, err) // sqlx.In 返回带 `?` bindvar的查询语句, 我们使用Rebind()重新绑定它 query = DbSqlx.Rebind(query) err = DbSqlx.Select(\u0026users, query, args...) return } func main() { // sqlx使用 err := InitDbSqlx() if err != nil { fmt.Printf(\"init db failed, err: %v\\n\", err) return } fmt.Printf(\"init db success db%v\\n\", DbSqlx) Ids := []int{3,1,2} userList, err := QueryAndOrderByIds(Ids) fmt.Println(userList) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180204/:14:2","tags":null,"title":"8-2.sqlx的使用","uri":"/lang/go/go_advanced/20250515180204/"},{"categories":null,"content":" 互斥锁（Mutex）: 当一个goroutine获得互斥锁后，其他goroutine无法在使用被上锁的资源，只能等待资源释放 读写锁 (RWMutex): RWMutex是单写多读锁，该锁可以加多个读锁或者一个写锁 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180200/:0:0","tags":null,"title":"8-1.Go中的Mutex和RWMutex","uri":"/lang/go/go_advanced/20250515180200/"},{"categories":null,"content":"\r1 Mutex: 互斥锁 结构 type Mutex struct { state int32 // 表示互斥锁的状态，比如是否被锁定等。 sema uint32 // sema表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。 } 特点 Mutex 是一个互斥锁，可以创建为其他结构体的字段；零值为解锁状态。Mutex 类型的锁和线程无关，可以由不同的线程加锁和解锁。 锁定状态值为1，未锁定状态锁未0 Lock()加锁、Unlock解锁 当一个goroutine获得互斥锁后，其他goroutine无法在使用被上锁的资源，只能等待资源释放 不可对同一资源重复使用Lock()，必须等待Unlock()后才可再次Lock()，否则将会导致死锁 package main import ( \"fmt\" \"sync\" ) type UserInfo struct { Name string Age int sync.Mutex } func (userInfo *UserInfo) updateUserInfo(name string, age int) { userInfo.Lock() defer userInfo.Unlock() userInfo.Name = name userInfo.Age = age } func main() { userInfo := UserInfo{Name: \"text1\", Age: 20} fmt.Println(userInfo) userInfo.Lock() fmt.Println(userInfo) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180200/:1:0","tags":null,"title":"8-1.Go中的Mutex和RWMutex","uri":"/lang/go/go_advanced/20250515180200/"},{"categories":null,"content":"\r2 RWMutex：读写锁 写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞 写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞 读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞 读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁 结构 type RWMutex struct { w Mutex // held if there are pending writers writerSem uint32 // semaphore for writers to wait for completing readers readerSem uint32 // semaphore for readers to wait for completing writers readerCount int32 // number of pending readers readerWait int32 // number of departing readers } 方法 RLock()：读锁定 RUnlock()：解除读锁定 Lock(): 写锁定，与Mutex完全一致 Unlock()：解除写锁定，与Mutex完全一致 特点 RWMutex是单写多读锁，该锁可以加多个读锁或者一个写锁 读锁占用的情况会阻止写，不会阻止读，多个goroutine可以同时获取读锁 写锁会阻止其他gorotine不论读或者写进来，整个锁由写锁goroutine占用 如果在加写锁之前已经有其他的读锁和写锁，则Lock()会阻塞直到该锁可用，为确保该锁可用，已经阻塞的Lock()调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定 RLock()加读锁时，如果存在写锁,则无法加读；当只有读锁或者没有锁时，可以加读锁，读锁可以加载多个 Rulock()解读锁，RUnlock撤销RLock()调用，对于其他同时存在的读锁则没有效果 在没有读锁的情况下调用Runlock()会导致panic错误 使用 type UserInfo struct { Name string sync.RWMutex } func main() { userInfo := UserInfo{Name: \"test1\"} go userInfo.userRLock() go userInfo.userRLock() go userInfo.userRLock() go userInfo.userRLock() go userInfo.userLock() time.Sleep(time.Second*5) } func (userInfo *UserInfo) userLock() { defer userInfo.Unlock() userInfo.Lock() fmt.Println(\"lock\") fmt.Println(\"lock\") fmt.Println(\"lock\") } func (userInfo *UserInfo) userRLock() { defer userInfo.RUnlock() userInfo.RLock() time.Sleep(time.Second) fmt.Println(\"Rlock\") fmt.Println(\"Rlock\") fmt.Println(\"Rlock\") } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180200/:2:0","tags":null,"title":"8-1.Go中的Mutex和RWMutex","uri":"/lang/go/go_advanced/20250515180200/"},{"categories":null,"content":"\r1 panic和recover使用场景","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:1:0","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r1.1 1. panic 程序报错退出,返回码是os.exit(0) 对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。 速错推荐panic ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:1:1","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r1.2 2. recover 从 panic 恢复 tip场景: 别人写的panic 但是不符合你的场景, 你想恢复 ,使用recover func main() { // defer 先进后出 defer func() { data := recover() if data!=nil{ fmt.Println(\"recover\",data) // recover 34 } }() panic(\"34\") // 以下代码不再执行 fmt.Println(\"不执行\") } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:1:2","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r2 Error vs Exception Panic使用场景 对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。 Golang error 处理方式的优点 简单 考虑失败，而不是成功（plan for failure, not success） 没有隐藏的控制流 完全交给你来控制 error Error are values ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:2:0","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r3 Error Type (处理错误的方式)","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:3:0","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r3.1 1. Sentinel Error 预定义的特定错误，我们叫为 sentinel error，这个名字来源于计算机编程中使用一个特定值来表示不可能进行进一步处理的做法。所以对于 Go，我们使用特定的值来表示错误。 if err == ErrSomething { … } 类似的 io.EOF，更底层的 syscall.ENOENT。 结论: 使用 sentinel 值是最不灵活的错误处理策略，因为调用方必须使用 == 将结果与预先声明的值进行比较。当您想要提供更多的上下文时，这就出现了一个问题，因为返回一个不同的错误将破坏相等性检查。 不依赖检查 error.Error 的输出。不应该依赖检测 error.Error 的输出，Error 方法存在于 error 接口主要用于方便程序员使用，但不是程序（编写测试可能会依赖这个返回）。这个输出的字符串用于记录日志、输出到 stdout 等。 尽可能避免 sentinel errors。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:3:1","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r3.2 2. Error types Error type 是实现了 error 接口的自定义类型。例如 MyError 类型记录了文件和行号以展示发生了什么。 结论: 尽量避免使用 error types，虽然错误类型比 sentinel errors 更好，因为它们可以捕获关于出错的更多上下文，但是 error types 共享 error values 许多相同的问题。 因此，我的建议是避免错误类型，或者至少避免将它们作为公共 API 的一部分。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:3:2","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r3.3 3. Opaque errors (推荐使用!!) 这是最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。 这种风格称为不透明错误处理，因为虽然您知道发生了错误，但您没有能力看到错误的内部。作为调用者，关于操作的结果，您所知道的就是它起作用了，或者没有起作用（成功还是失败）。 这就是不透明错误处理的全部功能–只需返回错误而不假设其内容。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:3:3","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r4 Handling Error 读取文件多少行 func CountLines(r io.Reader) (int,error){ sc := bufio.NewScanner(r) lines := 0 for sc.Scan(){ lines++ } return lines , sc.Err() } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:4:0","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r5 Errors err := errors.New(string) //创建errors err := errors.Errorf(string) //创建errors并记录堆栈信息, 通过’%v’获取 err2 := fmt.Errorf(“我错了%w”, err) // 包装error err0 := errors.Unwrap(err2) //解包装error resBool := errors.Is(err2,err0) // 判断是不是同一个error errors.As(err2,\u0026err3) //类型转为特定的error ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:5:0","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r6 Warp Error(!!!) 使用 pkg/errors 包 我们经常发现类似的代码，在错误处理中，带了两个任务: 记录日志并且再次返回错误。 应该只处理一次错误。处理错误意味着检查错误值，并做出单一决策。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:6:0","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r6.1 1. pkg/errors package main import ( \"fmt\" \"github.com/pkg/errors\" ) func main() { r := errors.New(\"我错了\") r2 := errors.Wrapf(r,\"我真的错了\") fmt.Println(r2.Error()) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:6:1","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r6.2 2. pkg/errors 使用技巧 在你的应用代码中，使用 errors.New 或者 erros.Errorf 返回错误。其中erros.Errorf 可以记录堆栈信息. import ( \"fmt\" \"github.com/pkg/errors\" ) func main() { r := errors.New(\"我错了\") //r := erros.Errorf(\"我错了\") r2 := errors.Wrapf(r,\"我真的错了\") fmt.Println(r2.Error()) // 我真的错了: 我错了 } 如果调用其他包内的函数，通常简单的直接返回。 直接返回错误，而不是每个错误产生的地方到处打日志。 在程序的顶部或者是工作的 goroutine 顶部（请求入口），使用 %+v 把堆栈详情记录。 import ( \"fmt\" \"github.com/pkg/errors\" ) func main() { r := errors.Errorf(\"我错了\") r2 := errors.Wrapf(r,\"我真的错了\") fmt.Printf(\"%v\",r2.Error()) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:6:2","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r7 处理error的正确姿势 7.0.0.1 失败的原因只有一个时，不使用error案例： func (self *AgentContext) CheckHostType(host_type string) error { switch host_type { case \"virtual_machine\": return nil case \"bare_metal\": return nil } return errors.New(\"CheckHostType ERROR:\" + host_type) } 重构一下代码： func (self *AgentContext) IsValidHostType(hostType string) bool { return hostType == \"virtual_machine\" || hostType == \"bare_metal\" } 说明：大多数情况，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息，这时的返回值类型不再是简单的bool，而是error。 7.0.0.2 没有失败不使用error // 错误示例 func (self *CniParam) setTenantId() error { self.TenantId = self.PodNs return nil } 7.0.0.3 error应放在返回值类型列表的最后 7.0.0.4 错误值统一定义很多人写代码时，到处return errors.New(value)，而错误value在表达同一个含义时也可能形式不同，比如“记录不存在”的错误value可能为： - \"record is not existed.\" - \"record is not exist!\" - \"###record is not existed！！！\" 这使得相同的错误value撒在一大片代码里，当上层函数要对特定错误value进行统一处理时，需要漫游所有下层代码，以保证错误value统一，不幸的是有时会有漏网之鱼，而且这种方式严重阻碍了错误value的重构。 于是，我们可以参考C/C++的错误码定义文件，在Golang的每个包中增加一个错误对象定义文件，如下所示： var ERR_EOF = errors.New(\"EOF\") var ERR_CLOSED_PIPE = errors.New(\"io: read/write on closed pipe\") var ERR_NO_PROGRESS = errors.New(\"multiple Read calls return no data or error\") var ERR_SHORT_BUFFER = errors.New(\"short buffer\") var ERR_SHORT_WRITE = errors.New(\"short write\") var ERR_UNEXPECTED_EOF = errors.New(\"unexpected EOF\") 7.0.0.5 错误逐层传递时，层层都加日志层层都加日志非常方便故障定位。不过存在争议! 7.0.0.6 当尝试几次可以避免失败时，不要立即返回错误 7.0.0.7 当上层函数不关心错误时，建议不返回error对于一些资源清理相关的函数（destroy/delete/clear），如果子函数出错，打印日志即可，而无需将错误进一步反馈到上层函数，因为一般情况下，上层函数是不关心执行结果的，或者即使关心也无能为力，于是我们建议将相关函数设计为不返回error。 7.0.0.8 当发生错误时，不忽略有用的返回值通常，当函数返回non-nil的error时，其他的返回值是未定义的(undefined)，这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，应该将读取到的字符串和错误信息一起打印出来。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:7:0","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r8 处理异常的正确姿势 8.0.0.9 在程序开发阶段，坚持速错速错推荐panic 8.0.0.10 在程序部署后，应恢复异常避免程序终止 8.0.0.11 对于不应该出现的分支，使用异常处理 panic switch s := suit(drawCard()); s { case \"Spades\": // ... case \"Hearts\": // ... case \"Diamonds\": // ... case \"Clubs\": // ... default: panic(fmt.Sprintf(\"invalid suit %v\", s)) } 8.0.0.12 针对入参不应该有问题的函数，使用panic设计 func MustCompile(str string) *Regexp { regexp, error := Compile(str) if error != nil { panic(`regexp: Compile(` + quote(str) + `): ` + error.Error()) } return regexp } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180156/:8:0","tags":null,"title":"7.Go异常处理","uri":"/lang/go/go_advanced/20250515180156/"},{"categories":null,"content":"\r1 高性能日志库zap doc: https://github.com/uber-go/zap 安装和基本使用 // go get -u go.uber.org/zap package main import ( \"go.uber.org/zap\" ) func main() { logger, _ := zap.NewProduction() defer logger.Sync() // flushes buffer, if any url := \"https://imooc.com\" sugar := logger.Sugar() sugar.Infow(\"failed to fetch URL\", // Structured context as loosely typed key-value pairs. \"url\", url, \"attempt\", 3, ) sugar.Infof(\"Failed to fetch URL: %s\", url) } Zap提供了两种类型的日志记录器—Sugared Logger和Logger。 在性能很好但不是很关键的上下文中，使用SugaredLogger。它比其他结构化日志记录包快4-10倍，并且支持结构化和printf风格的日志记录。 在每一微秒和每一次内存分配都很重要的上下文中，使用Logger。它甚至比SugaredLogger更快，内存分配次数也更少，但它只支持强类型的结构化日志记录 写入日志文件 package main import ( \"go.uber.org/zap\" \"time\" ) func NewLogger() (*zap.Logger, error) { cfg := zap.NewProductionConfig() cfg.OutputPaths = []string{ \"./myproject.log\", // 输出到文件 \"stdout\",// 输出到控制台 \"stderr\",//输出到控制台err } return cfg.Build() } func main() { //logger, _ := zap.NewProduction() logger, err := NewLogger() if err != nil { panic(err) //panic(\"初始化logger失败\") } su := logger.Sugar() defer su.Sync() url := \"https://imooc.com\" su.Info(\"failed to fetch URL\", // Structured context as strongly typed Field values. zap.String(\"url\", url), zap.Int(\"attempt\", 3), zap.Duration(\"backoff\", time.Second), ) } 高级用法 /* 1.S()可以获取一个全局的 sugar,可以让我们已设置一个全局的1oger, 而且S()是安全的 2.日志是分级别的, debug,info,Warn, error, fetal 3.zap.S()函数和zap.L()函数很有用 -- S()= sugure --L() = logger() */ logger, _ := zap.NewDevelopment() zap.ReplaceGlobals(logger) // 初始化router Router := initialize.Routers() zap.S().Info(\"启动服务端 %d\", port) zap.S().Panic(\"启动失败:\", err.Error()) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180153/:1:0","tags":null,"title":"6-2.高性能日志库zap","uri":"/lang/go/go_advanced/20250515180153/"},{"categories":null,"content":"\r2 案例1-gin package main import ( \"net\" \"net/http\" \"net/http/httputil\" \"os\" \"runtime/debug\" \"strings\" \"time\" \"github.com/gin-gonic/gin\" \"github.com/natefinch/lumberjack\" \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\" ) var logger *zap.Logger var sugarLogger *zap.SugaredLogger //func main() { // InitLogger() // defer logger.Sync() // // for i:=0;i\u003c10000;i++{ // logger.Info(\"test for log rotate...\") // } // simpleHttpGet(\"www.sogo.com\") // simpleHttpGet(\"http://www.sogo.com\") //} func main() { InitLogger() //r := gin.Default() r := gin.New() // 这样每次请求都会先走日志函数，先记录路径和请求参数，再调用Next函数，等其他函数执行完再去记录全部的信息 r.Use(GinLogger(logger), GinRecovery(logger, true)) r.GET(\"/hello\", func(c *gin.Context) { c.String(http.StatusOK, \"hello q1mi!\") logger.Info(\"测试日志\") }) r.Run() } func InitLogger() { writeSyncer := getLogWriter() encoder := getEncoder() core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel) logger = zap.New(core, zap.AddCaller()) sugarLogger = logger.Sugar() } func getEncoder() zapcore.Encoder { //return zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()) encoderConfig := zapcore.EncoderConfig{ TimeKey: \"ts\", LevelKey: \"level\", NameKey: \"logger\", CallerKey: \"caller\", MessageKey: \"msg\", StacktraceKey: \"stacktrace\", LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.ISO8601TimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } return zapcore.NewConsoleEncoder(encoderConfig) } //func getLogWriter() zapcore.WriteSyncer { // file, _ := os.OpenFile(\"./test.log\", os.O_CREATE|os.O_APPEND|os.O_RDWR, 0744) // return zapcore.AddSync(file) //} func getLogWriter() zapcore.WriteSyncer { lumberJackLogger := \u0026lumberjack.Logger{ Filename: \"./test.log\", // 这里定义保存日志的位置 MaxSize: 1, // 在进行切割之前，日志文件的最大大小（以MB为单位） MaxBackups: 5, // 保留旧文件的最大个数 MaxAge: 30, // 保留旧文件的最大天数 Compress: false, // 是否压缩/归档旧文件 } return zapcore.AddSync(lumberJackLogger) } func simpleHttpGet(url string) { resp, err := http.Get(url) if err != nil { sugarLogger.Error( \"Error fetching url..\", zap.String(\"url\", url), zap.Error(err)) } else { sugarLogger.Info(\"Success..\", zap.String(\"statusCode\", resp.Status), zap.String(\"url\", url)) resp.Body.Close() } } // GinLogger 接收gin框架默认的日志 func GinLogger(logger *zap.Logger) gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() path := c.Request.URL.Path query := c.Request.URL.RawQuery c.Next() cost := time.Since(start) logger.Info(path, zap.Int(\"status\", c.Writer.Status()), zap.String(\"method\", c.Request.Method), zap.String(\"path\", path), zap.String(\"query\", query), zap.String(\"ip\", c.ClientIP()), zap.String(\"user-agent\", c.Request.UserAgent()), zap.String(\"errors\", c.Errors.ByType(gin.ErrorTypePrivate).String()), zap.Duration(\"cost\", cost), ) } } // GinRecovery recover掉项目可能出现的panic func GinRecovery(logger *zap.Logger, stack bool) gin.HandlerFunc { return func(c *gin.Context) { defer func() { if err := recover(); err != nil { // Check for a broken connection, as it is not really a // condition that warrants a panic stack trace. var brokenPipe bool if ne, ok := err.(*net.OpError); ok { if se, ok := ne.Err.(*os.SyscallError); ok { if strings.Contains(strings.ToLower(se.Error()), \"broken pipe\") || strings.Contains(strings.ToLower(se.Error()), \"connection reset by peer\") { brokenPipe = true } } } httpRequest, _ := httputil.DumpRequest(c.Request, false) if brokenPipe { logger.Error(c.Request.URL.Path, zap.Any(\"error\", err), zap.String(\"request\", string(httpRequest)), ) // If the connection is dead, we can't write a status to it. c.Error(err.(error)) // nolint: errcheck c.Abort() return } if stack { logger.Error(\"[Recovery from panic]\", zap.Any(\"error\", err), zap.String(\"request\", string(httpRequest)), zap.String(\"stack\", string(debug.Stack())), ) } else { logger.Error(\"[Recovery from panic]\", zap.Any(\"error\", err), zap.String(\"request\", string(httpRequest)), ) } c.AbortWithStatus(http.StatusInternalServerError) } }() c.Next() } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180153/:2:0","tags":null,"title":"6-2.高性能日志库zap","uri":"/lang/go/go_advanced/20250515180153/"},{"categories":null,"content":"\r3 案例2 logcore /** * 获取日志 * filePath 日志文件路径 * level 日志级别 * maxSize 每个日志文件保存的最大尺寸 单位：M * maxBackups 日志文件最多保存多少个备份 * maxAge 文件最多保存多少天 * compress 是否压缩 * serviceName 服务名 */ func NewLogger(filePath string, level zapcore.Level, maxSize int, maxBackups int, maxAge int, compress bool, serviceName string) *zap.Logger { core := newCore(filePath, level, maxSize, maxBackups, maxAge, compress) return zap.New(core, zap.AddCaller(), zap.Development(), zap.Fields(zap.String(\"serviceName\", serviceName))) } /** * zapcore构造 */ func newCore(filePath string, level zapcore.Level, maxSize int, maxBackups int, maxAge int, compress bool) zapcore.Core { //日志文件路径配置2 hook := lumberjack.Logger{ Filename: filePath, // 日志文件路径 MaxSize: maxSize, // 每个日志文件保存的最大尺寸 单位：M MaxBackups: maxBackups, // 日志文件最多保存多少个备份 MaxAge: maxAge, // 文件最多保存多少天 Compress: compress, // 是否压缩 } // 设置日志级别 atomicLevel := zap.NewAtomicLevel() atomicLevel.SetLevel(level) //公用编码器 encoderConfig := zapcore.EncoderConfig{ TimeKey: \"time\", LevelKey: \"level\", NameKey: \"logger\", CallerKey: \"linenum\", MessageKey: \"msg\", StacktraceKey: \"stacktrace\", LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, // 小写编码器 EncodeTime: zapcore.ISO8601TimeEncoder, // ISO8601 UTC 时间格式 EncodeDuration: zapcore.SecondsDurationEncoder, // EncodeCaller: zapcore.FullCallerEncoder, // 全路径编码器 EncodeName: zapcore.FullNameEncoder, } return zapcore.NewCore( zapcore.NewJSONEncoder(encoderConfig), // 编码器配置 zapcore.NewMultiWriteSyncer(zapcore.AddSync(os.Stdout), zapcore.AddSync(\u0026hook)), // 打印到控制台和文件 atomicLevel, // 日志级别 ) } log var MainLogger *zap.Logger var GatewayLogger *zap.Logger func init() { MainLogger = NewLogger(\"./logs/main.log\", zapcore.InfoLevel, 128, 30, 7, true, \"Main\") GatewayLogger = NewLogger(\"./logs/gateway.log\", zapcore.DebugLevel, 128, 30, 7, true, \"Gateway\") } app func main() { fmt.Println(\"init main\") log.MainLogger.Debug(\"hello main Debug\") log.MainLogger.Info(\"hello main Info\") log.GatewayLogger.Debug(\"Hi Gateway Im Debug\") log.GatewayLogger.Info(\"Hi Gateway Im Info\") } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180153/:3:0","tags":null,"title":"6-2.高性能日志库zap","uri":"/lang/go/go_advanced/20250515180153/"},{"categories":null,"content":"\r线上线下配置隔离 在自己本地创建一个环境变量 ENV_DEBUG=1 Go配置管理—Viper 安装go get github.com/spf13/viper ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:0:0","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r1 什么是Viper？Viper是适用于Go应用程序（包括Twelve-Factor App）的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。它支持以下特性： 设置默认值 从JSON、TOML、YAML、HCL、envfile和Java properties格式的配置文件读取配置信息 实时监控和重新读取配置文件（可选） 从环境变量中读取 从远程配置系统（etcd或Consul）读取并监控配置变化 从命令行参数读取配置 从buffer读取配置 显式配置值 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:1:0","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r2 为什么选择Viper?在构建现代应用程序时，你无需担心配置文件格式；你想要专注于构建出色的软件。Viper的出现就是为了在这方面帮助你的。 Viper能够为你执行下列操作： 查找、加载和反序列化JSON、TOML、YAML、HCL、INI、envfile和Java properties格式的配置文件。 提供一种机制为你的不同配置选项设置默认值。 提供一种机制来通过命令行参数覆盖指定选项的值。 提供别名系统，以便在不破坏现有代码的情况下轻松重命名参数。 当用户提供了与默认值相同的命令行或配置文件时，可以很容易地分辨出它们之间的区别。 Viper会按照下面的优先级。每个项目的优先级都高于它下面的项目: 显示调用Set设置值 命令行参数（flag） 环境变量 配置文件 key/value存储 默认值 重要： 目前Viper配置的键（Key）是大小写不敏感的。目前正在讨论是否将这一选项设为可选。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:2:0","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3 把值存入Viper","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:0","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.1 建立默认值一个好的配置系统应该支持默认值。键不需要默认值，但如果没有通过配置文件、环境变量、远程配置或命令行标志（flag）设置键，则默认值非常有用。 例如： viper.SetDefault(\"ContentDir\", \"content\") viper.SetDefault(\"LayoutDir\", \"layouts\") viper.SetDefault(\"Taxonomies\", map[string]string{\"tag\": \"tags\", \"category\": \"categories\"}) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:1","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.2 读取配置文件Viper需要最少知道在哪里查找配置文件的配置。Viper支持JSON、TOML、YAML、HCL、envfile和Java properties格式的配置文件。Viper可以搜索多个路径，但目前单个Viper实例只支持单个配置文件。Viper不默认任何配置搜索路径，将默认决策留给应用程序。 下面是一个如何使用Viper搜索和读取配置文件的示例。不需要任何特定的路径，但是至少应该提供一个配置文件预期出现的路径。 viper.SetConfigFile(\"./config.yaml\") // 指定配置文件路径 viper.SetConfigName(\"config\") // 配置文件名称(无扩展名) viper.SetConfigType(\"yaml\") // 如果配置文件的名称中没有扩展名，则需要配置此项 viper.AddConfigPath(\"/etc/appname/\") // 查找配置文件所在的路径 viper.AddConfigPath(\"$HOME/.appname\") // 多次调用以添加多个搜索路径 viper.AddConfigPath(\".\") // 还可以在工作目录中查找配置 err := viper.ReadInConfig() // 查找并读取配置文件 if err != nil { // 处理读取配置文件的错误 panic(fmt.Errorf(\"Fatal error config file: %s \\n\", err)) } 在加载配置文件出错时，你可以像下面这样处理找不到配置文件的特定情况： if err := viper.ReadInConfig(); err != nil { if _, ok := err.(viper.ConfigFileNotFoundError); ok { // 配置文件未找到错误；如果需要可以忽略 } else { // 配置文件被找到，但产生了另外的错误 } } // 配置文件找到并成功解析 注意[自1.6起]： 你也可以有不带扩展名的文件，并以编程方式指定其格式。对于位于用户$HOME目录中的配置文件没有任何扩展名，如.bashrc。 这里补充两个问题供读者解答并自行验证 当你使用如下方式读取配置时，viper会从./conf目录下查找任何以config为文件名的配置文件，如果同时存在./conf/config.json和./conf/config.yaml两个配置文件的话，viper会从哪个配置文件加载配置呢？ viper.SetConfigName(\"config\") viper.AddConfigPath(\"./conf\") 在上面两个语句下搭配使用viper.SetConfigType(\"yaml\")指定配置文件类型可以实现预期的效果吗？ ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:2","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.3 写入配置文件从配置文件中读取配置文件是有用的，但是有时你想要存储在运行时所做的所有修改。为此，可以使用下面一组命令，每个命令都有自己的用途: WriteConfig - 将当前的viper配置写入预定义的路径并覆盖（如果存在的话）。如果没有预定义的路径，则报错。 SafeWriteConfig - 将当前的viper配置写入预定义的路径。如果没有预定义的路径，则报错。如果存在，将不会覆盖当前的配置文件。 WriteConfigAs - 将当前的viper配置写入给定的文件路径。将覆盖给定的文件(如果它存在的话)。 SafeWriteConfigAs - 将当前的viper配置写入给定的文件路径。不会覆盖给定的文件(如果它存在的话)。 根据经验，标记为safe的所有方法都不会覆盖任何文件，而是直接创建（如果不存在），而默认行为是创建或截断。 一个小示例： viper.WriteConfig() // 将当前配置写入“viper.AddConfigPath()”和“viper.SetConfigName”设置的预定义路径 viper.SafeWriteConfig() viper.WriteConfigAs(\"/path/to/my/.config\") viper.SafeWriteConfigAs(\"/path/to/my/.config\") // 因为该配置文件写入过，所以会报错 viper.SafeWriteConfigAs(\"/path/to/my/.other_config\") ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:3","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.4 监控并重新读取配置文件Viper支持在运行时实时读取配置文件的功能。 需要重新启动服务器以使配置生效的日子已经一去不复返了，viper驱动的应用程序可以在运行时读取配置文件的更新，而不会错过任何消息。 只需告诉viper实例watchConfig。可选地，你可以为Viper提供一个回调函数，以便在每次发生更改时运行。 确保在调用WatchConfig()之前添加了所有的配置路径。 viper.WatchConfig() viper.OnConfigChange(func(e fsnotify.Event) { // 配置文件发生变更之后会调用的回调函数 fmt.Println(\"Config file changed:\", e.Name) }) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:4","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.5 从io.Reader读取配置Viper预先定义了许多配置源，如文件、环境变量、标志和远程K/V存储，但你不受其约束。你还可以实现自己所需的配置源并将其提供给viper。 viper.SetConfigType(\"yaml\") // 或者 viper.SetConfigType(\"YAML\") // 任何需要将此配置添加到程序中的方法。 var yamlExample = []byte(` Hacker: true name: steve hobbies: - skateboarding - snowboarding - go clothing: jacket: leather trousers: denim age: 35 eyes : brown beard: true `) viper.ReadConfig(bytes.NewBuffer(yamlExample)) viper.Get(\"name\") // 这里会得到 \"steve\" ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:5","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.6 覆盖设置这些可能来自命令行标志，也可能来自你自己的应用程序逻辑。 viper.Set(\"Verbose\", true) viper.Set(\"LogFile\", LogFile) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:6","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.7 注册和使用别名别名允许多个键引用单个值 viper.RegisterAlias(\"loud\", \"Verbose\") // 注册别名（此处loud和Verbose建立了别名） viper.Set(\"verbose\", true) // 结果与下一行相同 viper.Set(\"loud\", true) // 结果与前一行相同 viper.GetBool(\"loud\") // true viper.GetBool(\"verbose\") // true ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:7","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.8 使用环境变量Viper完全支持环境变量。这使Twelve-Factor App开箱即用。有五种方法可以帮助与ENV协作: AutomaticEnv() BindEnv(string...) : error SetEnvPrefix(string) SetEnvKeyReplacer(string...) *strings.Replacer AllowEmptyEnv(bool) 使用ENV变量时，务必要意识到Viper将ENV变量视为区分大小写。 Viper提供了一种机制来确保ENV变量是惟一的。通过使用SetEnvPrefix，你可以告诉Viper在读取环境变量时使用前缀。BindEnv和AutomaticEnv都将使用这个前缀。 BindEnv使用一个或两个参数。第一个参数是键名称，第二个是环境变量的名称。环境变量的名称区分大小写。如果没有提供ENV变量名，那么Viper将自动假设ENV变量与以下格式匹配：前缀+ “_” +键名全部大写。当你显式提供ENV变量名（第二个参数）时，它 不会 自动添加前缀。例如，如果第二个参数是“id”，Viper将查找环境变量“ID”。 在使用ENV变量时，需要注意的一件重要事情是，每次访问该值时都将读取它。Viper在调用BindEnv时不固定该值。 AutomaticEnv是一个强大的助手，尤其是与SetEnvPrefix结合使用时。调用时，Viper会在发出viper.Get请求时随时检查环境变量。它将应用以下规则。它将检查环境变量的名称是否与键匹配（如果设置了EnvPrefix）。 SetEnvKeyReplacer允许你使用strings.Replacer对象在一定程度上重写 Env 键。如果你希望在Get()调用中使用-或者其他什么符号，但是环境变量里使用_分隔符，那么这个功能是非常有用的。可以在viper_test.go中找到它的使用示例。 或者，你可以使用带有NewWithOptions工厂函数的EnvKeyReplacer。与SetEnvKeyReplacer不同，它接受StringReplacer接口，允许你编写自定义字符串替换逻辑。 默认情况下，空环境变量被认为是未设置的，并将返回到下一个配置源。若要将空环境变量视为已设置，请使用AllowEmptyEnv方法。 3.8.1 Env 示例： SetEnvPrefix(\"spf\") // 将自动转为大写 BindEnv(\"id\") os.Setenv(\"SPF_ID\", \"13\") // 通常是在应用程序之外完成的 id := Get(\"id\") // 13 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:8","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.9 使用FlagsViper 具有绑定到标志的能力。具体来说，Viper支持Cobra库中使用的Pflag。 与BindEnv类似，该值不是在调用绑定方法时设置的，而是在访问该方法时设置的。这意味着你可以根据需要尽早进行绑定，即使在init()函数中也是如此。 对于单个标志，BindPFlag()方法提供此功能。 例如： serverCmd.Flags().Int(\"port\", 1138, \"Port to run Application server on\") viper.BindPFlag(\"port\", serverCmd.Flags().Lookup(\"port\")) 你还可以绑定一组现有的pflags （pflag.FlagSet）： 举个例子： pflag.Int(\"flagname\", 1234, \"help message for flagname\") pflag.Parse() viper.BindPFlags(pflag.CommandLine) i := viper.GetInt(\"flagname\") // 从viper而不是从pflag检索值 在 Viper 中使用 pflag 并不阻碍其他包中使用标准库中的 flag 包。pflag 包可以通过导入这些 flags 来处理flag包定义的flags。这是通过调用pflag包提供的便利函数AddGoFlagSet()来实现的。 例如： package main import ( \"flag\" \"github.com/spf13/pflag\" ) func main() { // 使用标准库 \"flag\" 包 flag.Int(\"flagname\", 1234, \"help message for flagname\") pflag.CommandLine.AddGoFlagSet(flag.CommandLine) pflag.Parse() viper.BindPFlags(pflag.CommandLine) i := viper.GetInt(\"flagname\") // 从 viper 检索值 ... } 3.9.1 flag接口如果你不使用Pflag，Viper 提供了两个Go接口来绑定其他 flag 系统。 FlagValue表示单个flag。这是一个关于如何实现这个接口的非常简单的例子： type myFlag struct {} func (f myFlag) HasChanged() bool { return false } func (f myFlag) Name() string { return \"my-flag-name\" } func (f myFlag) ValueString() string { return \"my-flag-value\" } func (f myFlag) ValueType() string { return \"string\" } 一旦你的 flag 实现了这个接口，你可以很方便地告诉Viper绑定它： viper.BindFlagValue(\"my-flag-name\", myFlag{}) FlagValueSet代表一组 flags 。这是一个关于如何实现这个接口的非常简单的例子: type myFlagSet struct { flags []myFlag } func (f myFlagSet) VisitAll(fn func(FlagValue)) { for _, flag := range flags { fn(flag) } } 一旦你的flag set实现了这个接口，你就可以很方便地告诉Viper绑定它： fSet := myFlagSet{ flags: []myFlag{myFlag{}, myFlag{}}, } viper.BindFlagValues(\"my-flags\", fSet) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:9","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.10 远程Key/Value存储支持在Viper中启用远程支持，需要在代码中匿名导入viper/remote这个包。 import _ \"github.com/spf13/viper/remote\" Viper将读取从Key/Value存储（例如etcd或Consul）中的路径检索到的配置字符串（如JSON、TOML、YAML、HCL、envfile和Java properties格式）。这些值的优先级高于默认值，但是会被从磁盘、flag或环境变量检索到的配置值覆盖。（译注：也就是说Viper加载配置值的优先级为：磁盘上的配置文件\u003e命令行标志位\u003e环境变量\u003e远程Key/Value存储\u003e默认值。） Viper使用crypt从K/V存储中检索配置，这意味着如果你有正确的gpg密匙，你可以将配置值加密存储并自动解密。加密是可选的。 你可以将远程配置与本地配置结合使用，也可以独立使用。 crypt有一个命令行助手，你可以使用它将配置放入K/V存储中。crypt默认使用在http://127.0.0.1:4001的etcd。 $ go get github.com/bketelsen/crypt/bin/crypt $ crypt set -plaintext /config/hugo.json /Users/hugo/settings/config.json 确认值已经设置： $ crypt get -plaintext /config/hugo.json 有关如何设置加密值或如何使用Consul的示例，请参见crypt文档。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:10","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.11 远程Key/Value存储示例-未加密\r3.11.1 etcd viper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\",\"/config/hugo.json\") viper.SetConfigType(\"json\") // 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\" err := viper.ReadRemoteConfig() 3.11.2 Consul你需要 Consul Key/Value存储中设置一个Key保存包含所需配置的JSON值。例如，创建一个keyMY_CONSUL_KEY将下面的值存入Consul key/value 存储： { \"port\": 8080, \"hostname\": \"liwenzhou.com\" } viper.AddRemoteProvider(\"consul\", \"localhost:8500\", \"MY_CONSUL_KEY\") viper.SetConfigType(\"json\") // 需要显示设置成json err := viper.ReadRemoteConfig() fmt.Println(viper.Get(\"port\")) // 8080 fmt.Println(viper.Get(\"hostname\")) // liwenzhou.com 3.11.3 Firestore viper.AddRemoteProvider(\"firestore\", \"google-cloud-project-id\", \"collection/document\") viper.SetConfigType(\"json\") // 配置的格式: \"json\", \"toml\", \"yaml\", \"yml\" err := viper.ReadRemoteConfig() 当然，你也可以使用SecureRemoteProvider。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:11","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.12 远程Key/Value存储示例-加密 viper.AddSecureRemoteProvider(\"etcd\",\"http://127.0.0.1:4001\",\"/config/hugo.json\",\"/etc/secrets/mykeyring.gpg\") viper.SetConfigType(\"json\") // 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\" err := viper.ReadRemoteConfig() ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:12","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r3.13 监控etcd中的更改-未加密 // 或者你可以创建一个新的viper实例 var runtime_viper = viper.New() runtime_viper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\", \"/config/hugo.yml\") runtime_viper.SetConfigType(\"yaml\") // 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\" // 第一次从远程读取配置 err := runtime_viper.ReadRemoteConfig() // 反序列化 runtime_viper.Unmarshal(\u0026runtime_conf) // 开启一个单独的goroutine一直监控远端的变更 go func(){ for { time.Sleep(time.Second * 5) // 每次请求后延迟一下 // 目前只测试了etcd支持 err := runtime_viper.WatchRemoteConfig() if err != nil { log.Errorf(\"unable to read remote config: %v\", err) continue } // 将新配置反序列化到我们运行时的配置结构体中。你还可以借助channel实现一个通知系统更改的信号 runtime_viper.Unmarshal(\u0026runtime_conf) } }() ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:3:13","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r4 从Viper获取值在Viper中，有几种方法可以根据值的类型获取值。存在以下功能和方法: Get(key string) : interface{} GetBool(key string) : bool GetFloat64(key string) : float64 GetInt(key string) : int GetIntSlice(key string) : []int GetString(key string) : string GetStringMap(key string) : map[string]interface{} GetStringMapString(key string) : map[string]string GetStringSlice(key string) : []string GetTime(key string) : time.Time GetDuration(key string) : time.Duration IsSet(key string) : bool AllSettings() : map[string]interface{} 需要认识到的一件重要事情是，每一个Get方法在找不到值的时候都会返回零值。为了检查给定的键是否存在，提供了IsSet()方法。 例如： viper.GetString(\"logfile\") // 不区分大小写的设置和获取 if viper.GetBool(\"verbose\") { fmt.Println(\"verbose enabled\") } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:4:0","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r4.1 访问嵌套的键访问器方法也接受深度嵌套键的格式化路径。例如，如果加载下面的JSON文件： { \"host\": { \"address\": \"localhost\", \"port\": 5799 }, \"datastore\": { \"metric\": { \"host\": \"127.0.0.1\", \"port\": 3099 }, \"warehouse\": { \"host\": \"198.0.0.1\", \"port\": 2112 } } } Viper可以通过传入.分隔的路径来访问嵌套字段： GetString(\"datastore.metric.host\") // (返回 \"127.0.0.1\") 这遵守上面建立的优先规则；搜索路径将遍历其余配置注册表，直到找到为止。(译注：因为Viper支持从多种配置来源，例如磁盘上的配置文件\u003e命令行标志位\u003e环境变量\u003e远程Key/Value存储\u003e默认值，我们在查找一个配置的时候如果在当前配置源中没找到，就会继续从后续的配置源查找，直到找到为止。) 例如，在给定此配置文件的情况下，datastore.metric.host和datastore.metric.port均已定义（并且可以被覆盖）。如果另外在默认值中定义了datastore.metric.protocol，Viper也会找到它。 然而，如果datastore.metric被直接赋值覆盖（被flag，环境变量，set()方法等等…），那么datastore.metric的所有子键都将变为未定义状态，它们被高优先级配置级别“遮蔽”（shadowed）了。 最后，如果存在与分隔的键路径匹配的键，则返回其值。例如： { \"datastore.metric.host\": \"0.0.0.0\", \"host\": { \"address\": \"localhost\", \"port\": 5799 }, \"datastore\": { \"metric\": { \"host\": \"127.0.0.1\", \"port\": 3099 }, \"warehouse\": { \"host\": \"198.0.0.1\", \"port\": 2112 } } } GetString(\"datastore.metric.host\") // 返回 \"0.0.0.0\" ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:4:1","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r4.2 提取子树从Viper中提取子树。 例如，viper实例现在代表了以下配置： app: cache1: max-items: 100 item-size: 64 cache2: max-items: 200 item-size: 80 执行后： subv := viper.Sub(\"app.cache1\") subv现在就代表： max-items: 100 item-size: 64 假设我们现在有这么一个函数： func NewCache(cfg *Viper) *Cache {...} 它基于subv格式的配置信息创建缓存。现在，可以轻松地分别创建这两个缓存，如下所示： cfg1 := viper.Sub(\"app.cache1\") cache1 := NewCache(cfg1) cfg2 := viper.Sub(\"app.cache2\") cache2 := NewCache(cfg2) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:4:2","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r4.3 反序列化你还可以选择将所有或特定的值解析到结构体、map等。 有两种方法可以做到这一点： Unmarshal(rawVal interface{}) : error UnmarshalKey(key string, rawVal interface{}) : error 举个例子： type config struct { Port int Name string PathMap string `mapstructure:\"path_map\"` } var C config err := viper.Unmarshal(\u0026C) if err != nil { t.Fatalf(\"unable to decode into struct, %v\", err) } 如果你想要解析那些键本身就包含.(默认的键分隔符）的配置，你需要修改分隔符： v := viper.NewWithOptions(viper.KeyDelimiter(\"::\")) v.SetDefault(\"chart::values\", map[string]interface{}{ \"ingress\": map[string]interface{}{ \"annotations\": map[string]interface{}{ \"traefik.frontend.rule.type\": \"PathPrefix\", \"traefik.ingress.kubernetes.io/ssl-redirect\": \"true\", }, }, }) type config struct { Chart struct{ Values map[string]interface{} } } var C config v.Unmarshal(\u0026C) Viper还支持解析到嵌入的结构体： /* Example config: module: enabled: true token: 89h3f98hbwf987h3f98wenf89ehf */ type config struct { Module struct { Enabled bool moduleConfig `mapstructure:\",squash\"` } } // moduleConfig could be in a module specific package type moduleConfig struct { Token string } var C config err := viper.Unmarshal(\u0026C) if err != nil { t.Fatalf(\"unable to decode into struct, %v\", err) } Viper在后台使用github.com/mitchellh/mapstructure来解析值，其默认情况下使用mapstructuretag。 注意 当我们需要将viper读取的配置反序列到我们定义的结构体变量中时，一定要使用mapstructuretag哦！ ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:4:3","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r4.4 序列化成字符串你可能需要将viper中保存的所有设置序列化到一个字符串中，而不是将它们写入到一个文件中。你可以将自己喜欢的格式的序列化器与AllSettings()返回的配置一起使用。 import ( yaml \"gopkg.in/yaml.v2\" // ... ) func yamlStringSettings() string { c := viper.AllSettings() bs, err := yaml.Marshal(c) if err != nil { log.Fatalf(\"unable to marshal config to YAML: %v\", err) } return string(bs) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:4:4","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r5 使用单个还是多个Viper实例?Viper是开箱即用的。你不需要配置或初始化即可开始使用Viper。由于大多数应用程序都希望使用单个中央存储库管理它们的配置信息，所以viper包提供了这个功能。它类似于单例模式。 在上面的所有示例中，它们都以其单例风格的方法演示了如何使用viper。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:5:0","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r5.1 使用多个viper实例你还可以在应用程序中创建许多不同的viper实例。每个都有自己独特的一组配置和值。每个人都可以从不同的配置文件，key value存储区等读取数据。每个都可以从不同的配置文件、键值存储等中读取。viper包支持的所有功能都被镜像为viper实例的方法。 例如： x := viper.New() y := viper.New() x.SetDefault(\"ContentDir\", \"content\") y.SetDefault(\"ContentDir\", \"foobar\") //... 当使用多个viper实例时，由用户来管理不同的viper实例。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:5:1","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r6 使用Viper示例假设我们的项目现在有一个./conf/config.yaml配置文件，内容如下： port: 8123 version: \"v1.2.3\" 接下来通过示例代码演示两种在项目中使用viper管理项目配置信息的方式。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:6:0","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r6.1 直接使用viper管理配置这里用一个demo演示如何在gin框架搭建的web项目中使用viper，使用viper加载配置文件中的信息，并在代码中直接使用viper.GetXXX()方法获取对应的配置值。 package main import ( \"fmt\" \"net/http\" \"github.com/gin-gonic/gin\" \"github.com/spf13/viper\" ) func main() { viper.SetConfigFile(\"config.yaml\") // 指定配置文件 viper.AddConfigPath(\"./conf/\") // 指定查找配置文件的路径 err := viper.ReadInConfig() // 读取配置信息 if err != nil { // 读取配置信息失败 panic(fmt.Errorf(\"Fatal error config file: %s \\n\", err)) } // 监控配置文件变化 viper.WatchConfig() r := gin.Default() // 访问/version的返回值会随配置文件的变化而变化 r.GET(\"/version\", func(c *gin.Context) { c.String(http.StatusOK, viper.GetString(\"version\")) }) if err := r.Run( fmt.Sprintf(\":%d\", viper.GetInt(\"port\"))); err != nil { panic(err) } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:6:1","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r6.2 使用结构体变量保存配置信息除了上面的用法外，我们还可以在项目中定义与配置文件对应的结构体，viper加载完配置信息后使用结构体变量保存配置信息。 package main import ( \"fmt\" \"net/http\" \"github.com/fsnotify/fsnotify\" \"github.com/gin-gonic/gin\" \"github.com/spf13/viper\" ) type Config struct { Port int `mapstructure:\"port\"` Version string `mapstructure:\"version\"` } var Conf = new(Config) func main() { viper.SetConfigFile(\"./conf/config.yaml\") // 指定配置文件路径 err := viper.ReadInConfig() // 读取配置信息 if err != nil { // 读取配置信息失败 panic(fmt.Errorf(\"Fatal error config file: %s \\n\", err)) } // 将读取的配置信息保存至全局变量Conf if err := viper.Unmarshal(Conf); err != nil { panic(fmt.Errorf(\"unmarshal conf failed, err:%s \\n\", err)) } // 监控配置文件变化 viper.WatchConfig() // 注意！！！配置文件发生变化后要同步到全局变量Conf viper.OnConfigChange(func(in fsnotify.Event) { fmt.Println(\"夭寿啦~配置文件被人修改啦...\") if err := viper.Unmarshal(Conf); err != nil { panic(fmt.Errorf(\"unmarshal conf failed, err:%s \\n\", err)) } }) r := gin.Default() // 访问/version的返回值会随配置文件的变化而变化 r.GET(\"/version\", func(c *gin.Context) { c.String(http.StatusOK, Conf.Version) }) if err := r.Run(fmt.Sprintf(\":%d\", Conf.Port)); err != nil { panic(err) } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180148/:6:2","tags":null,"title":"6-1.配置管理库—Viper","uri":"/lang/go/go_advanced/20250515180148/"},{"categories":null,"content":"\r1 一. 三次握手 1.0.1 tcp在建立连接时需要三次握手:1.accept接受过程中等待客户端的连接,当客户端发起连接时,会发起一个syn连接请求, 2.服务端收到该连接请求之后会立即响应一个ack的响应,与此同时还会向客户端发送一个syn连接请求 3.当客户端收到服务端的ack响应请求和syn连接请求之后,再向服务端回应一个ack的响应请求就可以建立tcp连接了 1.0.2 tcp的四次挥手:1.再客户端和服务端的代码中都有一个close方法,当有一方主动断开时,也就是执行close方法时,就是一次fin断开请求,在发出断开连接请求之后,如果收到对方的断开确认ack请求之后,就可以结束一段段额断开了,这样就是两次请求; 2.当客户端和服务端双方都执行close方法,就会有两次断开请求和两次断开确认,这样就完成了连接断开,四次挥手; 1.0.3 为什么连接是三次,而握手需要四次:因为在创建连接时,服务端收到客户端的连接请求后,会发送一个ack的响应和一个syn的请求,为了解决资源开销,这两个操作合并在了一起,就是三次握手了,但是在断开tcp连接的时候在一方断开请求的时候另一方可能还有数据正在传输,,为了确保数据传输的完整性,就需要四次挥手. 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180144/:1:0","tags":null,"title":"5.TCP网络连接以及TIME_WAIT的意义","uri":"/lang/go/go_advanced/20250515180144/"},{"categories":null,"content":"\r2 二. 四次挥手 2.0.4 tcp在建立连接时需要三次握手:1.accept接受过程中等待客户端的连接,当客户端发起连接时,会发起一个syn连接请求, 2.服务端收到该连接请求之后会立即响应一个ack的响应,与此同时还会向客户端发送一个syn连接请求 3.当客户端收到服务端的ack响应请求和syn连接请求之后,再向服务端回应一个ack的响应请求就可以建立tcp连接了 2.0.5 tcp的四次挥手:1.再客户端和服务端的代码中都有一个close方法,当有一方主动断开时,也就是执行close方法时,就是一次fin断开请求,在发出断开连接请求之后,如果收到对方的断开确认ack请求之后,就可以结束一段段额断开了,这样就是两次请求; 2.当客户端和服务端双方都执行close方法,就会有两次断开请求和两次断开确认,这样就完成了连接断开,四次挥手; 2.0.6 为什么连接是三次,而握手需要四次:因为在创建连接时,服务端收到客户端的连接请求后,会发送一个ack的响应和一个syn的请求,为了解决资源开销,这两个操作合并在了一起,就是三次握手了,但是在断开tcp连接的时候在一方断开请求的时候另一方可能还有数据正在传输,,为了确保数据传输的完整性,就需要四次挥手. 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 6)服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180144/:2:0","tags":null,"title":"5.TCP网络连接以及TIME_WAIT的意义","uri":"/lang/go/go_advanced/20250515180144/"},{"categories":null,"content":"\r3 三. 经典问题【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 【问题3】为什么不能用两次握手进行连接？ 3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180144/:3:0","tags":null,"title":"5.TCP网络连接以及TIME_WAIT的意义","uri":"/lang/go/go_advanced/20250515180144/"},{"categories":null,"content":"\r4 四. 什么是TIME_WAIT TIME_WAIT是TCP协议中断开连接所经历的一种状态。 我们在日常做服务器的研发中、或者面试网络部分知识的时候，会经常问到TIME_WAIT这个词，这个词作为服务端的开发者尤为重要。 上图是TCP连接的状态转换，包括了一些触发条件，如果不是很直观，可以对比看下面的简图。(三次握手四次挥手) 这里面作为主动关闭的一方(Client)出现了TIME_WAIT状态，目的是告诉Server端，自己没有需要发送的数据，但是它仍然保持了接收对方数据的能力，一个常见的关闭连接过程如下： 1、当客户端没有待发送的数据时，它会向服务端发送 FIN 消息，发送消息后会进入 FIN_WAIT_1 状态； 2、服务端接收到客户端的 FIN 消息后，会进入 CLOSE_WAIT 状态并向客户端发送 ACK 消息，客户端接收到 ACK 消息时会进入 FIN_WAIT_2 状态； 3、当服务端没有待发送的数据时，服务端会向客户端发送 FIN 消息； 4、客户端接收到 FIN 消息后，会进入 TIME_WAIT 状态并向服务端发送 ACK 消息，服务端收到后会进入 CLOSED 状态； 5、客户端等待两个最大数据段生命周期（Maximum segment lifetime，MSL）的时间后也会进入 CLOSED 状态； ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180144/:4:0","tags":null,"title":"5.TCP网络连接以及TIME_WAIT的意义","uri":"/lang/go/go_advanced/20250515180144/"},{"categories":null,"content":"\r5 五. 为什么需要TIME_WAIT 5.0.7 TIME_WAIT 一定是发生在主动关闭一方被动关闭一方，会直接进入CLOSED状态，而主动关闭一方需要等待2*MSL时间才会最终关闭。 原因： 1、防止被动关闭方的延迟数据被人窃取 2、防止被动关闭方没有收到最后的ACK 5.0.8 原因一：防止被动关闭方的延迟数据被人窃取 如上图所示， 1、在①中，服务端发送seq=1001的消息，由于网络延迟或其他原因，没有及时到达Client1客户端，导致整个包一直存留在网络环境的传输过程中。 2、在②中，Client1收到server的FIN包之后，变成了TIME_WAIT状态，这里假设TIME_WAIT等待的时间很短暂，那么，还没等之前的那个延迟包seq=1001到来，就回复给了Server最后一个ACK包。那么Server就会变成CLOSED状态。 3、在③中，相同的端口号的Client2的TCP链接被重用后 4、在④中，seq=1001的延迟包消息才发送给客户端，而这个延迟的消息却被Client2正常接收，主要就会给Client2带来严重的问题。所以TIME_WAIT不要轻易的调整，或者缩小时间，可能就会出现这种问题。 5.0.9 原因二：防止被动关闭方没有收到最后的ACK 该作用就是等待足够长的时间以确定远程的TCP链接收到了其发出的终止链接消息FIN包的回执消息ACK包。 如上图所示： 1、在①中，CLient1端主动发起关闭链接，Server针对Client1的FIN回执了ACK包，然后接着发送了自己的FIN包，等待Client1回执最终的ACK包。 2、在②中，这里假设TIME_WAIT的时间不足够充分，当Server还没有收到 ACK 消息时，Client1就主动变成CLOSED状态。 3、在③中，由于Server一直没有等到自己FIN包的ACK应答包，导致一直处于LAST_ACK状态。 4、在④中，因为 服务端因为没有收到 ACK 消息，当Client2重新与Server建立TCP链接，认为当前连接是合法的，CLient2重新发送 SYN 消息请求握手时会收到Server的 RST 消息，连接建立的过程就会被终止。 所以，我们在默认情况下，如果客户端等待足够长的时间就会遇到以下两种情况： 服务端正常收到了 ACK 消息并关闭当前 TCP 连接； 服务端没有收到 ACK 消息，重新发送 FIN 关闭连接并等待新的 ACK 消息； 只要客户端等待 2 MSL 的时间，客户端和服务端之间的连接就会正常关闭，新创建的 TCP 连接收到影响的概率也微乎其微，保证了数据传输的可靠性。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180144/:5:0","tags":null,"title":"5.TCP网络连接以及TIME_WAIT的意义","uri":"/lang/go/go_advanced/20250515180144/"},{"categories":null,"content":"\r一. 不控制goroutine数量 package main import ( \"fmt\" \"math\" \"runtime\" ) func main() { //模拟用户需求业务的数量 task_cnt := math.MaxInt64 for i := 0; i \u003c task_cnt; i++ { go func(i int) { //... do some busi... fmt.Println(\"go func \", i, \" goroutine count = \", runtime.NumGoroutine()) }(i) } } // panic: too many concurrent operations on a single file or socket (max 1048575) 我们迅速的开辟goroutine(不控制并发的 goroutine 数量 )会在短时间内占据操作系统的资源(CPU、内存、文件描述符等)。 CPU 使用率浮动上涨 Memory 占用不断上涨。 主进程崩溃（被杀掉了） 这些资源实际上是所有用户态程序共享的资源，所以大批的goroutine最终引发的灾难不仅仅是自身，还会关联其他运行的程序。 二. 控制goroutines数量","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180140/:0:0","tags":null,"title":"4-2控制goroutine的数量","uri":"/lang/go/go_advanced/20250515180140/"},{"categories":null,"content":"\r1 1. 有缓冲channel与sync同步组合方式 package main import ( \"fmt\" \"math\" \"sync\" \"runtime\" ) var wg = sync.WaitGroup{} func busi(ch chan bool, i int) { fmt.Println(\"go func \", i, \" goroutine count = \", runtime.NumGoroutine()) \u003c-ch wg.Done() } func main() { //模拟用户需求go业务的数量 task_cnt := math.MaxInt64 ch := make(chan bool, 3) for i := 0; i \u003c task_cnt; i++ { wg.Add(1) ch \u003c- true go busi(ch, i) } wg.Wait() } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180140/:1:0","tags":null,"title":"4-2控制goroutine的数量","uri":"/lang/go/go_advanced/20250515180140/"},{"categories":null,"content":"\r2 2. 利用无缓冲channel与任务发送/执行分离方式 生产者消费者模型 package main import ( \"fmt\" \"math\" \"sync\" \"runtime\" ) var wg = sync.WaitGroup{} func busi(ch chan int) { for t := range ch { fmt.Println(\"go task = \", t, \", goroutine count = \", runtime.NumGoroutine()) wg.Done() } } func sendTask(task int, ch chan int) { wg.Add(1) ch \u003c- task } func main() { ch := make(chan int) //无buffer channel goCnt := 3 //启动goroutine的数量 for i := 0; i \u003c goCnt; i++ { //启动go go busi(ch) } taskCnt := math.MaxInt64 //模拟用户需求业务的数量 for t := 0; t \u003c taskCnt; t++ { //发送任务 sendTask(t, ch) } wg.Wait() } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180140/:2:0","tags":null,"title":"4-2控制goroutine的数量","uri":"/lang/go/go_advanced/20250515180140/"},{"categories":null,"content":" 主要介绍常见的Server的并发模型，这些模型与编程语言本身无关，有的编程语言可能在语法上直接透明了模型本质，所以开发者没必要一定要基于模型去编写，只是需要知道和了解并发模型的构成和特点即可。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180130/:0:0","tags":null,"title":"4-1.单点Server的N种并发模型汇总","uri":"/lang/go/go_advanced/20250515180130/"},{"categories":null,"content":"\r1 模型一、单线程Accept（无IO复用）\r1.0.1 (1) 模型结构图 1.0.2 (2) 模型分析① 主线程main thread执行阻塞Accept，每次客户端Connect链接过来，main thread中accept响应并建立连接 ② 创建链接成功，得到Connfd1套接字后, 依然在main thread串行处理套接字读写，并处理业务。 ③ 在②处理业务中，如果有新客户端Connect过来，Server无响应，直到当前套接字全部业务处理完毕。 ④ 当前客户端处理完后，完毕链接，处理下一个客户端请求。 1.0.3 (3) 优缺点优点： socket编程流程清晰且简单，适合学习使用，了解socket基本编程流程。 缺点： 该模型并非并发模型，是串行的服务器，同一时刻，监听并响应最大的网络请求量为1。 即并发量为1。 仅适合学习基本socket编程，不适合任何服务器Server构建。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180130/:1:0","tags":null,"title":"4-1.单点Server的N种并发模型汇总","uri":"/lang/go/go_advanced/20250515180130/"},{"categories":null,"content":"\r2 模型二、单线程Accept+多线程读写业务（无IO复用）\r2.0.4 (1) 模型结构图 2.0.5 (2) 模型分析① 主线程main thread执行阻塞Accept，每次客户端Connect链接过来，main thread中accept响应并建立连接 ② 创建链接成功，得到Connfd1套接字后，创建一个新线程thread1用来处理客户端的读写业务。main thead依然回到Accept阻塞等待新客户端。 ③ thread1通过套接字Connfd1与客户端进行通信读写。 ④ server在②处理业务中，如果有新客户端Connect过来，main thread中Accept依然响应并建立连接，重复②过程。 2.0.6 (3) 优缺点优点： 基于模型一：单线程Accept（无IO复用） 支持了并发的特性。 使用灵活，一个客户端对应一个线程单独处理，server处理业务内聚程度高，客户端无论如何写，服务端均会有一个线程做资源响应。 缺点： 随着客户端的数量增多，需要开辟的线程也增加，客户端与server线程数量1:1正比关系，一次对于高并发场景，线程数量收到硬件上限瓶颈。 对于长链接，客户端一旦无业务读写，只要不关闭，server的对应线程依然需要保持连接(心跳、健康监测等机制)，占用连接资源和线程开销资源浪费。 仅适合客户端数量不大，并且数量可控的场景使用。 仅适合学习基本socket编程，不适合任何服务器Server构建。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180130/:2:0","tags":null,"title":"4-1.单点Server的N种并发模型汇总","uri":"/lang/go/go_advanced/20250515180130/"},{"categories":null,"content":"\r3 模型三、单线程多路IO复用\r3.0.7 (1) 模型结构图 3.0.8 (2) 模型分析① 主线程main thread创建listenFd之后，采用多路I/O复用机制(如:select、epoll)进行IO状态阻塞监控。有Client1客户端Connect请求，I/O复用机制检测到ListenFd触发读事件，则进行Accept建立连接，并将新生成的connFd1加入到监听I/O集合中。 ② Client1再次进行正常读写业务请求，main thread的多路I/O复用机制阻塞返回，会触该套接字的读/写事件等。 ③ 对于Client1的读写业务，Server依然在main thread执行流程提继续执行，此时如果有新的客户端Connect链接请求过来，Server将没有即时响应。 ④ 等到Server处理完一个连接的Read+Write操作，继续回到多路I/O复用机制阻塞，其他链接过来重复 ②、③流程。 3.0.9 (3) 优缺点优点： 单流程解决了可以同时监听多个客户端读写状态的模型，不需要1:1与客户端的线程数量关系。 多路I/O复用阻塞，非忙询状态，不浪费CPU资源， CPU利用率较高。 缺点： 虽然可以监听多个客户端的读写状态，但是同一时间内，只能处理一个客户端的读写操作，实际上读写的业务并发为1。 多客户端访问Server，业务为串行执行，大量请求会有排队延迟现象，如图中⑤所示，当Client3占据main thread流程时，Client1,Client2流程卡在IO复用等待下次监听触发事件。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180130/:3:0","tags":null,"title":"4-1.单点Server的N种并发模型汇总","uri":"/lang/go/go_advanced/20250515180130/"},{"categories":null,"content":"\r4 模型四、单线程多路IO复用+多线程读写业务(业务工作池)\r4.0.10 (1) 模型结构图 4.0.11 (2) 模型分析① 主线程main thread创建listenFd之后，采用多路I/O复用机制(如:select、epoll)进行IO状态阻塞监控。有Client1客户端Connect请求，I/O复用机制检测到ListenFd触发读事件，则进行Accept建立连接，并将新生成的connFd1加入到监听I/O集合中。 ② 当connFd1有可读消息，触发读事件，并且进行读写消息 ③ main thread按照固定的协议读取消息，并且交给worker pool工作线程池， 工作线程池在server启动之前就已经开启固定数量的thread，里面的线程只处理消息业务，不进行套接字读写操作。 ④ 工作池处理完业务，触发connFd1写事件，将回执客户端的消息通过main thead写给对方。 4.0.12 (3) 优缺点优点： 对于模型三, 将业务处理部分，通过工作池分离出来，减少多客户端访问Server，业务为串行执行，大量请求会有排队延迟时间。 实际上读写的业务并发为1，但是业务流程并发为worker pool线程数量，加快了业务处理并行效率。 缺点： 读写依然为main thread单独处理，最高读写并行通道依然为1. 虽然多个worker线程处理业务，但是最后返回给客户端，依旧需要排队，因为出口还是main thread的Read + Write ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180130/:4:0","tags":null,"title":"4-1.单点Server的N种并发模型汇总","uri":"/lang/go/go_advanced/20250515180130/"},{"categories":null,"content":"\r5 模型五、单线程IO复用+多线程IO复用(链接线程池)\r5.0.13 (1) 模型结构图 5.0.14 (2) 模型分析① Server在启动监听之前，开辟固定数量(N)的线程，用Thead Pool线程池管理 ② 主线程main thread创建listenFd之后，采用多路I/O复用机制(如:select、epoll)进行IO状态阻塞监控。有Client1客户端Connect请求，I/O复用机制检测到ListenFd触发读事件，则进行Accept建立连接，并将新生成的connFd1分发给Thread Pool中的某个线程进行监听。 ③ Thread Pool中的每个thread都启动多路I/O复用机制(select、epoll),用来监听main thread建立成功并且分发下来的socket套接字。 ④ 如图， thread监听ConnFd1、ConnFd2, thread2监听ConnFd3,thread3监听ConnFd4. 当对应的ConnFd有读写事件，对应的线程处理该套接字的读写及业务。 5.0.15 (3) 优缺点优点： 将main thread的单流程读写，分散到多线程完成，这样增加了同一时刻的读写并行通道，并行通道数量N， N为线程池Thread数量。 server同时监听的ConnFd套接字数量几乎成倍增大，之前的全部监控数量取决于main thread的多路I/O复用机制的最大限制***(select 默认为1024， epoll默认与内存大小相关，约3~6w不等)***，所以理论单点Server最高响应并发数量为N*(3~6W)(N为线程池Thread数量，建议与CPU核心成比例1:1)。 如果良好的线程池数量和CPU核心数适配，那么可以尝试CPU核心与Thread进行绑定，从而降低CPU的切换频率，提升每个Thread处理合理业务的效率，降低CPU切换成本开销。 缺点： 虽然监听的并发数量提升，但是最高读写并行通道依然为N，而且多个身处同一个Thread的客户端，会出现读写延迟现象，实际上每个Thread的模型特征与模型三：单线程多路IO复用一致。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180130/:5:0","tags":null,"title":"4-1.单点Server的N种并发模型汇总","uri":"/lang/go/go_advanced/20250515180130/"},{"categories":null,"content":"\r6 模型五、单进程多路I/O复用+多进程多路I/O复用(进程池)\r6.0.16 (1) 模型结构图 6.0.17 (2) 模型分析与五、单线程IO复用+多线程IO复用(链接线程池)无大差异。 不同处 进程和线程的内存布局不同导致，main process(主进程)不再进行Accept操作，而是将Accept过程分散到各个子进程(process)中. 进程的特性，资源独立，所以main process如果Accept成功的fd，其他进程无法共享资源，所以需要各子进程自行Accept创建链接 main process只是监听ListenFd状态，一旦触发读事件(有新连接请求). 通过一些IPC(进程间通信：如信号、共享内存、管道)等, 让各自子进程Process竞争Accept完成链接建立，并各自监听。 6.0.18 (3) 优缺点与五、单线程IO复用+多线程IO复用(链接线程池)无大差异。 不同处: 多进程内存资源空间占用稍微大一些 多进程模型安全稳定型较强，这也是因为各自进程互不干扰的特点导致。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180130/:6:0","tags":null,"title":"4-1.单点Server的N种并发模型汇总","uri":"/lang/go/go_advanced/20250515180130/"},{"categories":null,"content":"\r7 模型六、单线程多路I/O复用+多线程多路I/O复用+多线程\r7.0.19 (1) 模型结构图 7.0.20 (2) 模型分析① Server在启动监听之前，开辟固定数量(N)的线程，用Thead Pool线程池管理 ② 主线程main thread创建listenFd之后，采用多路I/O复用机制(如:select、epoll)进行IO状态阻塞监控。有Client1客户端Connect请求，I/O复用机制检测到ListenFd触发读事件，则进行Accept建立连接，并将新生成的connFd1分发给Thread Pool中的某个线程进行监听。 ③ Thread Pool中的每个thread都启动多路I/O复用机制(select、epoll),用来监听main thread建立成功并且分发下来的socket套接字。一旦其中某个被监听的客户端套接字触发I/O读写事件,那么，会立刻开辟一个新线程来处理I/O读写业务。 ④ 但某个读写线程完成当前读写业务，如果当前套接字没有被关闭，那么将当前客户端套接字如:ConnFd3重新加回线程池的监控线程中，同时自身线程自我销毁。 7.0.21 (3) 优缺点优点： 在模型五、单线程IO复用+多线程IO复用(链接线程池)基础上，除了能够保证同时响应的最高并发数，又能解决读写并行通道局限的问题。 同一时刻的读写并行通道，达到最大化极限，一个客户端可以对应一个单独执行流程处理读写业务，读写并行通道与客户端数量1:1关系。 缺点： 该模型过于理想化，因为要求CPU核心数量足够大。 如果硬件CPU数量可数(目前的硬件情况)，那么该模型将造成大量的CPU切换成本浪费。因为为了保证读写并行通道与客户端1:1的关系，那么Server需要开辟的Thread数量就与客户端一致，那么线程池中做多路I/O复用的监听线程池绑定CPU数量将变得毫无意义。 如果每个临时的读写Thread都能够绑定一个单独的CPU，那么此模型将是最优模型。但是目前CPU的数量无法与客户端的数量达到一个量级，目前甚至差的不是几个量级的事。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180130/:7:0","tags":null,"title":"4-1.单点Server的N种并发模型汇总","uri":"/lang/go/go_advanced/20250515180130/"},{"categories":null,"content":"\r8 总结 综上，我们整理了7中Server的服务器处理结构模型，每个模型都有各自的特点和优势，那么对于多少应付高并发和高CPU利用率的模型，目前多数采用的是模型五(或模型五进程版，如Nginx就是类似模型五进程版的改版)。 至于并发模型并非设计的约复杂越好，也不是线程开辟的越多越好，我们要考虑硬件的利用与和切换成本的开销。模型六设计就极为复杂，线程较多，但以当今的硬件能力无法支撑，反倒导致该模型性能极差。所以对于不同的业务场景也要选择适合的模型构建，并不是一定固定就要使用某个来应用。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180130/:8:0","tags":null,"title":"4-1.单点Server的N种并发模型汇总","uri":"/lang/go/go_advanced/20250515180130/"},{"categories":null,"content":" 分布式实际上就是单一的本地一体解决方案，在硬件或者资源上不够业务需求，而采取的一种分散式多节点，可以扩容资源的一种解决思路。它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给多个计算机进行处理，最后把这些计算结果综合起来得到最终的结果。 一. 从本地事务到分布式理论 事务: 事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。 简单地说，事务提供一种“ 要么什么都不做，要么做全套（All or Nothing）”机制。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:0:0","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r1 1. ACID 事务是基于数据进行操作，需要保证事务的数据通常存储在数据库中，所以介绍到事务，就不得不介绍数据库事务的ACID特性，指数据库事务正确执行的四个基本特性的缩写。包含： 原子性（Atomicity） 一致性（Consistency） 隔离性（Isolation） 持久性（Durability） 原子性（Atomicity） 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。 一致性（Consistency） 在事务开始之前和事务结束以后，数据库数据的一致性约束没有被破坏。 隔离性（Isolation） 数据库允许多个并发事务同时对数据进行读写和修改的能力，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 例如：现有有个交易是从A账户转100元至B账户，在这个交易事务还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。 持久性（Durability） 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 而分布式事务不能实现这种ACID。因为有CAP理论约束。接下来我们来了解一下，分布式中是如何保证以上特性的，那么就有了一个著名的CAP理论。 二. 分布式事务 分布式事务顾名思义就是要在分布式系统中实现事务，它其实是由多个本地事务组合而成。 对于分布式事务而言几乎满足不了 ACID，其实对于单机事务而言大部分情况下也没有满足 ACID，不然怎么会有四种隔离级别呢？所以更别说分布在不同数据库或者不同应用上的分布式事务了。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:1:0","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r1 1. CAP理论 cap理论是分布式系统的理论基石 Consistency (一致性)： “all nodes see the same data at the same time”,即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。 Availability (可用性): 可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。 Partition Tolerance (分区容错性): 即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。 如果你你是一个分布式系统，那么你必须要满足一点：分区容错性 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:2:0","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r2 2. CAP取舍策略 CAP三个特性只能满足其中两个，那么取舍的策略就共有三种： **CA without P：**如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。 **CP without A：**如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。 AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:3:0","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r3 3. Base理论 分布式系统中的一致性是 弱一致性 , 单数据库 mysql的一致性 强一致性 BASE是Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：**即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。**接下来看一下BASE中的三要素： 基本可用 软状态 最终一致性 1、基本可用 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性—-注意，这绝不等价于系统不可用。 （1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒 （2）系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面 2、软状态 软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时 3、最终一致性 最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。 一句话：CAP就是告诉你：想要满足C、A、P就是做梦，BASE才是你最终的归宿 三. 常见分布式事务解决方案 两阶段提交（2PC, Two-phase Commit） TCC 补偿模式 基于本地消息表实现最终一致性 最大努力通知 基于可靠消息最终一致性方案 (常用, 高并发) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:4:0","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r1 1. 两阶段提交（2PC）两阶段提交又称2PC,2PC是一个非常经典的中心化的原子提交协议。 这里所说的中心化是指协议中有两类节点：一个是中心化协调者节点（coordinator）和N个参与者节点（partcipant）。 两个阶段：第一阶段：投票阶段 和第二阶段：提交/执行阶段。 举例 订单服务A，需要调用 支付服务B 去支付，支付成功则处理购物订单为待发货状态，否则就需要将购物订单处理为失败状态。 那么看2PC阶段是如何处理的 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:5:0","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r1.1 第一阶段：投票阶段 第一阶段主要分为3步 1）事务询问 协调者 向所有的 参与者 发送事务预处理请求，称之为Prepare，并开始等待各 参与者 的响应。 2）执行本地事务 各个 参与者 节点执行本地事务操作,但在执行完成后并不会真正提交数据库本地事务，而是先向 协调者 报告说：“我这边可以处理了/我这边不能处理”。. 3）各参与者向协调者反馈事务询问的响应 如果 参与者 成功执行了事务操作,那么就反馈给协调者 Yes 响应,表示事务可以执行,如果没有 参与者 成功执行事务,那么就反馈给协调者 No 响应,表示事务不可以执行。 第一阶段执行完后，会有两种可能。1、所有都返回Yes. 2、有一个或者多个返回No。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:5:1","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r1.2 第二阶段：提交/执行阶段（成功流程） 成功条件：所有参与者都返回Yes。 第二阶段主要分为两步 1)所有的参与者反馈给协调者的信息都是Yes,那么就会执行事务提交 协调者 向 所有参与者 节点发出Commit请求. 2)事务提交 参与者 收到Commit请求之后,就会正式执行本地事务Commit操作,并在完成提交之后释放整个事务执行期间占用的事务资源。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:5:2","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r1.3 第二阶段：提交/执行阶段（异常流程） 异常条件：任何一个 参与者 向 协调者 反馈了 No 响应,或者等待超时之后,协调者尚未收到所有参与者的反馈响应。 异常流程第二阶段也分为两步 1)发送回滚请求 协调者 向所有参与者节点发出 RoollBack 请求. 2)事务回滚 参与者 接收到RoollBack请求后,会回滚本地事务。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:5:3","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r1.4 2PC缺点 通过上面的演示，很容易想到2pc所带来的缺陷 1）性能问题 无论是在第一阶段的过程中,还是在第二阶段,所有的参与者资源和协调者资源都是被锁住的,只有当所有节点准备完毕，事务 协调者 才会通知进行全局提交， 参与者 进行本地事务提交后才会释放资源。这样的过程会比较漫长，对性能影响比较大。 2）单节点故障 由于协调者的重要性，一旦 协调者 发生故障。参与者 会一直阻塞下去。尤其在第二阶段，协调者 发生故障，那么所有的 参与者 还都处于 锁定事务资源的状态中，而无法继续完成事务操作。（虽然协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题） 2PC出现单点问题的三种情况 (1)协调者正常,参与者宕机 由于 协调者 无法收集到所有 参与者 的反馈，会陷入阻塞情况。 解决方案:引入超时机制,如果协调者在超过指定的时间还没有收到参与者的反馈,事务就失败,向所有节点发送终止事务请求。 (2)协调者宕机,参与者正常 无论处于哪个阶段，由于协调者宕机，无法发送提交请求，所有处于执行了操作但是未提交状态的参与者都会陷入阻塞情况. 解决方案:引入协调者备份,同时协调者需记录操作日志.当检测到协调者宕机一段时间后，协调者备份取代协调者，并读取操作日志，向所有参与者询问状态。 (3)协调者和参与者都宕机 发生在第一阶段： 因为第一阶段，所有参与者都没有真正执行commit，所以只需重新在剩余的参与者中重新选出一个协调者，新的协调者在重新执行第一阶段和第二阶段就可以了。 2)发生在第二阶段 并且 挂了的参与者在挂掉之前没有收到协调者的指令。也就是上面的第4步挂了，这是可能协调者还没有发送第4步就挂了。这种情形下，新的协调者重新执行第一阶段和第二阶段操作。 3)发生在第二阶段 并且 有部分参与者已经执行完commit操作。就好比这里订单服务A和支付服务B都收到协调者 发送的commit信息，开始真正执行本地事务commit,但突发情况，Acommit成功，B确挂了。这个时候目前来讲数据是不一致的。虽然这个时候可以再通过手段让他和协调者通信，再想办法把数据搞成一致的，但是，这段时间内他的数据状态已经是不一致的了！ 2PC 无法解决这个问题。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:5:4","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r2 2. tcc分布式事务 一个订单支付之后，我们需要做下面的步骤： 更改订单的状态为“已支付” 扣减商品库存 给会员增加积分 创建销售出库单通知仓库发货 [1] 订单服务-修改订单状态 [2] 库存服务-扣减库存 [3] 积分服务-增加积分 [4] 仓储服务-创建销售出库单。 上述这几个步骤，要么一起成功，要么一起失败，必须是一个整体性的事务。 举个例子，现在订单的状态都修改为“已支付”了，结果库存服务扣减库存失败。那个商品的库存原来是 100 件，现在卖掉了 2 件，本来应该是 98 件了。 结果呢？由于库存服务操作数据库异常，导致库存数量还是 100。这不是在坑人么，当然不能允许这种情况发生了！ 但是如果你不用 TCC 分布式事务方案的话，就用个 go开发这么一个微服务系统，很有可能会干出这种事儿来。 我们来看看下面的这个图，直观的表达了上述的过程： 所以说，我们有必要使用 TCC 分布式事务机制来保证各个服务形成一个整体性的事务。 上面那几个步骤，要么全部成功，如果任何一个服务的操作失败了，就全部一起回滚，撤销已经完成的操作。 比如说库存服务要是扣减库存失败了，那么订单服务就得撤销那个修改订单状态的操作，然后得停止执行增加积分和通知出库两个操作。 说了那么多，老规矩，给大家上一张图，大伙儿顺着图来直观的感受一下： 一句话就是有一个服务操作失败, 通知所有的服务回滚 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:6:0","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r3 3. 基于本地消息表的最终一致性 本地消息表这个方案最初是eBay提出的，此方案的核心是通过本地事务保证数据业务操作和消息的一致性，然后通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。 下面以注册送积分为例来说明 ：下例共有两个微服务交互，用户服务和积分服务，用户服务负责添加用户，积分服务负责增加积分。 交互流程如下 ： 1、用户注册 用户服务在本地事务新增用户和增加“积分消息日志”。（用户表和消息表通过本地事务保证一致） 下表是伪代码 begin transaction； // 1.新增用户 // 2.存储积分消息日志 commit transation； 这种情况下，本地数据库操作与存储积分消息日志处于同一事务中，本地数据库操作与记录消息日志操作具备原子性。 2、定时任务扫描日志 如何保证将消息发送给消息队列呢？ 经过第一步消息已经写到消息日志表中，可以启动独立的线程，定时对消息日志表中的消息进行扫描并发送至消息中间件，在消息中间件反馈发送成功后删除该消息日志，否则等待定时任务下一周期重试。 3、消费消息 如何保证消费者一定能消费到消息呢？ 这里可以使用MQ的ack（即消息确认）机制，消费者监听MQ，如果消费者接收到消息并且业务处理完成后向MQ发送ack（即消息确认），此时说明消费者正常消费消息完成，MQ将不再向消费者推送消息，否则消费者会不断重试向消费者来发送消息。 积分服务接收到“增加积分”消息，开始增加积分，积分增加成功后消息中间件回应ack，否则消息中间件将重复投递此消息。 由于消息会重复投递，积分服务的“增加积分”功能需要实现幂等性。 总结：上诉的方式是一种非常经典的实现，基本避免了分布式事务，实现了“最终一致性”。但是，关系型数据库的吞吐量和性能方面存在瓶颈，频繁的读写消息会给数据库造成压力。所以，在真正的高并发场景下，该方案也会有瓶颈和限制的。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:7:0","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r4 4. 基于可靠消息的最终一致性 !!!!!!!!! 也叫: 基于事务消息的最终一致性 RocketMQ是一个来自阿里巴巴的分布式消息中间件，于2012年开源，并在2017年正式成为Apache顶级项目。据了解，包括阿里云上的消息产品以及收购的子公司在内，阿里集团的消息产品全线都运行在RocketMQ之上，并且最近几年的双十一大促中，RocketMQ都有抢眼表现。Apache RocketMQ 4.3之后的版本正式支持事务消息，为分布式事务实现提供来便利性支持。 RocketMQ事务消息设计则主要是为了解决Producer端的消息发送与本地事务执行的原子性问题，RocketMQ的设计中broker与producer端的双向通信能力，使得broker天生可以作为一个事务协调者存在；而RocketMQ本身提供的存储机制为事务消息提供了持久化能力；RocketMQ的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性。 在RocketMQ 4.3后实现了完整的事务消息，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，解决Producer端的消息发送与本地事务执行的原子性问题。 ​ 执行流程如下 ： 为方便理解我们还以注册送积分的例子来描述整个流程。 Producer即MQ发送方，本例中是用户服务，负责新增用户。MQ订阅方即消息消费方，本例中是积分服务，负责新增积分。 1、Producer发送事务消息 Producer（MQ发送方）发送事务消息至MQ Server，MQ Server将消息状态标记为Prepared（预览状态），注意此时这条消息消费者（MQ订阅方）是无法消费到的。 2、MQ Server回应消息发送成功 MQ Server接收到Producer发送给的消息则回应发送成功表示MQ已接收到消息。 3、Producer执行本地事务 Producer端执行业务代码逻辑，通过本地数据库事务控制。 本例中，Producer执行添加用户操作。 4、消息投递 若Producer本地事务执行成功则自动向MQ Server发送commit消息，MQ Server接收到commit消息后将“增加积分消息”状态标记为可消费，此时MQ订阅方（积分服务）即正常消费消息； 若Producer 本地事务执行失败则自动向MQ Server发送rollback消息，MQ Server接收到rollback消息后将删除“增加积分消息”。 MQ订阅方（积分服务）消费消息，消费成功则向MQ回应ack，否则将重复接收消息。这里ack默认自动回应，即程序执行正常则自动回应ack。 5、事务回查 如果执行Producer端本地事务过程中，执行端挂掉，或者超时，MQ Server将会不停的询问同组的其他Producer来获取事务执行状态，这个过程叫事务回查。MQ Server会根据事务回查结果来决定是否投递消息。 以上主干流程已由RocketMQ实现，对用户则来说，用户需要分别实现本地事务执行以及本地事务回查方法，因此只需关注本地事务的执行状态即可。 RocketMQ 可靠消息, rebiitmQ 本地消息, RocketMQ比rebiitMQ的并发量大很多 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:8:0","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r5 5. 最大努力通知 最大努力通知也是一种解决分布式事务的方案，下边是一个是充值的例子： 交互流程: 1、账户系统调用充值系统接口 2、充值系统完成支付处理向账户系统发起充值结果通知，若通知失败，则充值系统按策略进行重复通知 3、账户系统接收到充值结果通知修改充值状态。 4、账户系统未接收到通知会主动调用充值系统的接口查询充值结果。 通过上边的例子我们总结最大努力通知方案的目标： 目标：发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。 具体包括： 1、有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。 2、消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。 最大努力通知与可靠消息一致性有什么不同？ 1、解决方案思想不同 可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。 最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。 ​ 2、两者的业务应用场景不同 可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。 最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。 ​ 3、技术解决方向不同 可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。 最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制是，最大努力的将消息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果）。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180123/:9:0","tags":null,"title":"3.分布式从ACID、CAP、BASE的理论推进","uri":"/lang/go/go_advanced/20250515180123/"},{"categories":null,"content":"\r一. 流, I/O操作, 阻塞","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:0:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r1 1. 流 可以进行I/O操作的内核对象 文件、管道、套接字…… 流的入口：文件描述符(fd) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:1:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r2 2. I/O操作 所有对流的读写操作，我们都可以称之为IO操作。 当一个流中， 在没有数据read的时候，或者说在流中已经写满了数据，再write，我们的IO操作就会出现一种现象，就是阻塞现象，如下图。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:2:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r3 3. 阻塞 阻塞场景: 你有一份快递，家里有个座机，快递到了主动给你打电话，期间你可以休息。 非阻塞，忙轮询场景: 你性子比较急躁， 每分钟就要打电话询问快递小哥一次， 到底有没有到，快递员接你电话要停止运输，这样很耽误快递小哥的运输速度。 阻塞等待 空出大脑可以安心睡觉, 不影响快递员工作（不占用CPU宝贵的时间片）。 非阻塞，忙轮询 浪费时间，浪费电话费，占用快递员时间（占用CPU，系统资源）。 很明显，阻塞等待这种方式，对于通信上是有明显优势的， 那么它有哪些弊端呢？ 二. IO多路复用","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:3:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r1 1. 阻塞IO 就像 socket 通信一样, 连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。就会发生IO阻塞 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:4:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r2 2. 非阻塞 IO 恳请操作系统为我们提供一个非阻塞的 read 函数。通过轮询或者回调的方法实现 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:5:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r3 3. IO多路复用 doc: https://mp.weixin.qq.com/s/kebjG5UosHmXa7AKCatSrA 实现IO多路复用的方法: select : 通过遍历(系统遍历)的方式实现, select 只能监听 1024 个文件描述符. windows,linux poll: 通过遍历(系统遍历)的方式实现, 不再有文件描述符数量限制. linux epoll: 通过回调的方式实现IO多路复用, 没有文件描述符限制, 效率最高. linux ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:6:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r3.1 3.1 select 系统遍历 select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制） select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知） select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历） 我们可以开设一个代收网点，让快递员全部送到代收点。这个网店管理员叫select。这样我们就可以在家休息了，麻烦的事交给select就好了。当有快递的时候，select负责给我们打电话，期间在家休息睡觉就好了。 但select 代收员比较懒，她记不住快递员的单号，还有快递货物的数量。她只会告诉你快递到了，但是是谁到的，你需要挨个快递员问一遍。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:6:1","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r3.2 3.2 poll 系统遍历 poll 也是操作系统提供的系统调用函数。 它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:6:2","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r3.3 3.2 epoll 回调(异步 IO 事件唤醒) 内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。 内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。 内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。 三.底层原理","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:6:3","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r1 1 单进程单socket的弊端 服务端需要管理多个客户端连接，而 recv() 系统调用只能监视单个socket。 这种情况下，如果要管理多个客户端连接，就需要多开进程或线程，每个进程维护一个socket套接字，没有网络数据时进程阻塞在recv()系统调用上，当网络数据到达时，操作系统环境对应socket等待队列上的进程。 此时面临的问题是维护进程或线程带来的系统开销（每个线程的栈空间8M，由于系统的内存资源有限，1K个线程就已经需要消耗8G内存，不可能无限制的多开线程，且进程、线程间的频繁切换也会带来较大的开销）。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:7:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r2 2 select的设计思想 最先想到的办法是使用一个进程监视多个socket，预先传入一个socket列表，如果列表中的socket都没有数据，则进程继续挂起；直到有一个或以上的socket接收到网络数据，再唤醒进程。这种方法很直接，这也是select的设计思想。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:8:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r2.1 2.1 select的执行流程 如下图，假设进程A同时监听 sock1、sock2、sock3（通过fd_set传入），那么，在调用select之后，操作系统会把进程A分别加入到这三个socket的等待队列中： 当任何一个socket上收到数据时，中断程序将唤起进程。所谓唤起进程，就是将其从所有的socket对象的等待队列中移除，并插入到就绪队列中。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:8:1","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r2.2 2.2 select的缺点 每次调用select都需要将进程加入到所有socket对象的等待队列中，每次唤醒进程又要将进程从所有socket对象的等待队列中移除。这里涉及到对socket列表的两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正因为遍历操作开销大，出于效率的考量，才会规定select的最大监视数量，默认只能监视1024个socket（强行修改也是可以的）； 进程被唤醒后，程序并不知道socket列表中的那些socket上收到数据，因此在用户空间内需要对socket列表再做一次遍历。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:8:2","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r3 3 epoll的设计思想","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:9:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r3.1 3.1 epoll的实现原理和流程 创建epoll对象： 当进程调用 epoll_create 方法时，内核会创建一个 eventpoll 对象，也就是应用程序中的 epfd 所代表的对象。eventpoll 对象也是文件系统中的一员（Linux中一切设备皆文件），和socket一样也拥有一个“等待队列”。 维护监视列表： 创建epoll对象 eventpoll 之后，可以使用 epoll_ctl 添加或者删除所要监听的socket。以添加socket为例，如果要对sock1、sock2、sock3进行监视，内核会将eventpoll添加到这三个socket的等待队列中。 当socket收到数据后，中断回调程序会操作eventpoll对象，而不是直接操作进程。 接收数据： select的低效原因之一在于应用程序不知道哪些socket收到数据，只能一个个的遍历。如果内核维护一个“就绪列表”，在就绪列表中引用收到数据的socket，就能避免遍历。 在 eventpoll 对象中就实现了这样的一个“就绪列表” —- rdlist。 当socket收到数据，中断回调程序会给eventpoll的“就绪列表”添加socket的引用，如下图所示： eventpoll对象相当于是socket和进程之间的中介，socket的数据接收并不直接影响进程，而是通过改变eventpoll的就绪列表来改变进程状态。 epoll_wait的返回条件也是根据rdlist的状态进行判断： 如果rdlist已经引用了socket，那么epoll_wait直接返回； 如果rdlist为空，阻塞进程。 阻塞和唤醒进程： 如下图，假设当进程A运行到epoll_wait()时，操作系统会将进程A放入到eventpoll对象的等待队列中，阻塞进程。（对于epoll，操作系统只需要将进程A放入eventpoll这一个对象的等待队列中；而对于select，操作系统则需要将进程A放入到socket列表中的所有socket对象的等待队列中。） 当socket接收到数据时，中断回调程序一方面修改rdlist“就绪列表”，另一方面唤醒eventpoll等待队列中的进程A。 也因为rdlist就绪列表的存在，进程A可以在重新进入运行态后准确知道哪些socket上发生了变化。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:9:1","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r3.2 3.2 epoll高效的原因 相较于select，epoll实现高效主要基于以下两点： 功能分离； 就绪列表。 select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。 每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket相对固定，并不需要每次修改。 epoll将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程，以此来提高效率。 select低效的另一个原因在于程序不知道哪些socket收到数据，只能一个一个的遍历。如果内核维护一个“就绪列表”，引用收到的数据的socket，就能避免遍历。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:9:2","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r3.3 3.3 epoll的实现细节\r3.3.1 a. eventpoll对象的数据结构 eventpoll对象包含了：lock、mtx、wq（等待队列）、rdlist 等成员。 3.3.2 b. rdlist就绪队列的数据结构： epoll使用双向链表来实现就绪队列rdlist。 3.3.3 c. 索引结构： epoll使用红黑树作为索引结构，以便于快速的插入和删除要监视的socket套接字。 红黑树时一种自平衡的二叉查找树，搜索、插入、删除的时间复杂度都是O(logN)。 四. CPU密集型和IO密集型","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:9:3","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r1 CPU密集型CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作CPU读写IO(硬盘/内存)时，IO可以在很短的时间内完成，而CPU还有许多运算要处理，因此，CPU负载很高。 CPU密集表示该任务需要大量的运算，而没有阻塞，CPU一直全速运行。CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程），而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就只有这么多。 CPU使用率较高（例如:计算圆周率、对视频进行高清解码、矩阵运算等情况）的情况下，通常，线程数只需要设置为CPU核心数的线程个数就可以了。 这一情况多出现在一些业务复杂的计算和逻辑处理过程中。比如说，现在的一些机器学习和深度学习的模型训练和推理任务，包含了大量的矩阵运算。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:10:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r2 IO密集型IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等IO (硬盘/内存) 的读写操作，因此，CPU负载并不高。 密集型的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而程序的逻辑做得不是很好，没有充分利用处理器能力。 CPU 使用率较低，程序中会存在大量的 I/O 操作占用时间，导致线程空余时间很多，通常就需要开CPU核心数数倍的线程。 其计算公式为：IO密集型核心线程数 = CPU核数 / （1-阻塞系数）。 当线程进行 I/O 操作 CPU 空闲时，启用其他线程继续使用 CPU，以提高 CPU 的使用率。例如：数据库交互，文件上传下载，网络传输等。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:11:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r3 CPU密集型与IO密集型任务的使用说明 当线程等待时间所占比例越高，需要越多线程，启用其他线程继续使用CPU，以此提高CPU的利用率； 当线程CPU时间所占比例越高，需要越少的线程，通常线程数和CPU核数一致即可，这一类型在开发中主要出现在一些计算业务频繁的逻辑中。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:12:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r4 CPU密集型任务与IO密集型任务的区别计算密集型任务的特点是要进行大量的计算，消耗CPU资源，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数，避免线程或进程的切换。 计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。 IO密集型任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。涉及到网络、磁盘IO的任务都是IO密集型任务， 对于IO密集型任务，线程数越多，CPU效率越高，但也有一个限度。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:13:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r5 go适合的IO密集型 推荐博文：https://mp.weixin.qq.com/s/eSlv61fR61SQTt3iTgzbPQ ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:14:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r6 总结 一个计算为主的应用程序（CPU密集型程序），多线程或多进程跑的时候，可以充分利用起所有的 CPU 核心数，比如说16核的CPU ，开16个线程的时候，可以同时跑16个线程的运算任务，此时是最大效率。但是如果线程数/进程数远远超出 CPU 核心数量，反而会使得任务效率下降，因为频繁的切换线程或进程也是要消耗时间的。因此对于 CPU 密集型的任务来说，线程数/进程数等于 CPU 数是最好的了。 如果是一个磁盘或网络为主的应用程序（IO密集型程序），一个线程处在 IO 等待的时候，另一个线程还可以在 CPU 里面跑，有时候 CPU 闲着没事干，所有的线程都在等着 IO，这时候他们就是同时的了，而单线程的话，此时还是在一个一个等待的。我们都知道IO的速度比起 CPU 来是很慢的。此时线程数可以是CPU核心数的数倍（视情况而定）。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180119/:15:0","tags":null,"title":"2-1.流和IO多路复用","uri":"/lang/go/go_advanced/20250515180119/"},{"categories":null,"content":"\r1 前戏：”链接“基础概念 参考文章：http://blog.champbay.com/2019/11/25/%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e9%9d%99%e6%80%81%e5%ba%93%e5%85%b1%e4%ba%ab%e5%ba%93%e8%bf%99%e4%ba%9b%e6%a6%82%e5%bf%b5%e7%9a%84%e8%af%a6%e8%a7%a3/ ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180114/:1:0","tags":null,"title":"1-12. go链接参数 ldflags","uri":"/lang/go/go_advanced/20250515180114/"},{"categories":null,"content":"\r2 ldflags 用于链接过程 通过命令go tool dist list查看go支持的平台： aix/ppc64, android/386, android/amd64, android/arm, android/arm64, darwin/amd64, darwin/arm64, dragonfly/amd64, freebsd/386, freebsd/amd64, freebsd/arm, freebsd/arm64, illumos/amd64, ios/amd64, ios/arm64, js/wasm, linux/386, linux/amd64, linux/arm, linux/arm64, linux/mips, linux/mips64, linux/mips64le, linux/mipsle, linux/ppc64, linux/ppc64le, linux/riscv64, linux/s390x, netbsd/386, netbsd/amd64, netbsd/arm, netbsd/arm64, openbsd/386, openbsd/amd64, openbsd/arm, openbsd/arm64, openbsd/mips64, plan9/386, plan9/amd64, plan9/arm, solaris/amd64, windows/386, windows/amd64, windows/arm, windows/arm64 大佬的文章： https://tonybai.com/2017/06/27/an-intro-about-go-portability/ ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180114/:2:0","tags":null,"title":"1-12. go链接参数 ldflags","uri":"/lang/go/go_advanced/20250515180114/"},{"categories":null,"content":"\r3 配置go应用和变量 参数 -w 去掉调试信息 -s 去掉符号表 -X 注入变量, 编译时赋值 使用范围：go install 、go build、go run 、go test 编译 ‘${GO_PATH}/main.go’ package main var B int func main(){ fmt.Println(B) } 编译 go build -ldflags '-w -s -X ${GO_PATH}/main.B=100' -o main main.go 运行二进制文件输出：100 使用变量 Module=github.com/pubgo/xxx GOPATH=$(shell go env GOPATH) Version=$(shell git tag --sort=committerdate | tail -n 1) GoVersion=$(shell go version) BuildTime=$(shell date \"+%F %T\") CommitID=$(shell git rev-parse HEAD) LDFLAGS:=-ldflags \"-X 'github.com/pubgo/xxx/version.GoVersion=${GoVersion}' \\ -X 'github.com/pubgo/xxx/version.BuildTime=${BuildTime}' \\ -X 'github.com/pubgo/xxx/version.GoPath=${GOPATH}' \\ -X 'github.com/pubgo/xxx/version.CommitID=${CommitID}' \\ -X 'github.com/pubgo/xxx/version.Module=${Module}' \\ -X 'github.com/pubgo/xxx/version.Version=${Version:-v0.0.1}'\" // go build ${LDFLAGS} -mod vendor -race -v -o main main.go ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180114/:3:0","tags":null,"title":"1-12. go链接参数 ldflags","uri":"/lang/go/go_advanced/20250515180114/"},{"categories":null,"content":" go支持两种条件编译的实现方式 编译标签（build tags） //go:build !windows 和 // +build !windows 文件后缀 条件编译的应用场景 平台适配：不同平台的操作系统和 CPU 架构可能有不同的特性和限制，需要针对不同平台编写不同的代码。通过条件编译，可以根据不同平台选择不同的代码进行编译，从而提高程序的性能和稳定性。 调试信息：在开发和调试过程中，需要添加一些调试信息来辅助开发人员定位问题。但是，在发布版本时这些信息不应该包含在内。使用条件编译，可以在开发和调试阶段包含调试信息，在发布版本中去除这些信息。 功能开关：有些功能可能只在特定的场景下使用，而在其他场景下不需要。使用条件编译可以根据编译标记开启或关闭这些功能，从而减少程序的代码量和复杂度。 性能优化：有些代码可能只在特定的环境下才能发挥最优性能。使用条件编译，可以根据编译标记选择不同的代码实现，从而提高程序的性能。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180101/:0:0","tags":null,"title":"1-11. go条件编译","uri":"/lang/go/go_advanced/20250515180101/"},{"categories":null,"content":"\r1 编译标签（build tags）","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180101/:1:0","tags":null,"title":"1-11. go条件编译","uri":"/lang/go/go_advanced/20250515180101/"},{"categories":null,"content":"\r1.1 1. //go:build 和 // +build 的区别 // +build编译条件的注释和package 语句之间一定要隔一行。不然无法识别编译条件，编译条件支持“非”逻辑，比如某个文件在非 windows 环境下编译 //go:build是Go 1.17中引入的新的条件编译指令，旨在取代// +build指令，因为新语法带来了一些关键改进： 与其他现有Go指令和pragma的一致性，例如//go:generate 支持标准布尔表达式，例如//go:build foo \u0026\u0026 bar，而旧的// +build注释的语法不那么直观。例如，AND用逗号// +build foo,bar和或空格// +build foo bar表示 它由go fmt支持，它将自动修复指令在源文件中的错误位置，从而避免常见错误，如在指令和包语句之间不留空行。 在Go 1.N中： 生成将开始优先选择//go:build行进行文件选择。如果文件中没有//go:build，那么任何// +build行仍然适用。 如果Go文件包含//go:build而没有// +build，则构建将不再失败。 如果Go或程序集文件中包含//go:build太晚，则生成将失败。Gofmt将把错位的//go:build和//+build行移到文件中的正确位置。 Gofmt将使用与其他Go布尔表达式（所有\u0026\u0026和||运算符周围的空格）相同的规则格式化//go:build行中的表达式。 如果文件只包含// +build行，则gofmt将在其上方添加一个等效的//go:build行。 如果一个文件同时包含//go:build和// +build行，则gofmt将考虑//go:build是真理的来源，并更新// +build行以匹配，从而保持与早期版本的Go的兼容性。Gofmt还将拒绝被认为太复杂而无法转换为// +build格式的//go:build行，尽管这种情况很少见。（注意此项目符号开头的“If”。Gofmt不会将// +build行添加到只有//go:build.的文件中） buildtags签入go vet将添加对//go:build约束的支持。当Go源文件包含具有不同含义的//go:build和// +build行时，它将失败。如果检查失败，可以运行gofmt -w。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180101/:1:1","tags":null,"title":"1-11. go条件编译","uri":"/lang/go/go_advanced/20250515180101/"},{"categories":null,"content":"\r1.2 2. 使用说明 基础语法 // +build \u003ctag1\u003e \u003ctag2\u003e \u003ctag3\u003e ... 或者是 //go:build \u003ctag1\u003e \u003ctag2\u003e \u003ctag3\u003e ... 编译的时候 go build -tag1 mytag2 mytag3 \u003ctag\u003e 可以是操作系统、CPU 架构、编译标记等，多个标记之间用空格分隔或者都好分隔。 编译标签由空格分隔的编译选项(options)以”或”的逻辑关系组成 每个编译选项由逗号分隔的条件项以逻辑”与”的关系组成 每个条件项的名字用字母+数字表示，在前面加!表示否定的意思 不同tag域之间用空格区分，他们是OR关系 同一tag域之内不同的tag用都好区分，他们是AND关系 每一个tag都由字母和数字构成，！开头表示条件“非” // +build linux darwin // +build 386 一个源文件里可以有多个编译标签，多个编译标签之间是逻辑”与”的关系 关系 空格表示：AND 逗号表示：OR !表示：NOT 换行表示：AND 内置 tag 指定操作系统：如 darwin、linux、windows 等，对应 runtime.GOOS 的值。 指定CPU 架构：如 amd64、arm、386 等，对应 runtime.GOARCH 的值。 指定编译器：例如：gccgo、gc，是否开启CGO,cgo。 指定Go 版本：例如：go1.19、go1.20 等。 // +build ignore，编译时自动忽略该文件 demo // +build linux,arm !darwin 表示该文件在 Linux 平台且 ARM 架构下编译，但不在 Darwin 平台下编译。 自定义tag, // +build mytag 编译的时候go build -tags mytag才会编译此文件 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180101/:1:2","tags":null,"title":"1-11. go条件编译","uri":"/lang/go/go_advanced/20250515180101/"},{"categories":null,"content":"\r1.3 3. 注意事项 // +build 或者 //go:build 指令必须放在文件的开头。 // +build 或者 //go:build 指令只能出现一次，且只能针对整个文件进行编译，不能对单独的函数或变量进行编译。 标记中的操作系统和 CPU 架构必须使用官方定义的名称，否则编译器无法识别。 在编写代码时，应该尽量避免使用条件编译，以保持代码的简洁和易读性。 在使用编译标记时，应该尽量使用官方定义的标记，避免与其他库或框架的标记冲突。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180101/:1:3","tags":null,"title":"1-11. go条件编译","uri":"/lang/go/go_advanced/20250515180101/"},{"categories":null,"content":"\r2 文件后缀 这个方法通过改变文件名的后缀来提供条件编译，这种方案比编译标签要简单很多 go/build可以在不读取源文件的情况下就可以决定哪些文件不需要参与编译。 简单来说，就是源文件包含后缀：$GOOS.go，那么这个源文件只会在这个平台下编译，$GOARCH.go也是如此。 demo mygo_freebsd_arm.go // only builds on freebsd/arm systems mygo_plan9.go // only builds on plan9 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180101/:2:0","tags":null,"title":"1-11. go条件编译","uri":"/lang/go/go_advanced/20250515180101/"},{"categories":null,"content":"\r1 什么是内联？ 内联是将较小的函数合并到它们各自的调用者中的行为。其在不同的计算历史时期的做法不一样，如下： 早期：这种优化通常是由手工完成的。 现在：内联是在编译过程中自动进行的一类基本优化之一。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180055/:1:0","tags":null,"title":"1-10. 内联优化","uri":"/lang/go/go_advanced/20250515180055/"},{"categories":null,"content":"\r2 为什么内联很重要？ 内联是很重要的，每一门语言都必然会有。具体的原因如下： 它消除了函数调用本身的开销。 它允许编译器更有效地应用其他优化策略。 核心来讲，就是性能更好了。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180055/:2:0","tags":null,"title":"1-10. 内联优化","uri":"/lang/go/go_advanced/20250515180055/"},{"categories":null,"content":"\r3 函数调用的开销","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180055/:3:0","tags":null,"title":"1-10. 内联优化","uri":"/lang/go/go_advanced/20250515180055/"},{"categories":null,"content":"\r3.1 a. 基本知识 在任何语言中调用一个函数都是有代价的。将参数编入寄存器或堆栈（取决于ABI），并在返回时反转这一过程，这些都是开销。 调用一个函数需要将程序计数器从指令流中的一个点跳到另一个点，这可能会导致流水线停滞。 一旦进入函数，通常需要一些前言来为函数的执行准备一个新的堆栈框架，在返回调用者之前，还需要一个类似的尾声来退掉这个框架。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180055/:3:1","tags":null,"title":"1-10. 内联优化","uri":"/lang/go/go_advanced/20250515180055/"},{"categories":null,"content":"\r3.2 b. Go 中的开销和优化 在 Go 中，一个函数的调用需要额外的成本来支持动态堆栈的增长。在进入时，goroutine 可用的堆栈空间的数量与函数所需的数量进行比较。 如果可用的堆栈空间不足，前言就会跳转到运行时逻辑，通过将堆栈复制到一个新的、更大的位置来增加堆栈。 消除这些开销的解决方案必须是消除函数调用本身，Go 编译器在某些条件下通过用函数的内容替换对函数的调用来做到这一点，这被称为内联。因为它使函数的主体与它的调用者保持一致。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180055/:3:2","tags":null,"title":"1-10. 内联优化","uri":"/lang/go/go_advanced/20250515180055/"},{"categories":null,"content":"\r4 进行内联优化","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180055/:4:0","tags":null,"title":"1-10. 内联优化","uri":"/lang/go/go_advanced/20250515180055/"},{"categories":null,"content":"\r4.1 a. 不允许内联 内联的效果可以通过这个小例子来证明： package main import \"testing\" //go:noinline func max(a, b int) int { if a \u003e b { return a } return b } var Result int func BenchmarkMax(b *testing.B) { var r int for i := 0; i \u003c b.N; i++ { r = max(-1, i) } Result = r } 运行这个基准可以得到以下结果： % go test -bench=. BenchmarkMax-4 530687617 2.24 ns/op 从执行结果来看，max(-1, i)的成本大约是 2.24ns，感觉性能不错。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180055/:4:1","tags":null,"title":"1-10. 内联优化","uri":"/lang/go/go_advanced/20250515180055/"},{"categories":null,"content":"\r4.2 b. 允许内联 现在让我们去掉 //go:noinline pragma 的语句，再看看不允许内联的情况下，性能是否会改变。 如下结果： % go test -bench=. BenchmarkMax-4 1000000000 0.514 ns/op 两个结果对比一看，2.24ns 和 0.51ns。差距至少一倍以上。 另外根据 benchstat 的建议，在内联情况下，性能提高了 78%。 如下结果： % benchstat {old,new}.txt name old time/op new time/op delta Max-4 2.21ns ± 1% 0.49ns ± 6% -77.96% (p=0.000 n=18+19) ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180055/:4:2","tags":null,"title":"1-10. 内联优化","uri":"/lang/go/go_advanced/20250515180055/"},{"categories":null,"content":"\r1 基础知识 在Go语言中，我们可以通过 unsafe.Sizeof(x) 来确定一个变量占用的内存字节数（不包含 x 所指向的内容的大小）。 例如对于字符串数组，在64位机器上，unsafe.Sizeof() 返回的任意字符串数组大小为 24 字节，和其底层数据无关： func main() { s := []string{\"1\", \"2\", \"3\"} s2 := []string{\"1\"} fmt.Println(unsafe.Sizeof(s)) // 24 fmt.Println(unsafe.Sizeof(s2)) // 24 } 对于Go语言的内置类型，占用内存大小如下： 类型 字节数 bool 1个字节 intN, uintN, floatN, complexN N/8 个字节 （int32 是 4 个字节） int, uint, uintptr 计算机字长/8 (64位 是 8 个字节) *T, map, func, chan 计算机字长/8 (64位 是 8 个字节) string （data、len） 2 * 计算机字长/8 (64位 是 16 个字节) interface (tab、data 或 _type、data) 2 * 计算机字长/8 (64位 是 16 个字节) []T (array、len、cap) 3 * 计算机字长/8 (64位 是 24 个字节) func main() { fmt.Println(unsafe.Sizeof(int(1))) // 8 fmt.Println(unsafe.Sizeof(uintptr(1))) // 8 fmt.Println(unsafe.Sizeof(map[string]string{})) // 8 fmt.Println(unsafe.Sizeof(string(\"\"))) // 16 fmt.Println(unsafe.Sizeof([]string{})) // 24 var a interface{} fmt.Println(unsafe.Sizeof(a)) // 16 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:1:0","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r2 内存对齐引入 基于上面的理解，那么对于一个结构体来说，占用内存大小就应该等于多个基础类型占用内存大小的和，我们就结合几个示例来看下： type Example struct { a bool // 1个字节 b int // 8个字节 c string // 16个字节 } func main() { fmt.Println(unsafe.Sizeof(Example{})) // 32 } Example 结构体的三个基础类型，加起来一个 25字节，但是最终输出的却是 32字节。 我们再看两个结构体，即使这两个结构体包含的字段类型一致，但是顺序不一致，最终输出的大小也不一样： type A struct { a int32 b int64 c int32 } type B struct { a int32 b int32 c int64 } func main() { fmt.Println(unsafe.Sizeof(A{})) // 24 fmt.Println(unsafe.Sizeof(B{})) // 16 } 是什么导致了上述问题的呢，这就引出了我们要看的知识点：内存对齐。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:2:0","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r3 内存对齐","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:3:0","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r3.1 1. 什么是内存对齐 在计算机中访问一个变量，需要访问它的内存地址，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是：在访问特定类型变量的时候通常在特定的内存地址访问，这就需要对这些数据在内存中存放的位置有限制，各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。 内存对齐是编译器的管辖范围。表现为：编译器为程序中的每个“数据单元”安排在适当的位置上。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:3:1","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r3.2 2. 为什么需要内存对齐 有些CPU可以访问任意地址上的任意数据，而有些CPU只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了。 CPU 访问内存时并不是逐个字节访问，而是以字长（word size）为单位访问，例如 32位的CPU 字长是4字节，64位的是8字节。如果变量的地址没有对齐，可能需要多次访问才能完整读取到变量内容，而对齐后可能就只需要一次内存访问，因此内存对齐可以减少CPU访问内存的次数，加大CPU访问内存的吞吐量。 假设每次访问的步长为4个字节，如果未经过内存对齐，获取b的数据需要进行两次内存访问，最后再进行数据整理得到b的完整数据： 如果经过内存对齐，一次内存访问就能得到b的完整数据，减少了一次内存访问： ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:3:2","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r4 unsafe.AlignOf() unsafe.AlignOf(x) 方法的返回值是 m，当变量进行内存对齐时，需要保证分配到 x 的内存地址能够整除 m。因此可以通过这个方法，确定变量x 在内存对齐时的地址： 对于任意类型的变量 x ，unsafe.Alignof(x) 至少为 1。 对于 struct 结构体类型的变量 x，计算 x 每一个字段 f 的 unsafe.Alignof(x.f)，unsafe.Alignof(x) 等于其中的最大值。 对于 array 数组类型的变量 x，unsafe.Alignof(x) 等于构成数组的元素类型的对齐倍数。 对于系统内置基础类型变量 x ，unsafe.Alignof(x) 的返回值就是 min(字长/8，unsafe.Sizeof(x))，即计算机字长与类型占用内存的较小值: func main() { fmt.Println(unsafe.Alignof(int(1))) // 1 -- min(8,1) fmt.Println(unsafe.Alignof(int32(1))) // 4 -- min (8,4) fmt.Println(unsafe.Alignof(int64(1))) // 8 -- min (8,8) fmt.Println(unsafe.Alignof(complex128(1))) // 8 -- min(8,16) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:4:0","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r5 内存对齐规则 成员对齐规则: 针对一个基础类型变量，如果 unsafe.AlignOf() 返回的值是 m，那么该变量的地址需要 被m整除 （如果当前地址不能整除，填充空白字节，直至可以整除）。 整体对齐规则 针对一个结构体，如果 unsafe.AlignOf() 返回值是 m，需要保证该结构体整体内存占用是 m的整数倍，如果当前不是整数倍，需要在后面填充空白字节。 通过内存对齐后，就可以在保证在访问一个变量地址时： 如果该变量占用内存小于字长：保证一次访问就能得到数据； 如果该变量占用内存大于字长：保证第一次内存访问的首地址，是该变量的首地址。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:5:0","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r6 示例","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:6:0","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r6.1 1. 结构体一 type A struct { a int32 b int64 c int32 } func main() { fmt.Println(unsafe.Sizeof(A{1, 1, 1})) // 24 } 第一个字段是 int32 类型，unsafe.Sizeof(int32(1))=4，内存占用为4个字节，同时unsafe.Alignof(int32(1)) = 4，内存对齐需保证变量首地址可以被4整除，我们假设地址从0开始，0可以被4整除： 第二个字段是 int64 类型，unsafe.Sizeof(int64(1)) = 8，内存占用为 8 个字节，同时unsafe.Alignof(int64(1)) = 8，需保证变量放置首地址可以被8整除，当前地址为4，距离4最近的且可以被8整除的地址为8，因此需要添加四个空白字节，从8开始放置： 第三个字段是 int32 类型，unsafe.Sizeof(int32(1))=4，内存占用为4个字节，同时unsafe.Alignof(int32(1)) = 4，内存对齐需保证变量首地址可以被4整除，当前地址为16，16可以被4整除： 所有成员对齐都已经完成，现在我们需要看一下整体对齐规则：unsafe.Alignof(A{}) = 8，即三个变量成员的最大值，内存对齐需要保证该结构体的内存占用是 8 的整数倍，当前内存占用是 20个字节，因此需要再补充4个字节： 最终该结构体的内存占用为 24字节。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:6:1","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r6.2 2. 结构体二 type B struct { a int32 b int32 c int64 } func main() { fmt.Println(unsafe.Sizeof(B{1, 1, 1})) // 16 } 第一个字段是 int32 类型，unsafe.Sizeof(int32(1))=4，内存占用为4个字节，同时unsafe.Alignof(int32(1)) = 4，内存对齐需保证变量首地址可以被4整除，我们假设地址从0开始，0可以被4整除： 第二个字段是 int32 类型，unsafe.Sizeof(int32(1))=4，内存占用为4个字节，同时unsafe.Alignof(int32(1)) = 4，内存对齐需保证变量首地址可以被4整除，当前地址为4，4可以被4整除： 第三个字段是 int64 类型，unsafe.Sizeof(int64(1))=8，内存占用为8个字节，同时unsafe.Alignof(int64(1)) = 8，内存对齐需保证变量首地址可以被8整除，当前地址为8，8可以被8整除： 所有成员对齐都已经完成，现在我们需要看一下整体对齐规则：unsafe.Alignof(B{}) = 8，即三个变量成员的最大值，内存对齐需要保证该结构体的内存占用是 8 的整数倍，当前内存占用是 16个字节，已经符合规则，最终该结构体的内存占用为 16个字节。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:6:2","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r7 空结构体的对齐规则 如果空结构体作为结构体的内置字段：当变量位于结构体的前面和中间时，不会占用内存；当该变量位于结构体的末尾位置时，需要进行内存对齐，内存占用大小和前一个变量的大小保持一致。 type C struct { a struct{} b int64 c int64 } type D struct { a int64 b struct{} c int64 } type E struct { a int64 b int64 c struct{} } type F struct { a int32 b int32 c struct{} } func main() { fmt.Println(unsafe.Sizeof(C{})) // 16 fmt.Println(unsafe.Sizeof(D{})) // 16 fmt.Println(unsafe.Sizeof(E{})) // 24 fmt.Println(unsafe.Sizeof(F{})) // 12 } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:7:0","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r8 总结 unsafe.Sizeof(x) 返回了变量x的内存占用大小 两个结构体，即使包含变量类型的数量相同，但是位置不同，占用的内存大小也不同，由此引出了内存对齐 内存对齐包含成员对齐和整体对齐，与 unsafe.AlignOf(x) 息息相关 空结构体作为成员变量时，是否占用内存和所处位置有关 在实际开发中，我们可以通过调整变量位置，优化内存占用（一般按照变量内存大小顺序排列，整体占用内存更小） ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180051/:8:0","tags":null,"title":"1-9.Go语言内存对齐","uri":"/lang/go/go_advanced/20250515180051/"},{"categories":null,"content":"\r1 1. Golang go 深拷贝， 就是拷贝值 go 浅拷贝， 拷贝引用 go中赋值就能实现拷贝，针对引用类型（slice，map，channel）是浅拷贝，对值类型是深拷贝 1、深拷贝（Deep Copy）： 拷贝的是数据本身，创造一个样的新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放。 值类型的数据，默认全部都是深复制，Array、Int、String、Struct、Float，Bool。 2、浅拷贝（Shallow Copy）： 拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。释放内存地址时，同时释放内存地址。 引用类型的数据，默认全部都是浅复制，Slice，Map, channel。 二、本质区别： 是否真正获取（复制）对象实体，而不是引用。 三、如何理解？ 这里举个例子，比如P2复制了P1，修改P1属性的时候，观察P2的属性是否会产生变化 1、P2的属性变化了，说明这是浅拷贝，堆中内存还是同一个值。 p2=\u0026p1 // 浅拷贝，p2为指针，p1和p2共用一个内存地址 2、P2的属性没变化，说明这是深拷贝，堆中内存是不同的值了。 p2=p1 // 深拷贝，生成两个内存地址 四、演示示例： 深拷贝示例： package main import ( \"fmt\" ) // 定义一个Robot结构体 type Robot struct { Name string Color string Model string } func main() { fmt.Println(\"深拷贝 内容一样，改变其中一个对象的值时，另一个不会变化。\") robot1 := Robot{ Name: \"小白-X型-V1.0\", Color: \"白色\", Model: \"小型\", } robot2 := robot1 fmt.Printf(\"Robot 1：%s\\t内存地址：%p \\n\", robot1, \u0026robot1) fmt.Printf(\"Robot 2：%s\\t内存地址：%p \\n\", robot2, \u0026robot2) fmt.Println(\"修改Robot1的Name属性值\") robot1.Name = \"小白-X型-V1.1\" fmt.Printf(\"Robot 1：%s\\t内存地址：%p \\n\", robot1, \u0026robot1) fmt.Printf(\"Robot 2：%s\\t内存地址：%p \\n\", robot2, \u0026robot2) } 运行结果： 深拷贝 内容一样，改变其中一个对象的值时，另一个不会变化。 Robot 1：{小白-X型-V1.0 白色 小型} 内存地址：0xc000072330 Robot 2：{小白-X型-V1.0 白色 小型} 内存地址：0xc000072360 修改Robot1的Name属性值 Robot 1：{小白-X型-V1.1 白色 小型} 内存地址：0xc000072330 Robot 2：{小白-X型-V1.0 白色 小型} 内存地址：0xc000072360 深拷贝中，我们可以看到Robot1号的地址与Robot2号的内存地址是不同的，修改Robot1号的Name属性时，Robot2号不会变化。 浅拷贝我们用两种方式来介绍。 浅拷贝示例1： package main import ( \"fmt\" ) // 定义一个Robot结构体 type Robot struct { Name string Color string Model string } func main() { fmt.Println(\"浅拷贝 内容和内存地址一样，改变其中一个对象的值时，另一个同时变化。\") robot1 := Robot{ Name: \"小白-X型-V1.0\", Color: \"白色\", Model: \"小型\", } robot2 := \u0026robot1 fmt.Printf(\"Robot 1：%s\\t内存地址：%p \\n\", robot1, \u0026robot1) fmt.Printf(\"Robot 2：%s\\t内存地址：%p \\n\", robot2, robot2) fmt.Println(\"在这里面修改Robot1的Name和Color属性\") robot1.Name = \"小黑-X型-V1.1\" robot1.Color = \"黑色\" fmt.Printf(\"Robot 1：%s\\t内存地址：%p \\n\", robot1, \u0026robot1) fmt.Printf(\"Robot 2：%s\\t内存地址：%p \\n\", robot2, robot2) } 运行结果1： 浅拷贝 内容和内存地址一样，改变其中一个对象的值时，另一个同时变化。 Robot 1：{小白-X型-V1.0 白色 小型} 内存地址：0xc000062330 Robot 2：\u0026{小白-X型-V1.0 白色 小型} 内存地址：0xc000062330 在这里面修改Robot1的Name和Color属性 Robot 1：{小黑-X型-V1.1 黑色 小型} 内存地址：0xc000062330 Robot 2：\u0026{小黑-X型-V1.1 黑色 小型} 内存地址：0xc000062330 浅拷贝中，我们可以看到Robot1和Robot2的内存地址是相同的，修改其中一个对象的属性时，另一个也会产生变化。 浅拷贝示例2： package main import ( \"fmt\" ) // 定义一个Robot结构体 type Robot struct { Name string Color string Model string } func main() { fmt.Println(\"浅拷贝 使用new方式\") robot1 := new(Robot) robot1.Name = \"小白-X型-V1.0\" robot1.Color = \"白色\" robot1.Model = \"小型\" robot2 := robot1 fmt.Printf(\"Robot 1：%s\\t内存地址：%p \\n\", robot1, robot1) fmt.Printf(\"Robot 2：%s\\t内存地址：%p \\n\", robot2, robot2) fmt.Println(\"在这里面修改Robot1的Name和Color属性\") robot1.Name = \"小蓝-X型-V1.2\" robot1.Color = \"蓝色\" fmt.Printf(\"Robot 1：%s\\t内存地址：%p \\n\", robot1, robot1) fmt.Printf(\"Robot 2：%s\\t内存地址：%p \\n\", robot2, robot2) } 运行结果： 浅拷贝 使用new方式 Robot 1：\u0026{小白-X型-V1.0 白色 小型} 内存地址：0xc000068330 Robot 2：\u0026{小白-X型-V1.0 白色 小型} 内存地址：0xc000068330 在这里面修改Robot1的Name和Color属性 Robot 1：\u0026{小黑-X型-V1.2 黑色 小型} 内存地址：0xc000068330 Robot 2：\u0026{小黑-X型-V1.2 黑色 小型} 内存地址：0xc000068330 new操作，robot2 := robot1，看上去是深拷贝，其实是浅拷贝，robot2和robot1两个指针共用同一个内存地址。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180045/:1:0","tags":null,"title":"1-8.Go和Python中的深浅拷贝","uri":"/lang/go/go_advanced/20250515180045/"},{"categories":null,"content":"\r2 2. Python 对于不可变数据类型来说都一样,对于可变数据类型: # 浅拷贝: 只拷贝数据的第一层 # 深拷贝: 对于可变的数据类型,拷贝拷贝嵌套层级中的所有可变类型 ---------------------------------------------------------- id(查看内存地址),赋值更改内存地址,内部变更改变量的值 # 内存地址 a = 1 b = 1 id(a) = id(b) #按理说a与b的id不该一样,但是在python中,为了提高运算性能,对某些特殊情况进行了缓存.(小数据池)缓存 对象: 1. 整型： -5 ~ 256 2. 字符串：\"alex\",'asfasd asdf asdf d_asdf ' ----\"f_*\" * 3 - 重新开辟内存。 == 与is 区别 ==比较的是值是否一致 is 比较内存地址是否一致 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180045/:2:0","tags":null,"title":"1-8.Go和Python中的深浅拷贝","uri":"/lang/go/go_advanced/20250515180045/"},{"categories":null,"content":"\r3 3. 总结 go深拷贝， 就是拷贝值 go浅拷贝， 拷贝引用 go中赋值就能实现拷贝，针对引用类型（slice，map，channel）是浅拷贝，对值类型是深拷贝 python 深浅拷贝针对可变类型的 python 深拷贝，拷贝是所有层引用 python 浅拷贝，拷贝是第一层引用 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515180045/:3:0","tags":null,"title":"1-8.Go和Python中的深浅拷贝","uri":"/lang/go/go_advanced/20250515180045/"},{"categories":null,"content":"\rDefer知识点 Defer 是在函数结束之前,return之前 执行一些逻辑, return之后的语句先执行，defer后的语句后执行 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175219/:0:0","tags":null,"title":"1-7.Go中的Defer","uri":"/lang/go/go_advanced/20250515175219/"},{"categories":null,"content":"\r1 1. defer的执行顺序 多个defer出现的时候，它是一个“栈”的关系，也就是先进后出。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175219/:1:0","tags":null,"title":"1-7.Go中的Defer","uri":"/lang/go/go_advanced/20250515175219/"},{"categories":null,"content":"\r2 2. defer与return谁先谁后 Defer 是在函数结束之前,return之前 执行一些逻辑 return之后的语句先执行，defer后的语句后执行, 除非defer后函数的参数中包含子函数 package main import \"fmt\" func d() string{ fmt.Println(\"d \") return \"derfer return\" } func f() string{ fmt.Println(\"f \") return \"func func\" } func do() string { defer d() return f() } func main() { fmt.Println(do()) } /* f d func func */ defer下的函数参数包含子函数, 该子函数会先执行, 其他情况defer后的函数都不会先执行(其他情况如:defer内部包含自执行函数,defer后面跟自执行函数, ) 然后 return后的函数, 然后再执行defer后的函数 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175219/:2:0","tags":null,"title":"1-7.Go中的Defer","uri":"/lang/go/go_advanced/20250515175219/"},{"categories":null,"content":"\r3 3. 函数的返回值初始化 只要声明函数的返回值变量名称，就会在函数初始化时候为之赋值为0，而且在函数体作用域可见。 该知识点不属于defer本身，但是调用的场景却与defer有联系，所以也算是defer必备了解的知识点之一。 如 ： func DeferFunc1(i int) (t int) {}其中返回值t int，这个t会在函数起始处被初始化为对应类型的零值并且作用域为整个函数。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175219/:3:0","tags":null,"title":"1-7.Go中的Defer","uri":"/lang/go/go_advanced/20250515175219/"},{"categories":null,"content":"\r4 4. 有名函数返回值遇见defer情况 通过知识点2得知，先return，再defer，所以在执行完return之后，还要再执行defer里的语句，依然可以修改本应该返回的结果。 在没有defer的情况下，其实函数的返回就是与return一致的，但是有了defer就不一样了。 package main import \"fmt\" func returnButDefer() (t int) { //t初始化0， 并且作用域为该函数全域 defer func() { t = t * 10 }() return 1 } func main() { fmt.Println(returnButDefer()) } // 输出: 10 /* 该returnButDefer()本应的返回值是1，但是在return之后，又被defer的匿名func函数执行，所以t=t*10被执行，最后returnButDefer()返回给上层main()的结果为10 */ ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175219/:4:0","tags":null,"title":"1-7.Go中的Defer","uri":"/lang/go/go_advanced/20250515175219/"},{"categories":null,"content":"\r5 5. defer遇见panic defer 最大的功能是 panic 后依然有效 所以defer可以保证你的一些资源一定会被关闭，从而避免一些异常出现的问题。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175219/:5:0","tags":null,"title":"1-7.Go中的Defer","uri":"/lang/go/go_advanced/20250515175219/"},{"categories":null,"content":"\r5.1 5.1 defer 没有recover panic 触发之前, 先进后出执行已经入栈的defer, 然后panic,程序异常结束, panic之后的不再执行. package main import ( \"fmt\" ) func main() { defer_call() fmt.Println(\"main 正常结束\") } func defer_call() { defer func() { fmt.Println(\"defer: panic 之前1\") }() defer func() { fmt.Println(\"defer: panic 之前2\") }() panic(\"异常内容\") //触发defer出栈 defer func() { fmt.Println(\"defer: panic 之后，永远执行不到\") }() } /* defer: panic 之前2 defer: panic 之前1 panic: 异常内容 goroutine 1 [running]: main.defer_call() /Users/liusaisai/workspace/goProject/src/picturePro/main.go:17 +0x6c main.main() /Users/liusaisai/workspace/goProject/src/picturePro/main.go:8 +0x20 */ ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175219/:5:1","tags":null,"title":"1-7.Go中的Defer","uri":"/lang/go/go_advanced/20250515175219/"},{"categories":null,"content":"\r5.2 5.2 defer 中存在recover panic 触发之前, 先进后出执行已经入栈的defer, recover 正常执行, 然后panic,程序正常结束, 子函数中panic之后的不再执行,main函数正常执行. package main import ( \"fmt\" ) func main() { defer_call() fmt.Println(\"main 正常结束\") } func defer_call() { defer func() { fmt.Println(\"defer: panic 之前1, 捕获异常\") if err := recover(); err != nil { fmt.Println(err) } }() defer func() { fmt.Println(\"defer: panic 之前2, 不捕获\") }() panic(\"异常内容\") //触发defer出栈 defer func() { fmt.Println(\"defer: panic 之后, 永远执行不到\") }() } /* defer: panic 之前2, 不捕获 defer: panic 之前1, 捕获异常 异常内容 main 正常结束 */ ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175219/:5:2","tags":null,"title":"1-7.Go中的Defer","uri":"/lang/go/go_advanced/20250515175219/"},{"categories":null,"content":"\r6 6. defer中包含panic panic仅有最后一个可以被revover捕获。 触发panic(\"panic\")后defer顺序出栈执行，第一个被执行的defer中 会有panic(\"defer panic\")异常语句，这个异常将会覆盖掉main中的异常panic(\"panic\")，最后这个异常被第二个执行的defer捕获到。 package main import ( \"fmt\" ) func main() { defer func() { if err := recover(); err != nil{ fmt.Println(err) }else { fmt.Println(\"fatal\") } }() defer func() { panic(\"defer panic\") }() panic(\"panic\") } // \"defer panic\" ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175219/:6:0","tags":null,"title":"1-7.Go中的Defer","uri":"/lang/go/go_advanced/20250515175219/"},{"categories":null,"content":"\r7 7. defer下的函数参数包含子函数 defer下的函数参数包含子函数, 该子函数会先执行, 其他情况defer后的函数都不会先执行(其他情况如:defer内部包含自执行函数,defer后面跟自执行函数, ) defer压栈function1，压栈函数地址、形参1、形参2(调用function3) –\u003e 打印3 defer压栈function2，压栈函数地址、形参1、形参2(调用function4) –\u003e 打印4 defer出栈function2, 调用function2 –\u003e 打印2 defer出栈function1, 调用function1–\u003e 打印1 package main import \"fmt\" func function(index int, value int) int { fmt.Println(index) return index } func main() { defer function(1, function(3, 0)) defer function(2, function(4, 0)) } 经典练习(一定要看) 题解: https://www.kancloud.cn/aceld/golang/1958310#3_92 package main import \"fmt\" func DeferFunc1(i int) (t int) { t = i defer func() { t += 3 }() return t // 返回的是t } func DeferFunc2(i int) int { t := i defer func() { t += 3 }() return t // 将t赋值给返回值 } func DeferFunc3(i int) (t int) { defer func() { t += i }() return 2 } func DeferFunc4() (t int) { defer func(i int) { fmt.Println(i) fmt.Println(t) // 闭包引入外部变量t }(t) // t的值被压入栈, 此时为0 t = 1 return 2 } func main() { fmt.Println(DeferFunc1(1)) fmt.Println(DeferFunc2(1)) fmt.Println(DeferFunc3(1)) DeferFunc4() } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175219/:7:0","tags":null,"title":"1-7.Go中的Defer","uri":"/lang/go/go_advanced/20250515175219/"},{"categories":null,"content":"\r一. interface interface 是方法声明的集合 任何类型的对象实现了在interface 接口中声明的全部方法，则表明该类型实现了该接口。 interface 可以作为一种数据类型，实现了该接口的任何对象都可以给对应的接口类型变量赋值。 interface 可以被任意对象实现，一个类型/对象也可以实现多个 interface 方法不能重载，如 eat(), eat(s string) 不能同时存在 接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。 牢记接口（interface）是一种类型。 接口类型是一种抽象的类型, 不会暴露出他所代表的内部属性的结构, 只会展示出他自己的方法,因此接口不能被实例化; **Golang中的接口没有数据字段, 只有定义的方法;**接口是方法的集合 接口命名规范: 单个函数的接口名以\"er\"作为后缀, 接口的实现则去掉\"er\" 两个函数的接口名综合两个函数名, 以\"er\"作为后缀, 接口的实现则去掉\"er\" 三个以上函数以上的接口名, 抽象这个接口的功能, 类似于结构体命名; 结构体嵌入接口值，结构体初始化后可以返回嵌入的接口值类型 二. 面向对象原则 面向对象尽量遵从一下原则 开闭原则: 面向扩展开放, 面向修改关闭. 简单的说就是在修改需求的时候，应该尽量通过扩展来实现变化，而不是通过修改已有代码来实现变化。 依赖倒转原则: 抽象层暴露出来的接口就是我们业务层可以使用的方法，然后可以通过多态的线下，接口指针指向哪个实现模块，调用了就是具体的实现方法; 依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。低层模块尽量都要有抽象类或接口，或者两者都有。变量的声明类型尽量是抽象类或接口。 单一原则: 单一职责，从字面意思其实就很好理解，只做一件事，不去多揽其他的事使自己烦心；单一职责原则可以看做是低耦合高内聚思想的延伸，提高高内聚来减少引起变化的原因。 里氏替换原则: 里氏替换原则对继承进行了规则上的约束，这种约束主要体现在四个方面： \\1. 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。 \\2. 子类中可以增加自己特有的方法。 \\3. 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 \\4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 就是要求继承是严格的is-a关系。所有引用基类的地方必须能透明地使用其子类的对象。在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。 接口隔离原则: 接口端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。一个类对另一个类的依赖应该建立在最小的接口上,通俗的讲就是需要什么就提供什么，不需要的就不要提供。接口中的方法应该尽量少，不要使接口过于臃肿，不要有很多不相关的逻辑方法。 三. 面向对象中的开闭原则 开闭原则: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 简单的说就是在修改需求的时候，应该尽量通过扩展来实现变化，而不是通过修改已有代码来实现变化。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175216/:0:0","tags":null,"title":"1-6.Go面向对象的思维理解interface","uri":"/lang/go/go_advanced/20250515175216/"},{"categories":null,"content":"\r1 1. 平铺式的模块设计 (垃圾) 那么作为interface数据类型，他存在的意义在哪呢？ 实际上是为了满足一些面向对象的编程思想。 我们知道，软件设计的最高目标就是高内聚，低耦合。那么其中有一个设计原则叫开闭原则。什么是开闭原则呢，接下来我们看一个例子： 一个银行业务员，他可能拥有很多的业务，比如Save()存款、Transfer()转账、Pay()支付等。那么如果这个业务员模块只有这几个方法还好，但是随着我们的程序写的越来越复杂，银行业务员可能就要增加方法，会导致业务员模块越来越臃肿。 package main import \"fmt\" //我们要写一个类,Banker银行业务员 type Banker struct { } //存款业务 func (this *Banker) Save() { fmt.Println( \"进行了 存款业务...\") } //转账业务 func (this *Banker) Transfer() { fmt.Println( \"进行了 转账业务...\") } //支付业务 func (this *Banker) Pay() { fmt.Println( \"进行了 支付业务...\") } func main() { banker := \u0026Banker{} banker.Save() banker.Transfer() banker.Pay() } 这样的设计会导致，当我们去给Banker添加新的业务的时候，会直接修改原有的Banker代码，那么Banker模块的功能会越来越多，出现问题的几率也就越来越大，假如此时Banker已经有99个业务了，现在我们要添加第100个业务，可能由于一次的不小心，导致之前99个业务也一起崩溃，因为所有的业务都在一个Banker类里，他们的耦合度太高，Banker的职责也不够单一，代码的维护成本随着业务的复杂正比成倍增大。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175216/:1:0","tags":null,"title":"1-6.Go面向对象的思维理解interface","uri":"/lang/go/go_advanced/20250515175216/"},{"categories":null,"content":"\r2 2. 开闭原则设计 (优化) 开闭原则: 设计代码时应该对功能扩展开放, 对修改功能关闭; 简单的说就是在修改需求的时候，应该尽量通过扩展来实现变化，而不是通过修改已有代码来实现变化。 如果我们拥有接口, interface这个东西，那么我们就可以抽象一层出来，制作一个抽象的Banker模块，然后提供一个抽象的方法。 分别根据这个抽象模块，去实现支付Banker（实现支付方法）,转账Banker（实现转账方法） 开闭原则设计代码 package main import \"fmt\" //抽象的银行业务员 type AbstractBanker interface{ DoBusi() //抽象的处理业务接口 } //存款的业务员 type SaveBanker struct { //AbstractBanker } func (sb *SaveBanker) DoBusi() { fmt.Println(\"进行了存款\") } //转账的业务员 type TransferBanker struct { //AbstractBanker } func (tb *TransferBanker) DoBusi() { fmt.Println(\"进行了转账\") } //支付的业务员 type PayBanker struct { //AbstractBanker } func (pb *PayBanker) DoBusi() { fmt.Println(\"进行了支付\") } func main() { //进行存款 sb := \u0026SaveBanker{} sb.DoBusi() //进行转账 tb := \u0026TransferBanker{} tb.DoBusi() //进行支付 pb := \u0026PayBanker{} pb.DoBusi() } 当然我们也可以根据AbstractBanker设计一个小框架 //实现架构层(基于抽象层进行业务封装-针对interface接口进行封装) func BankerBusiness(banker AbstractBanker) { //通过接口来向下调用，(多态现象) banker.DoBusi() } 那么main中可以如下实现业务调用: func main() { //进行存款 BankerBusiness(\u0026SaveBanker{}) //进行存款 BankerBusiness(\u0026TransferBanker{}) //进行存款 BankerBusiness(\u0026PayBanker{}) } 四. 面向对象中的依赖倒转原则","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175216/:2:0","tags":null,"title":"1-6.Go面向对象的思维理解interface","uri":"/lang/go/go_advanced/20250515175216/"},{"categories":null,"content":"\r1 1. 耦合度极高的模块关系设计 package main import \"fmt\" // === \u003e 奔驰汽车 \u003c=== type Benz struct { } func (this *Benz) Run() { fmt.Println(\"Benz is running...\") } // === \u003e 宝马汽车 \u003c=== type BMW struct { } func (this *BMW) Run() { fmt.Println(\"BMW is running ...\") } //===\u003e 司机张三 \u003c=== type Zhang3 struct { //... } func (zhang3 *Zhang3) DriveBenZ(benz *Benz) { fmt.Println(\"zhang3 Drive Benz\") benz.Run() } func (zhang3 *Zhang3) DriveBMW(bmw *BMW) { fmt.Println(\"zhang3 drive BMW\") bmw.Run() } //===\u003e 司机李四 \u003c=== type Li4 struct { //... } func (li4 *Li4) DriveBenZ(benz *Benz) { fmt.Println(\"li4 Drive Benz\") benz.Run() } func (li4 *Li4) DriveBMW(bmw *BMW) { fmt.Println(\"li4 drive BMW\") bmw.Run() } func main() { //业务1 张3开奔驰 benz := \u0026Benz{} zhang3 := \u0026Zhang3{} zhang3.DriveBenZ(benz) //业务2 李四开宝马 bmw := \u0026BMW{} li4 := \u0026Li4{} li4.DriveBMW(bmw) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175216/:3:0","tags":null,"title":"1-6.Go面向对象的思维理解interface","uri":"/lang/go/go_advanced/20250515175216/"},{"categories":null,"content":"\r2 2. 面向抽象层依赖倒转 抽象层依赖倒转原则: 在指定业务逻辑也是一样，只需要参考抽象层的接口来业务就好了，抽象层暴露出来的接口就是我们业务层可以使用的方法，然后可以通过多态的线下，接口指针指向哪个实现模块，调用了就是具体的实现方法，这样我们业务逻辑层也是依赖抽象成编程。我们就将这种的设计原则叫做依赖倒转原则。 如上图所示，如果我们在设计一个系统的时候，将模块分为3个层次，抽象层、实现层、业务逻辑层。那么，我们首先将抽象层的模块和接口定义出来，这里就需要了interface接口的设计，然后我们依照抽象层，依次实现每个实现层的模块，在我们写实现层代码的时候，实际上我们只需要参考对应的抽象层实现就好了，实现每个模块，也和其他的实现的模块没有关系，这样也符合了上面介绍的开闭原则。这样实现起来每个模块只依赖对象的接口，而和其他模块没关系，依赖关系单一。系统容易扩展和维护。 package main import \"fmt\" // ===== \u003e 抽象层 \u003c ======== type Car interface { Run() } type Driver interface { Drive(car Car) } // ===== \u003e 实现层 \u003c ======== type BenZ struct { //... } func (benz * BenZ) Run() { fmt.Println(\"Benz is running...\") } type Bmw struct { //... } func (bmw * Bmw) Run() { fmt.Println(\"Bmw is running...\") } type Zhang_3 struct { //... } func (zhang3 *Zhang_3) Drive(car Car) { fmt.Println(\"Zhang3 drive car\") car.Run() } type Li_4 struct { //... } func (li4 *Li_4) Drive(car Car) { fmt.Println(\"li4 drive car\") car.Run() } // ===== \u003e 业务逻辑层 \u003c ======== func main() { //张3 开 宝马 var bmw Car bmw = \u0026Bmw{} var zhang3 Driver zhang3 = \u0026Zhang_3{} zhang3.Drive(bmw) //李4 开 奔驰 var benz Car benz = \u0026BenZ{} var li4 Driver li4 = \u0026Li_4{} li4.Drive(benz) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175216/:4:0","tags":null,"title":"1-6.Go面向对象的思维理解interface","uri":"/lang/go/go_advanced/20250515175216/"},{"categories":null,"content":"\r3 3. 依赖倒转小练习 结构体嵌入接口值，结构体初始化后可以返回嵌入的接口值类型 需求 模拟组装2台电脑 — 抽象层 —有显卡Card 方法display，有内存Memory 方法storage，有处理器CPU 方法calculate — 实现层层 —有 Intel因特尔公司 、产品有(显卡、内存、CPU)，有 Kingston 公司， 产品有(内存3)，有 NVIDIA 公司， 产品有(显卡) — 逻辑层 —1. 组装一台Intel系列的电脑，并运行，2. 组装一台 Intel CPU Kingston内存 NVIDIA显卡的电脑，并运行 实现 /* 模拟组装2台电脑 --- 抽象层 --- 有显卡Card 方法display 有内存Memory 方法storage 有处理器CPU 方法calculate --- 实现层层 --- 有 Intel因特尔公司 、产品有(显卡、内存、CPU) 有 Kingston 公司， 产品有(内存3) 有 NVIDIA 公司， 产品有(显卡) --- 逻辑层 --- 1. 组装一台Intel系列的电脑，并运行 2. 组装一台 Intel CPU Kingston内存 NVIDIA显卡的电脑，并运行 */ package main import \"fmt\" //------ 抽象层 ----- type Card interface{ Display() } type Memory interface { Storage() } type CPU interface { Calculate() } type Computer struct { cpu CPU mem Memory card Card } func NewComputer(cpu CPU, mem Memory, card Card) *Computer{ return \u0026Computer{ cpu:cpu, mem:mem, card:card, } } func (this *Computer) DoWork() { this.cpu.Calculate() this.mem.Storage() this.card.Display() } //------ 实现层 ----- //intel type IntelCPU struct { CPU } func (this *IntelCPU) Calculate() { fmt.Println(\"Intel CPU 开始计算了...\") } type IntelMemory struct { Memory } func (this *IntelMemory) Storage() { fmt.Println(\"Intel Memory 开始存储了...\") } type IntelCard struct { Card } func (this *IntelCard) Display() { fmt.Println(\"Intel Card 开始显示了...\") } //kingston type KingstonMemory struct { Memory } func (this *KingstonMemory) Storage() { fmt.Println(\"Kingston memory storage...\") } //nvidia type NvidiaCard struct { Card } func (this *NvidiaCard) Display() { fmt.Println(\"Nvidia card display...\") } //------ 业务逻辑层 ----- func main() { //intel系列的电脑 com1 := NewComputer(\u0026IntelCPU{}, \u0026IntelMemory{}, \u0026IntelCard{}) //结构体嵌入接口值，结构体初始化后可以返回嵌入的接口值类型 com1.DoWork() //杂牌子 com2 := NewComputer(\u0026IntelCPU{}, \u0026KingstonMemory{}, \u0026NvidiaCard{}) com2.DoWork() } 五. 接口的意义 接口的意义就是为了实现解耦为了实现多态 接口的最大的意义就是实现多态的思想，就是我们可以根据interface类型来设计API接口，那么这种API接口的适应能力不仅能适应当下所实现的全部模块，也适应未来实现的模块来进行调用。 调用未来可能就是接口的最大意义所在吧，这也是为什么架构师那么值钱，因为良好的架构师是可以针对interface设计一套框架，在未来许多年却依然适用。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175216/:5:0","tags":null,"title":"1-6.Go面向对象的思维理解interface","uri":"/lang/go/go_advanced/20250515175216/"},{"categories":null,"content":"\r一. 栈和堆 栈内存: 栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。但是可分配的内存有限 Go语言中的引用类型有func（函数类型），interface（接口类型），slice（切片类型），map（字典类型），channel（管道类型），*（指针类型）等。 堆内存: 存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾通过GC回收. ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:0:0","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r1 1.原理 在main函数中 var arr = make([]int,9)的定义流程: 主函数先进栈，在栈中定义一个变量arr,接下来为arr赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过new关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体： 给堆分配了一个地址，把堆的地址赋给arr，arr就通过地址指向了数组。所以arr想操纵数组时，就通过地址，而不是直接把实体都赋给它。这种我们不再叫他基本数据类型，而叫引用数据类型。称为arr引用了堆内存当中的实体。(指针) 如果当int [] arr=null;arr不做任何指向，null的作用就是取消引用数据类型的指向。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:1:0","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2 2.区别 栈内存存储的是局部变量而堆内存存储的是实体； 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短； 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。 二. make和new的区别 变量的声明我们可以通过var关键字，然后就可以在程序中使用。当我们不指定变量的默认值时，这些变量的默认值是他们的零值，比如int类型的零值是0,string类型的零值是\"\"，引用类型的零值是nil。 引用类型的变量，我们不光要声明它，还要为它分配内容空间 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:2:0","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r1 1. new new分配内存。 new只接受一个参数，这个参数是一个类型，分配好内存后，返回一个指向该类型内存地址的指针。同时请注意它同时把分配的内存置为零，也就是类型的零值。 new返回的永远是类型的指针，指向分配类型的内存地址。 // 示例一 func main() { var i *int i=new(int) *i=10 fmt.Println(*i) //打印10 } // 示例2 package main import ( \"fmt\" \"sync\" ) type user struct { lock sync.Mutex name string age int } func main() { u := new(user) //默认给u分配到内存全部为0 u.lock.Lock() //可以直接使用，因为lock为0,是开锁状态 u.name = \"张三\" u.lock.Unlock() fmt.Println(u) } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:3:0","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2 2. make make也是用于内存分配的，但是和new不同。 只用于chan, map, slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。 注意，因为这三种类型是引用类型，所以必须得初始化，但是不是置为零值，这个和new是不一样的。 func make(t Type, size ...IntegerType) Type 从函数声明中可以看到，返回的还是该类型。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:4:0","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r3 3. make与new的异同 相同 堆空间分配 不同 make: 只用于slice、map以及channel的初始化， 无可替代 new: 用于类型内存分配(初始化值为0)， 不常用 new不常用 所以有new这个内置函数，可以给我们分配一块内存让我们使用，但是现实的编码中，它是不常用的。我们通常都是采用短语句声明以及结构体的字面量达到我们的目的，比如： i : =0 u := user{} make 无可替代 我们在使用slice、map以及channel的时候，还是要使用make进行初始化，然后才才可以对他们进行操作。 三. Golang中逃逸现象 栈(Stack)内存: 栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量） 堆(heap)内存: 存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾通过GC回收. 示例代码 package main func foo(arg_val int)(*int) { var foo_val int = 11; return \u0026foo_val; } func main() { main_val := foo(666) println(*main_val) } 函数foo 返回了一个函数内部变量, 在c++中直接报错, 在C/C++中, 外部函数使用了子函数的局部变量, 理论来说,子函数的foo_val 的声明周期早就销毁了才对 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:5:0","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r1 1. Golang编译器得逃逸分析 go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。 go语言声称这样可以释放程序员关于内存的使用限制，更多的让程序员关注于程序功能逻辑本身。 示例代码 package main func foo(arg_val int) (*int) { var foo_val1 int = 11; var foo_val2 int = 12; var foo_val3 int = 13; var foo_val4 int = 14; var foo_val5 int = 15; //此处循环是防止go编译器将foo优化成inline(内联函数) //如果是内联函数，main调用foo将是原地展开，所以foo_val1-5相当于main作用域的变量 //即使foo_val3发生逃逸，地址与其他也是连续的 for i := 0; i \u003c 5; i++ { println(\u0026arg_val, \u0026foo_val1, \u0026foo_val2, \u0026foo_val3, \u0026foo_val4, \u0026foo_val5) } //返回foo_val3给main函数 return \u0026foo_val3; } func main() { main_val := foo(666) println(*main_val, main_val) } /* 输出结果 $ go run pro_2.go 0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720 0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720 0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720 0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720 0xc000030758 0xc000030738 0xc000030730 0xc000082000 0xc000030728 0xc000030720 13 0xc000082000 */ 我们能看到foo_val3是返回给main的局部变量, 其中他的地址应该是0xc000082000,很明显与其他的foo_val1、2、3、4不是连续的. foo_val3是被runtime.newobject()在堆空间开辟的, 而不是像其他几个是基于地址偏移的开辟的栈空间. ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:6:0","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2 2. 逃逸规则 我们其实都知道一个普遍的规则，就是如果变量需要使用堆空间，那么他就应该进行逃逸。但是实际上Golang并不仅仅把逃逸的规则如此泛泛。Golang会有很多场景具备出现逃逸的现象。 **一般我们给一个引用类对象中的引用类成员进行赋值，可能出现逃逸现象。**可以理解为访问一个引用对象实际上底层就是通过一个指针来间接的访问了，但如果再访问里面的引用成员就会有第二次间接访问，这样操作这部分对象的话，极大可能会出现逃逸的现象。 Go语言中的引用类型有func（函数类型），interface（接口类型），slice（切片类型），map（字典类型），channel（管道类型），*（指针类型）等。 指针逃逸: 指针逃逸应该是最容易理解的一种情况了，即在函数中创建了一个对象，返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。 **interface{} 动态类型逃逸:**空接口即 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。 栈空间不足: 操作系统对内核线程使用的栈空间是有大小限制的，64 位系统上通常是 8 MB。可以使用 ulimit -a 命令查看机器上栈允许占用的内存的大小。对于 Go 语言来说，运行时(runtime) 尝试在 goroutine 需要的时候动态地分配栈空间，goroutine 的初始栈大小为 2 KB。当 goroutine 被调度时，会绑定内核线程执行，栈空间大小也不会超过操作系统的限制。 **闭包:**闭包让你可以在一个内层函数中访问到其外层函数的作用域。变量 n 占用的内存不能随着函数的退出而回收，因此将会逃逸到堆上。 发送指针的指针或值包含了指针到channel 中，由于在编译阶段无法确定其作用域与传递的路径，所以一般都会逃逸到堆上分配。 slice 由于 append 操作超出其容量，因此会导致 slice 重新分配。这种情况下，由于在编译时 slice 的初始大小的已知情况下，将会在栈上分配。如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:7:0","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2.1 2.1 逃逸场景1 (interface{} 逃逸)[]interface{}数据类型，通过[]赋值必定会出现逃逸。 package main func main() { data := []interface{}{100, 200} data[0] = 100 } 我们通过编译看看逃逸结果 aceld:test ldb$ go tool compile -m 1.go 1.go:3:6: can inline main 1.go:4:23: []interface {}{...} does not escape 1.go:4:24: 100 does not escape 1.go:4:29: 200 does not escape 1.go:6:10: 100 escapes to heap 我们能看到，data[0] = 100 发生了逃逸现象。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:7:1","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2.2 2.2 逃逸场景2 (interface{} 逃逸)map[string]interface{}类型尝试通过赋值，必定会出现逃逸。 package main func main() { data := make(map[string]interface{}) data[\"key\"] = 200 } 我们通过编译看看逃逸结果 aceld:test ldb$ go tool compile -m 2.go 2.go:3:6: can inline main 2.go:4:14: make(map[string]interface {}) does not escape 2.go:6:14: 200 escapes to heap 我们能看到，data[\"key\"] = 200 发生了逃逸。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:7:2","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2.3 2.3 逃逸场景3 (interface{} 逃逸)map[interface{}]interface{}类型尝试通过赋值，会导致key和value的赋值，出现逃逸。 package main func main() { data := make(map[interface{}]interface{}) data[100] = 200 } 我们通过编译看看逃逸结果 aceld:test ldb$ go tool compile -m 3.go 3.go:3:6: can inline main 3.go:4:14: make(map[interface {}]interface {}) does not escape 3.go:6:6: 100 escapes to heap 3.go:6:12: 200 escapes to heap 我们能看到，data[100] = 200 中，100和200均发生了逃逸。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:7:3","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2.4 2.4 逃逸场景4map[string][]string数据类型，赋值会发生[]string发生逃逸。 package main func main() { data := make(map[string][]string) data[\"key\"] = []string{\"value\"} } 我们通过编译看看逃逸结果 aceld:test ldb$ go tool compile -m 4.go 4.go:3:6: can inline main 4.go:4:14: make(map[string][]string) does not escape 4.go:6:24: []string{...} escapes to heap 我们能看到，[]string{...}切片发生了逃逸。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:7:4","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2.5 2.5 逃逸场景5[]*int数据类型，赋值的右值会发生逃逸现象。 package main func main() { a := 10 data := []*int{nil} data[0] = \u0026a } 我们通过编译看看逃逸结果 aceld:test ldb$ go tool compile -m 5.go 5.go:3:6: can inline main 5.go:4:2: moved to heap: ash 5.go:6:16: []*int{...} does not escape 其中 moved to heap: a，最终将变量a 移动到了堆上。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:7:5","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2.6 2.6 逃逸场景6func(*int)函数类型，进行函数赋值，会使传递的形参出现逃逸现象。 package main import \"fmt\" func foo(a *int) { return } func main() { data := 10 f := foo f(\u0026data) fmt.Println(data) } 我们通过编译看看逃逸结果 aceld:test ldb$ go tool compile -m 6.go 6.go:5:6: can inline foo 6.go:12:3: inlining call to foo 6.go:14:13: inlining call to fmt.Println 6.go:5:10: a does not escape 6.go:14:13: data escapes to heap 6.go:14:13: []interface {}{...} does not escape :1: .this does not escape 我们会看到data已经被逃逸到堆上。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:7:6","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2.7 2.7 逃逸场景7 func([]string): 函数类型，进行[]string{\"value\"}赋值，会使传递的参数出现逃逸现象。 package main import \"fmt\" func foo(a []string) { return } func main() { s := []string{\"aceld\"} foo(s) fmt.Println(s) } 我们通过编译看看逃逸结果 aceld:test ldb$ go tool compile -m 7.go 7.go:5:6: can inline foo 7.go:11:5: inlining call to foo 7.go:13:13: inlining call to fmt.Println 7.go:5:10: a does not escape 7.go:10:15: []string{...} escapes to heap 7.go:13:13: s escapes to heap 7.go:13:13: []interface {}{...} does not escape :1: .this does not escape 我们看到 s escapes to heap，s被逃逸到堆上。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:7:7","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2.8 2.8 逃逸场景8 chan []string数据类型，想当前channel中传输[]string{\"value\"}会发生逃逸现象。 package main func main() { ch := make(chan []string) s := []string{\"aceld\"} go func() { ch \u003c- s }() } 我们通过编译看看逃逸结果 aceld:test ldb$ go tool compile -m 8.go 8.go:8:5: can inline main.func1 8.go:6:15: []string{...} escapes to heap 8.go:8:5: func literal escapes to heap 我们看到[]string{...} escapes to heap, s被逃逸到堆上。 四. 内存溢出","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:7:8","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r1 1. 什么情况下内存会泄露 go 中的内存泄漏一般都是 goroutine 泄漏，就是 goroutine 没有被关闭，或者没有添加超时控制，让 goroutine 一直处于阻塞状态，不能被 GC。 如果 goroutine 在执行时被阻塞而无法退出，就会导致 goroutine 的内存泄漏，一个 goroutine 的最低栈大小为 2KB，在高并发的场景下，对内存的消耗也是非常恐怖的。 互斥锁未释放或者造成死锁会造成内存泄漏 time.Ticker 是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间。 字符串的截取引发临时性的内存泄漏 func main() { var str0 = \"12345678901234567890\" str1 := str0[:10] } 切片截取引起子切片内存泄漏 func main() { var s0 = []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} s1 := s0[:3] } 函数数组传参引发内存泄漏 【如果我们在函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为 100 万，64 位机上消耗的内存约为 800w 字节，即 8MB 内存），或者该函数短时间内被调用 N 次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及 GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕。】 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:8:0","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r2 2. 怎么定位排查内存泄漏问题 一般通过 pprof 是 Go 的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是 CPU 使用情况、内存使用情况、goroutine 运行情况等，当需要性能调优或者定位 Bug 时候，这些记录的信息是相当重要。 五. 结论 Golang中一个函数内局部变量，不管是不是动态new出来的，它会被分配在堆还是栈，是由编译器做逃逸分析之后做出的决定。 go语言不希望程序员关心这些事! ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175213/:9:0","tags":null,"title":"1-5.Go中逃逸现象, 变量+堆栈","uri":"/lang/go/go_advanced/20250515175213/"},{"categories":null,"content":"\r1 一. 提高cpu利用率 最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。 多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。 大量的进程/线程出现了新的问题 高内存占用 调度的高消耗CPU ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175210/:1:0","tags":null,"title":"1-4.Go协程调度原理及GPM模型","uri":"/lang/go/go_advanced/20250515175210/"},{"categories":null,"content":"\r1.1 1. 协程 和 m:n模型 大量的进程/线程出现了新的问题 高内存占用 调度的高消耗CPU 其实一个线程分为“内核态“线程和”用户态“线程。 m:n 线程模型 M个用户态线程倚在N个核心线程身上， N个核心线程可能阻塞。每个核心态线程对应一个或多个用户态线程，至少包含一个调度线程。 M，一般只受资源或系统值限制。而对于N，一般受CPU数限制，如果核心线程阻塞 协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175210/:1:1","tags":null,"title":"1-4.Go协程调度原理及GPM模型","uri":"/lang/go/go_advanced/20250515175210/"},{"categories":null,"content":"\r2 二. Goroutine调度器的GMP模型","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175210/:2:0","tags":null,"title":"1-4.Go协程调度原理及GPM模型","uri":"/lang/go/go_advanced/20250515175210/"},{"categories":null,"content":"\r2.1 1. Goroutine特点 OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的goroutine也是可以的。 Goroutine特点： 占用内存更小（几kb） 调度更灵活(runtime调度) Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175210/:2:1","tags":null,"title":"1-4.Go协程调度原理及GPM模型","uri":"/lang/go/go_advanced/20250515175210/"},{"categories":null,"content":"\r2.2 2. GPM模型 G: goroutine 协程 P: process 处理器 M: 内核线程thread 在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。 全局队列（Global Queue）：存放等待运行的G。 P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。 P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。 M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。 Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。 2.2.1 2.1 P 和 M 的个数 P的数量 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。 M的数量: go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。 runtime/debug中的SetMaxThreads函数，设置M的最大数量 一个M阻塞了，会创建新的M。 M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。 2.2.2 2.2 P 和 M 何时会被创建? P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。 M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175210/:2:2","tags":null,"title":"1-4.Go协程调度原理及GPM模型","uri":"/lang/go/go_advanced/20250515175210/"},{"categories":null,"content":"\r2.3 3. Goroutine调度器的设计策略 复用线程：避免频繁的创建、销毁线程，而是对线程的复用. work stealing 机制: 当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。 hand off 机制: 当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。 利用并行：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。 抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。 全局G队列：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175210/:2:3","tags":null,"title":"1-4.Go协程调度原理及GPM模型","uri":"/lang/go/go_advanced/20250515175210/"},{"categories":null,"content":"\r2.4 4. Go func() 调度流程 从上图我们可以分析出几个结论： 我们通过 go func()来创建一个goroutine； 有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中； G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行； 一个M调度G执行的过程是一个循环机制； 当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P； 当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175210/:2:4","tags":null,"title":"1-4.Go协程调度原理及GPM模型","uri":"/lang/go/go_advanced/20250515175210/"},{"categories":null,"content":"\r2.5 5. 调度器的生命周期 M0 M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。 G0 G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。 package main import \"fmt\" func main() { fmt.Println(\"Hello world\") } 针对上面的代码对调度器里面的结构做一个分析。也会经历如上图所示的过程： runtime创建最初的线程m0和goroutine g0，并把2者关联。 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。 G拥有栈，M根据G中的栈信息和调度信息设置运行环境 M运行G G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。 调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175210/:2:5","tags":null,"title":"1-4.Go协程调度原理及GPM模型","uri":"/lang/go/go_advanced/20250515175210/"},{"categories":null,"content":"\r2.6 6. goroutine 调度切换条件 runtime.Sched() 主动让出cpu channel 读写阻塞 遇到互斥锁 网络IO 阻塞的系统调用 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175210/:2:6","tags":null,"title":"1-4.Go协程调度原理及GPM模型","uri":"/lang/go/go_advanced/20250515175210/"},{"categories":null,"content":"\r2.7 7. 抢占式调度器 doc: 抢占式调度器 对 Go 语言并发模型的修改提升了调度器的性能，但是 1.1 版本中的调度器仍然不支持抢占式调度，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度。Go 语言的调度器在 1.2 版本4中引入基于协作的抢占式调度解决下面的问题： 某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿； 垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间，导致整个程序无法工作； 1.2 版本的抢占式调度虽然能够缓解这个问题，但是它实现的抢占式调度是基于协作的，在之后很长的一段时间里 Go 语言的调度器都有一些无法被抢占的边缘情况，例如：for 循环或者垃圾回收长时间占用线程，这些问题中的一部分直到 1.14 才被基于信号的抢占式调度解决。 2.7.1 7.1 基于协作的抢占式调度 编译器会在调用函数前插入 runtime.morestack； Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 StackPreempt； 当发生函数调用时，可能会执行编译器插入的 runtime.morestack，它调用的 runtime.newstack 会检查 Goroutine 的 stackguard0 字段是否为 StackPreempt； 如果 stackguard0 是 StackPreempt，就会触发抢占让出当前线程； 因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种协作式的抢占式调度。 当运行到 time.Sleep 后，线程上的 goroutine 会从 main 切换到前面的匿名函数协程，而这个匿名函数协程并是在作for 死循环，并没有任何可以让出 cpu 运行权的操作，因为该程序在 go 1.14 之前的 go版本中，运行后会一直卡住，而不会打印 I got scheduled! package main import ( \"fmt\" \"runtime\" \"time\" ) func main() { runtime.GOMAXPROCS(1) fmt.Println(\"The program starts ...\") go func() { for { } }() time.Sleep(time.Second) fmt.Println(\"I got scheduled!\") } 2.7.2 7.2 基于信号的抢占式调度 程序启动时，在 runtime.sighandler 中注册 _SIGURG 信号的处理函数 runtime.doSigPreempt; 此时有一个 M1 通过 signalM 函数向 M2 发送中断信号 _SIGURG； M2 收到信号，操作系统中断其执行代码，并切换到信号处理函数runtime.doSigPreempt； M2 调用 runtime.asyncPreempt 修改执行的上下文，重新进入调度循环进而调度其他 G； ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175210/:2:7","tags":null,"title":"1-4.Go协程调度原理及GPM模型","uri":"/lang/go/go_advanced/20250515175210/"},{"categories":null,"content":"\rGo语言中的并发编程","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175207/:0:0","tags":null,"title":"1-3.Go语言中的并发编程","uri":"/lang/go/go_advanced/20250515175207/"},{"categories":null,"content":"\r1 1. 并发与并行 并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。 并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。 Go语言的并发通过goroutine实现, 协程。goroutine类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个goroutine并发工作。goroutine是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。 Go语言还提供channel在多个goroutine间进行通信。goroutine和channel是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175207/:1:0","tags":null,"title":"1-3.Go语言中的并发编程","uri":"/lang/go/go_advanced/20250515175207/"},{"categories":null,"content":"\r2 2. goroutine在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？ Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。 在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。 2.0.1 2.1 使用goroutineGo语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。 一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。 2.0.2 2.2 启动单个goroutine启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字。 举个例子如下： func hello() { fmt.Println(\"Hello Goroutine!\") } func main() { hello() fmt.Println(\"main goroutine done!\") } 这个示例中hello函数和下面的语句是串行的，执行的结果是打印完Hello Goroutine!后打印main goroutine done!。 接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数。 func main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\"main goroutine done!\") } 这一次的执行结果只打印了main goroutine done!，并没有打印Hello Goroutine!。为什么呢？ 在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。 当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。 所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是time.Sleep了。 func main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\"main goroutine done!\") time.Sleep(time.Second) } 执行上面的代码你会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!。 首先为什么会先打印main goroutine done!是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。 2.0.3 2.3 启动多个goroutine在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步） var wg sync.WaitGroup func hello(i int) { defer wg.Done() // goroutine结束就登记-1 fmt.Println(\"Hello Goroutine!\", i) } func main() { for i := 0; i \u003c 10; i++ { wg.Add(1) // 启动一个goroutine就登记+1 go hello(i) } wg.Wait() // 等待所有登记的goroutine都结束 } 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175207/:2:0","tags":null,"title":"1-3.Go语言中的并发编程","uri":"/lang/go/go_advanced/20250515175207/"},{"categories":null,"content":"\r3 3. goroutine与线程\r3.0.4 3.1 可增长的栈 OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的goroutine也是可以的。 3.0.5 3.2 goroutine调度 GPM模型GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。 G, goroutine缩写, 很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。 P, process缩写, 管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。 M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的； P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。 P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。 单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。 3.0.6 3.3 GPM详解点我了解更多 3.0.7 3.4 GOMAXPROCS m:n 线程模型 M个用户态线程倚在N个核心线程身上， N个核心线程可能阻塞。每个核心态线程对应一个或多个用户态线程，至少包含一个调度线程。 M，一般只受资源或系统值限制。而对于N，一般受CPU数限制，如果核心线程阻塞 Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。 Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。 Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。 我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子： func a() { for i := 1; i \u003c 10; i++ { fmt.Println(\"A:\", i) } } func b() { for i := 1; i \u003c 10; i++ { fmt.Println(\"B:\", i) } } func main() { runtime.GOMAXPROCS(1) go a() go b() time.Sleep(time.Second) } 两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。 func a() { for i := 1; i \u003c 10; i++ { fmt.Println(\"A:\", i) } } func b() { for i := 1; i \u003c 10; i++ { fmt.Println(\"B:\", i) } } func main() { runtime.GOMAXPROCS(2) go a() go b() time.Sleep(time.Second) } Go语言中的操作系统线程和goroutine的关系： 一个操作系统线程对应用户态多个goroutine。 go程序可以同时使用多个操作系统线程。 goroutine和OS线程是多对多的关系，即m:n。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175207/:3:0","tags":null,"title":"1-3.Go语言中的并发编程","uri":"/lang/go/go_advanced/20250515175207/"},{"categories":null,"content":"\r4 4. channel 空读写阻塞，写关闭异常，读关闭空零 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。 虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。 Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。 如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。 Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。 4.0.8 4.1 channel类型channel是一种类型，一种引用类型。声明通道类型的格式如下： var 变量 chan 元素类型 举几个例子： var ch1 chan int // 声明一个传递整型的通道 var ch2 chan bool // 声明一个传递布尔型的通道 var ch3 chan []int // 声明一个传递int切片的通道 4.0.9 4.2 创建channel通道是引用类型，通道类型的空值是nil。 var ch chan int fmt.Println(ch) // \u003cnil\u003e 声明的通道后需要使用make函数初始化之后才能使用。 创建channel的格式如下： make(chan 元素类型, [缓冲大小]) channel的缓冲大小是可选的。 举几个例子： ch4 := make(chan int) ch5 := make(chan bool) ch6 := make(chan []int) 4.0.10 4.3 channel操作通道有发送（send）、接收(receive）和关闭（close）三种操作。 发送和接收都使用\u003c-符号。 现在我们先使用以下语句定义一个通道： ch := make(chan int) 4.0.10.1 发送 将一个值发送到通道中。 ch \u003c- 10 // 把10发送到ch中 4.0.10.2 接收 从一个通道中接收值。 x := \u003c- ch // 从ch中接收值并赋值给变量x \u003c-ch // 从ch中接收值，忽略结果 4.0.10.3 关闭 我们通过调用内置的close函数来关闭通道。 close(ch) 关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。 关闭后的通道有以下特点： 对一个关闭的通道再发送值就会导致panic。 对一个关闭的通道进行接收会一直获取值直到通道为空。 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的通道会导致panic。 4.0.11 4.4 无缓冲的通道无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码： func main() { ch := make(chan int) ch \u003c- 10 fmt.Println(\"发送成功\") } 上面这段代码能够通过编译，但是执行的时候会出现以下错误： fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.main() .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54 为什么会出现deadlock错误呢？ 因为我们使用ch := make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。 上面的代码会阻塞在ch \u003c- 10这一行代码形成死锁，那如何解决这个问题呢？ 一种方法是启用一个goroutine去接收值，例如： func recv(c chan int) { ret := \u003c-c fmt.Println(\"接收成功\", ret) } func main() { ch := make(chan int) go recv(ch) // 启用goroutine从通道接收值 ch \u003c- 10 fmt.Println(\"发送成功\") } 无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。 使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。 4.0.12 4.5 有缓冲的通道解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如： func main() { ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道 ch \u003c- 10 fmt.Println(\"发送成功\") } 只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。 我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。 4.0.13 4.6 for range从通道循环取值当向通道中发送完数据时，我们可以通过close函数来关闭通道。 当通道被关闭时，再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？ 我们来看下面这个例子： // channel 练习 func main() { ch1 := make(chan int) ch2 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 go func() { for i := 0; i \u003c 100; i++ { ch1 \u003c- i } close(ch1) }() // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中 go func() { for { i, ok := \u003c-ch1 // 通道关闭后再取值ok=false if !ok { break } ch2 \u003c- i * i } close(ch2) }() // 在主goroutine中从ch2中接收值打印 for i := range ch2 { // 通道关闭后会退出for range循环 fmt.Println(i) } } 从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是for range的方式。使用for range遍历通道，当通道被关闭的时候就会退出for range。 4.0.14 4.7 单向通道有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。 Go语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下： func counter(out chan\u003c- int) { for i := 0; i \u003c 100; i++ { out \u003c- i } close(out) } func squarer(out chan\u003c- int, in \u003c-chan int) { for i := range in { out \u003c- i * i } close(out) } func printer(in \u003c-chan int) { for i := range in { fmt.Println(i) } } func main() { ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2) } 其中， chan\u003c- int是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作； \u003c-chan int是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。 在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。 4.0.15 4.8 通道总结 空读写阻塞，写关闭异常，读关闭空零 channel常见的异常总结，如下图： 关闭已经关闭的channel也会引发panic。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175207/:4:0","tags":null,"title":"1-3.Go语言中的并发编程","uri":"/lang/go/go_advanced/20250515175207/"},{"categories":null,"content":"\r5 5. worker pool（goroutine池）在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。 一个简易的work pool示例代码如下： func worker(id int, jobs \u003c-chan int, results chan\u003c- int) { for j := range jobs { fmt.Printf(\"worker:%d start job:%d\\n\", id, j) time.Sleep(time.Second) fmt.Printf(\"worker:%d end job:%d\\n\", id, j) results \u003c- j * 2 } } func main() { jobs := make(chan int, 100) results := make(chan int, 100) // 开启3个goroutine for w := 1; w \u003c= 3; w++ { go worker(w, jobs, results) } // 5个任务 for j := 1; j \u003c= 5; j++ { jobs \u003c- j } close(jobs) // 输出结果 for a := 1; a \u003c= 5; a++ { \u003c-results } } ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175207/:5:0","tags":null,"title":"1-3.Go语言中的并发编程","uri":"/lang/go/go_advanced/20250515175207/"},{"categories":null,"content":"\r6 6. select多路复用 select 基于回调 poll epoll 在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现： for{ // 尝试从ch1接收值 data, ok := \u003c-ch1 // 尝试从ch2接收值 data, ok := \u003c-ch2 … } 这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。 select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下： select{ case \u003c-ch1: ... case data := \u003c-ch2: ... case ch3\u003c-data: ... default: 默认操作 } 举个小例子来演示下select的使用： func main() { ch := make(chan int, 1) for i := 0; i \u003c 10; i++ { select { case x := \u003c-ch: fmt.Println(x) case ch \u003c- i: } } } 使用select语句能提高代码的可读性。 可处理一个或多个channel的发送/接收操作。 如果多个case同时满足，select会随机选择一个。 对于没有case的select{}会一直等待，可用于阻塞main函数。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175207/:6:0","tags":null,"title":"1-3.Go语言中的并发编程","uri":"/lang/go/go_advanced/20250515175207/"},{"categories":null,"content":"\r7 7. 并发安全和锁有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。 举个例子： var x int64 var wg sync.WaitGroup func add() { for i := 0; i \u003c 5000; i++ { x = x + 1 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。 7.0.16 7.1 互斥锁互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题： var x int64 var wg sync.WaitGroup var lock sync.Mutex func add() { for i := 0; i \u003c 5000; i++ { lock.Lock() // 加锁 x = x + 1 lock.Unlock() // 解锁 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。 7.0.17 7.2 读写互斥锁互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。 读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。 读写锁示例： var ( x int64 wg sync.WaitGroup lock sync.Mutex rwlock sync.RWMutex ) func write() { // lock.Lock() // 加互斥锁 rwlock.Lock() // 加写锁 x = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 rwlock.Unlock() // 解写锁 // lock.Unlock() // 解互斥锁 wg.Done() } func read() { // lock.Lock() // 加互斥锁 rwlock.RLock() // 加读锁 time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 rwlock.RUnlock() // 解读锁 // lock.Unlock() // 解互斥锁 wg.Done() } func main() { start := time.Now() for i := 0; i \u003c 10; i++ { wg.Add(1) go write() } for i := 0; i \u003c 1000; i++ { wg.Add(1) go read() } wg.Wait() end := time.Now() fmt.Println(end.Sub(start)) } 需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。 7.0.18 7.3 sync.WaitGroup在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。sync.WaitGroup有以下几个方法： 方法名 功能 (wg * WaitGroup) Add(delta int) 计数器+delta (wg *WaitGroup) Done() 计数器-1 (wg *WaitGroup) Wait() 阻塞直到计数器变为0 sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。 我们利用sync.WaitGroup将上面的代码优化一下： var wg sync.WaitGroup func hello() { defer wg.Done() fmt.Println(\"Hello Goroutine!\") } func main() { wg.Add(1) go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\"main goroutine done!\") wg.Wait() } 需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。 7.0.19 7.4 sync.Once说在前面的话：这是一个进阶知识点。 在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。 Go语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。 sync.Once只有一个Do方法，其签名如下： func (o *Once) Do(f func()) {} 备注：如果要执行的函数f需要传递参数就需要搭配闭包来使用。 7.0.19.1 加载配置文件示例延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子： var icons map[string]image.Image func loadIcons() { icons = map[string]image.Image{ \"left\": loadIcon(\"left.png\"), \"up\": loadIcon(\"up.png\"), \"right\": loadIcon(\"right.png\"), \"down\": loadIcon(\"down.png\"), } } // Icon 被多个goroutine调用时不是并发安全的 func Icon(name string) image.Image { if icons == nil { loadIcons() } return icons[name] } 多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果： func loadIcons() { icons = make(map[string]image.Image) icons[\"left\"] = loadIcon(\"left.png\") icons[\"up\"] = loadIcon(\"up.png\") icons[\"right\"] = loadIcon(\"right.png\") icons[\"down\"] = loadIcon(\"down.png\") } 在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题。 使用sync.Once改造的示例代码如下： var icons map[string]image.Image var loadIconsOnce sync.Once func loadIcons() { icons = map[string]image.Image{ \"left\": loadIcon(\"left.png\"), \"up\": loadIcon(\"up.png\"), \"right\": loadIcon(\"right.png\"), \"down\": loadIcon(\"down.png\"), } } // Icon 是并发安全的 func Icon(name string) image.Image { loadIconsOnce.Do(loadIcons) return icons[name] } 7.0.19.2 并发安全的单例模式下面是借助sync.Once实现的并发安全的单例模式： package singleton import ( \"sync\" ) type singleton struct {} var instance *singleton var once sync.Once func GetInstance() *singleton { once.Do(func()","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175207/:7:0","tags":null,"title":"1-3.Go语言中的并发编程","uri":"/lang/go/go_advanced/20250515175207/"},{"categories":null,"content":"\r8 8. 原子操作在上面的代码中的我们通过锁操作来实现同步。而锁机制的底层是基于原子操作的，其一般直接通过CPU指令实现。Go语言中原子操作由内置的标准库sync/atomic提供。 8.0.21 8.1 atomic包 方法 解释 func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer) 读取操作 func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer) 写入操作 func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) 修改操作 func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer) 交换操作 func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) 比较并交换操作 8.0.22 8.4 示例我们填写一个示例来比较下互斥锁和原子操作的性能。 package main import ( \"fmt\" \"sync\" \"sync/atomic\" \"time\" ) type Counter interface { Inc() Load() int64 } // 普通版 type CommonCounter struct { counter int64 } func (c CommonCounter) Inc() { c.counter++ } func (c CommonCounter) Load() int64 { return c.counter } // 互斥锁版 type MutexCounter struct { counter int64 lock sync.Mutex } func (m *MutexCounter) Inc() { m.lock.Lock() defer m.lock.Unlock() m.counter++ } func (m *MutexCounter) Load() int64 { m.lock.Lock() defer m.lock.Unlock() return m.counter } // 原子操作版 type AtomicCounter struct { counter int64 } func (a *AtomicCounter) Inc() { atomic.AddInt64(\u0026a.counter, 1) } func (a *AtomicCounter) Load() int64 { return atomic.LoadInt64(\u0026a.counter) } func test(c Counter) { var wg sync.WaitGroup start := time.Now() for i := 0; i \u003c 1000; i++ { wg.Add(1) go func() { c.Inc() wg.Done() }() } wg.Wait() end := time.Now() fmt.Println(c.Load(), end.Sub(start)) } func main() { c1 := CommonCounter{} // 非并发安全 test(c1) c2 := MutexCounter{} // 使用互斥锁实现并发安全 test(\u0026c2) c3 := AtomicCounter{} // 并发安全且比互斥锁效率更高 test(\u0026c3) } atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175207/:8:0","tags":null,"title":"1-3.Go语言中的并发编程","uri":"/lang/go/go_advanced/20250515175207/"},{"categories":null,"content":"[TOC] 一. 栈和堆 栈内存: 栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。但是可分配的内存有限 堆内存: 存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾通过GC回收. ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:0:0","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r1 1.原理 在main函数中 var arr = make([]int,9)的定义流程: 主函数先进栈，在栈中定义一个变量arr,接下来为arr赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过new关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体： 给堆分配了一个地址，把堆的地址赋给arr，arr就通过地址指向了数组。所以arr想操纵数组时，就通过地址，而不是直接把实体都赋给它。这种我们不再叫他基本数据类型，而叫引用数据类型。称为arr引用了堆内存当中的实体。(指针) 如果当int [] arr=null;arr不做任何指向，null的作用就是取消引用数据类型的指向。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:1:0","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r2 2.区别 栈内存存储的是局部变量而堆内存存储的是实体； 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短； 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。 二. python 垃圾回收 书籍: 《python源码剖析》 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:2:0","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r1 1. python内存管理 python中将所有的数据类型分为了两种；分别是:由多个元素组成的和单个元素组成的；以利用不同的结构体去区分， 分别是：pyobject结构体（_ PyObject_HEAD_EXTRA 双向链表;ob_refcnt;引用计数器；_typeobject *ob_type 表示对象类型）， 一个是pyvarobject结构体(PyObject ob_base 内部包含pyobject结构体； obsize；此对象有多少元素组成 ) 在pytho代码中，如果创建对象或者是对对象赋值，内存中会对对象做两种操作：将对象加入双向链表，引用计数加1； 如果执行对象删除操作，也会进行两步操作：引用计数器减一；如果引用计数为0，就将对象从链表中剔除； ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:3:0","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r2 2. python 垃圾回收 垃圾回收机制是以引用计数为主，以分代回收和标记清楚为辅； 引用计数 在pytho代码中，如果创建对象或者是对对象赋值，内存中会对对象做两种操作：将对象加入双向链表，引用计数加1；如果执行对象删除操作，也会进行两步操作：引用计数器减一；如果引用计数为0，就将对象从链表中剔除； **标记清除：引用计数可以满足基本的内存管理和垃圾回收，但是无法解决\"循环引用\"的问题,所以存在标记清除;**只有多个元素组成的才会产生循环引用； # 循环引用 v1= [1,2] v2=[3,4] v1.append(v2) v2.append(v1) # 在python内部维护了两个双向链表，一个单个元素组成，一个是多个元素组成的；在垃圾回收机制（GC）中会定期扫描由多个元素组成的链表，如果发现有循环引用存在，那么引用计数分别减一； 分代回收： 分代回收：在python中为由多个元素的组成的类型（可能存在循环引用），为这些元素维护了三个双向链表，分别称为0代1代2代；python中为这三个链表设置了一个阈值，分别是700，10，10；（参数说明：如果第0代的链表中有700个对象时，进行一次扫描；0代扫描十次，一代扫描一次；一代扫描十次，二代扫描一次；极大的减少了扫描元素的个数） 0代链表中item的个数达到700时进行十次扫描，标记清除，引用计数为0的从双向链表中删除； 三. Golang 垃圾回收","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:4:0","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r1 1. Go-v1.3 标记清除 标记-清除(mark and sweep)算法 第一步, 标记 暂停程序业务逻辑, 分类出可达和不可达的对象，然后做上标记。如下如, 目前程序可达对象仅1,2,3,4,7五个对象, 对这五个对象进行标记(mark) 第二步,需要程序暂停, 然后清除对象5和对象6, 程序会暂定停止任何工作，卡在那等待回收执行完毕。 第三部, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:5:0","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r1.1 1.1 缺点 STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)； 标记需要扫描整个heap； 清除数据会产生heap碎片。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:5:1","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r2 2. Go-v1.5 三色标记+屏障机制 标记清除最大的缺点就是存在 STW需要程序暂停才能进行垃圾回收, 造成性能问题. v1.5使用三色标记+屏障机制 解决STW问题 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:6:0","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r2.1 2.1 三色标记\r2.1.0.1 2.1.1 原理 第一步 , 每次新创建的对象，默认的颜色都是标记为“白色”，如图所示。 第二步, 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合如图所示。 要注意的是，本次遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。 第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，如图所示。 第四步, 重复第三步, 直到灰色中无任何对象，如图所示。 当我们全部的可达对象都遍历完后，灰色标记表将不再存在灰色对象，目前全部内存的数据只有两种颜色，黑色和白色。那么黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除，白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。 第五步: 回收所有的白色标记表的对象. 也就是回收垃圾，如图所示。将全部的白色对象进行删除回收，剩下的就是全部依赖的黑色对象。 2.1.0.2 2.1.2 缺点 为了保证数据安全, 仍然存在 STW 缺陷 如果没有STW的三色标记法 第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。 现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。 与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。 然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。对象3只能等待被清除, 产生错误! 最后本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:6:1","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r2.2 2.2 屏障机制\r2.2.0.3 2.2.1 强弱三色不变式 强三色不变式: 不存在黑色对象引用到白色对象的指针。 强三色不变式实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。 若三色不变式: 所有被黑色对象引用的白色对象都处于灰色保护状态。 弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。 2.2.0.4 2.2.2 屏障机制 为了遵循上述的强弱三色不变式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。 插入屏障 具体操作: 在黑色A对象引用白色B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色) 满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色) 删除屏障 具体操作: 被破坏的对象，如果自身为灰色或者白色，那么被标记为灰色。 满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断) 2.2.0.5 2.2.3 缺点 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活； 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:6:2","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r3 3. Go-v1.8+ 三色标记 + 混合写屏障 Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。 注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:7:0","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r3.1 3.1 混合写屏障原理 注意: 混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。 GC开始将栈上的可达对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，栈上不再启用屏障, 只有堆启用屏障. GC期间，任何在栈上创建的新对象，均为黑色。 栈上被删除的对象标记为灰色。 栈上被添加的对象标记为灰色。 满足: 变形的强弱三色不变式.结合了插入/删除屏障的优点 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:7:1","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r3.2 3.2 混合写屏障的具体场景 GC开始：扫描栈区，将可达对象全部标记为黑 3.2.0.6 3.2.1 场景一 对象被一个堆对象删除引用，成为栈对象的下游(A引用B, A就是B的下游) 前提： 堆对象4-\u003e对象7 = 对象7； //对象7 被 对象4引用 栈对象1-\u003e对象7 = 堆对象7； //将堆对象7 挂在 栈对象1 下游 堆对象4-\u003e对象7 = null； //对象4 删除引用 对象7 3.2.0.7 3.2.2 场景二 对象被一个栈对象删除引用，成为另一个栈对象的下游 new 栈对象9； 对象8-\u003e对象3 = 对象3； //将栈对象3 挂在 栈对象9 下游 对象2-\u003e对象3 = null； //对象2 删除引用 对象3 四. GC触发时机 主动调用runtime.GC 当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟 当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。 申请内存触发 runtime.mallocgc Go运行时会将堆上的对象按大小分成微对象、小对象和大对象三类，这三类对象的创建都可能会触发新的GC 当前线程的内存管理单元中不存在空闲空间时，创建微对象 (noscan\u0026\u0026size\u003cmaxTinySize)和小对象需要调用 runtime.mcache.nextFree从中心缓存或者页堆中获取新的管理单元，这时如果span满了就会导致返回的 shouldhelpgc=true，就可能触发垃圾收集； 当用户程序申请分配 32KB 以上的大对象时，一定会构建 runtime.gcTrigger结构体尝试触发垃圾收集； // src/runtime/mgc.go func (t gcTrigger) test() bool { if !memstats.enablegc || panicking != 0 || gcphase != _GCoff { return false } switch t.kind { case gcTriggerHeap: // Non-atomic access to gcController.heapLive for performance. If // we are going to trigger on this, this thread just // atomically wrote gcController.heapLive anyway and we'll see our // own write. return gcController.heapLive \u003e= gcController.trigger // 是否触发gc case gcTriggerTime: if gcController.gcPercent \u003c 0 { return false } lastgc := int64(atomic.Load64(\u0026memstats.last_gc_nanotime)) return lastgc != 0 \u0026\u0026 t.now-lastgc \u003e forcegcperiod case gcTriggerCycle: // t.n \u003e work.cycles, but accounting for wraparound. return int32(t.n-work.cycles) \u003e 0 } return true } 这个时候调用 t.test()执行的是 gcTriggerHeap情况，只需要判断 gcController.heapLive\u003e=gcController.trigger的真假就可以了。heapLive 表示垃圾收集中存活对象字节数， trigger表示触发标记的堆内存大小的；当内存中存活的对象字节数大于触发垃圾收集的堆大小时，新一轮的垃圾收集就会开始。 heapLive — 为了减少锁竞争，运行时只会在中心缓存分配或者释放内存管理单元以及在堆上分配大对象时才会更新； trigger — 在标记终止阶段调用 runtime.gcSetTriggerRatio 更新触发下一次垃圾收集的堆大小，它能够决定触发垃圾收集的时间以及用户程序和后台处理的标记任务的多少，利用反馈控制的算法根据堆的增长情况和垃圾收集 CPU 利用率确定触发垃圾收集的时机。 五. Golang GC总结 v1.3 使用标记清除, 存在STW(stop the word)机制, 垃圾回收时程序暂停, 效率低下 v1.5 三色标记法 + 删除/插入屏障 : 栈空间不动, 堆空间全部重新扫描,存在STW(stop the word)机制, 效率低下. vGoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175202/:7:2","tags":null,"title":"1-2.Go垃圾回收机制","uri":"/lang/go/go_advanced/20250515175202/"},{"categories":null,"content":"\r一. 内存为什么需要管理？ 我们将大部分程序逻辑临时用的数据，全部都存在内存之中，比如，变量、全局变量、函数跳转地址、静态库、执行代码、临时开辟的内存结构体(对象)等。 当我们希望存储的东西越来越多，也就发现物理内存的容量依然是不够用，那么对物理内存的利用率和合理的分配，管理就变得非常的重要。 1、首先操作系统就会对内存进行非常详细的管理， 2、其次基于操作系统的基础上，不同语言的内存管理机制也应允而生，但是有的一些语言并没有提供自动的 内存管理模式，有的语言就已经提供了自身程序的内存管理模式： 内存自动管理的语言(部分) 非自动管理的语言(部分) Golang C Java C++ Python Rust 二. Go内存管理 Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。 Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的TCMalloc算法，全称Thread-Caching Malloc。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175156/:0:0","tags":null,"title":"1-1.Go内存管理","uri":"/lang/go/go_advanced/20250515175156/"},{"categories":null,"content":"\r1 1. 基础概念 Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理。 申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。 arena区域就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成8KB大小的页，一些页组合起来称为mspan。 bitmap区域标识arena区域哪些地址保存了对象，并且用4bit标志位表示对象是否包含指针、GC标记信息。bitmap中一个byte大小的内存对应arena区域中4个指针大小（指针大小为 8B ）的内存，所以bitmap区域的大小是512GB/(4*8B)=16GB。 从上图其实还可以看到bitmap的高地址部分指向arena区域的低地址部分，也就是说bitmap的地址是由高地址向低地址增长的。 spans区域存放mspan（也就是一些arena分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以spans区域的大小就是512GB/8KB*8B=512MB。除以8KB是计算arena区域的页数，而最后乘以8是计算spans区域所有指针的大小。创建mspan的时候，按页填充对应的spans区域，在回收object时，根据地址很容易就能找到它所属的mspan。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175156/:1:0","tags":null,"title":"1-1.Go内存管理","uri":"/lang/go/go_advanced/20250515175156/"},{"categories":null,"content":"\r2 2. 内存管理单元 mspan：Go中内存管理的基本单元，是由一片连续的8KB的页组成的大块内存。注意，这里的页和操作系统本身的页并不是一回事，它一般是操作系统页大小的几倍。一句话概括：mspan是一个包含起始地址、mspan规格、页的数量等内容的双端链表。 每个mspan按照它自身的属性Size Class的大小分割成若干个object，每个object可存储一个对象。并且会使用一个位图来标记其尚未使用的object。属性Size Class决定object大小，而mspan只会分配给和object尺寸大小接近的对象，当然，对象的大小要小于object大小。还有一个概念：Span Class，它和Size Class的含义差不多 Size_Class = Span_Class / 2 这是因为其实每个 Size Class有两个mspan，也就是有两个Span Class。其中一个分配给含有指针的对象，另一个分配给不含有指针的对象。这会给垃圾回收机制带来利好，之后的文章再谈。 如下图，mspan由一组连续的页组成，按照一定大小划分成object。 Go1.9.2里mspan的Size Class共有67种，每种mspan分割的object大小是8*2n的倍数，这个是写死在代码里的： // path: /usr/local/go/src/runtime/sizeclasses.go const _NumSizeClasses = 67 var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536,1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768} 根据mspan的Size Class可以得到它划分的object大小。 比如Size Class等于3，object大小就是32B。 32B大小的object可以存储对象大小范围在17B~32B的对象。而对于微小对象（小于16B），分配器会将其进行合并，将几个对象分配到同一个object中。 数组里最大的数是32768，也就是32KB，超过此大小就是大对象了，它会被特别对待，这个稍后会再介绍。顺便提一句，类型Size Class为0表示大对象，它实际上直接由堆内存分配，而小对象都要通过mspan来分配。 对于mspan来说，它的Size Class会决定它所能分到的页数，这也是写死在代码里的： // path: /usr/local/go/src/runtime/sizeclasses.go const _NumSizeClasses = 67 var class_to_allocnpages = [_NumSizeClasses]uint8{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 2, 3, 1, 3, 2, 3, 4, 5, 6, 1, 7, 6, 5, 4, 3, 5, 7, 2, 9, 7, 5, 8, 3, 10, 7, 4} 比如当我们要申请一个object大小为32B的mspan的时候，在class_to_size里对应的索引是3，而索引3在class_to_allocnpages数组里对应的页数就是1。 mspan结构体定义： // path: /usr/local/go/src/runtime/mheap.go type mspan struct { //链表前向指针，用于将span链接起来 next *mspan //链表前向指针，用于将span链接起来 prev *mspan // 起始地址，也即所管理页的地址 startAddr uintptr // 管理的页数 npages uintptr // 块个数，表示有多少个块可供分配 nelems uintptr //分配位图，每一位代表一个块是否已分配 allocBits *gcBits // 已分配块的个数 allocCount uint16 // class表中的class ID，和Size Classs相关 spanclass spanClass // class表中的对象大小，也即块大小 elemsize uintptr } 我们将mspan放到更大的视角来看： 上图可以看到有两个S指向了同一个mspan，因为这两个S指向的P是同属一个mspan的。所以，通过arena上的地址可以快速找到指向它的S，通过S就能找到mspan，回忆一下前面我们说的mspan区域的每个指针对应一页。 假设最左边第一个mspan的Size Class等于10，根据前面的class_to_size数组，得出这个msapn分割的object大小是144B，算出可分配的对象个数是8KB/144B=56.89个，取整56个，所以会有一些内存浪费掉了，Go的源码里有所有Size Class的mspan浪费的内存的大小；再根据class_to_allocnpages数组，得到这个mspan只由1个page组成；假设这个mspan是分配给无指针对象的，那么spanClass等于20。 startAddr直接指向arena区域的某个位置，表示这个mspan的起始地址，allocBits指向一个位图，每位代表一个块是否被分配了对象；allocCount则表示总共已分配的对象个数。 这样，左起第一个mspan的各个字段参数就如下图所示： ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175156/:2:0","tags":null,"title":"1-1.Go内存管理","uri":"/lang/go/go_advanced/20250515175156/"},{"categories":null,"content":"\r3 3. 内存管理组件 内存分配由内存分配器完成。分配器由3种组件构成：mcache, mcentral, mheap。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175156/:3:0","tags":null,"title":"1-1.Go内存管理","uri":"/lang/go/go_advanced/20250515175156/"},{"categories":null,"content":"\r3.1 a. mcache mcache：每个工作线程都会绑定一个mcache，本地缓存可用的mspan资源，这样就可以直接给Goroutine分配，因为不存在多个Goroutine竞争的情况，所以不会消耗锁资源。 mcache的结构体定义： //path: /usr/local/go/src/runtime/mcache.go type mcache struct { alloc [numSpanClasses]*mspan } numSpanClasses = _NumSizeClasses \u003c\u003c 1 mcache用Span Classes作为索引管理多个用于分配的mspan，它包含所有规格的mspan。它是_NumSizeClasses的2倍，也就是67*2=134，为什么有一个两倍的关系，前面我们提到过：为了加速之后内存回收的速度，数组里一半的mspan中分配的对象不包含指针，另一半则包含指针。 对于无指针对象的mspan在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。 mcache在初始化的时候是没有任何mspan资源的，在使用过程中会动态地从mcentral申请，之后会缓存下来。当对象小于等于32KB大小时，使用mcache的相应规格的mspan进行分配。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175156/:3:1","tags":null,"title":"1-1.Go内存管理","uri":"/lang/go/go_advanced/20250515175156/"},{"categories":null,"content":"\r3.2 b. mcentral mcentral：为所有mcache提供切分好的mspan资源。每个central保存一种特定大小的全局mspan列表，包括已分配出去的和未分配出去的。 每个mcentral对应一种mspan，而mspan的种类导致它分割的object大小不同。当工作线程的mcache中没有合适（也就是特定大小的）的mspan时就会从mcentral获取。 mcentral被所有的工作线程共同享有，存在多个Goroutine竞争的情况，因此会消耗锁资源。结构体定义： //path: /usr/local/go/src/runtime/mcentral.go type mcentral struct { // 互斥锁 lock mutex // 规格 sizeclass int32 // 尚有空闲object的mspan链表 nonempty mSpanList // 没有空闲object的mspan链表，或者是已被mcache取走的msapn链表 empty mSpanList // 已累计分配的对象个数 nmalloc uint64 } empty表示这条链表里的mspan都被分配了object，或者是已经被cache取走了的mspan，这个mspan就被那个工作线程独占了。而nonempty则表示有空闲对象的mspan列表。每个central结构体都在mheap中维护。 简单说下mcache从mcentral获取和归还mspan的流程： 获取 加锁；从nonempty链表找到一个可用的mspan；并将其从nonempty链表删除；将取出的mspan加入到empty链表；将mspan返回给工作线程；解锁。 归还 加锁；将mspan从empty链表删除；将mspan加入到nonempty链表；解锁。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175156/:3:2","tags":null,"title":"1-1.Go内存管理","uri":"/lang/go/go_advanced/20250515175156/"},{"categories":null,"content":"\r3.3 c. mheap mheap：代表Go程序持有的所有堆空间，Go程序使用一个mheap的全局对象_mheap来管理堆内存。 当mcentral没有空闲的mspan时，会向mheap申请。而mheap没有资源时，会向操作系统申请新内存。mheap主要用于大对象的内存分配，以及管理未切割的mspan，用于给mcentral切割成小对象。 同时我们也看到，mheap中含有所有规格的mcentral，所以，当一个mcache从mcentral申请mspan时，只需要在独立的mcentral中使用锁，并不会影响申请其他规格的mspan。 mheap结构体定义： //path: /usr/local/go/src/runtime/mheap.go type mheap struct { lock mutex // spans: 指向mspans区域，用于映射mspan和page的关系 spans []*mspan // 指向bitmap首地址，bitmap是从高地址向低地址增长的 bitmap uintptr // 指示arena区首地址 arena_start uintptr // 指示arena区已使用地址位置 arena_used uintptr // 指示arena区末地址 arena_end uintptr central [67*2]struct { mcentral mcentral pad [sys.CacheLineSize - unsafe.Sizeof(mcentral{})%sys.CacheLineSize]byte } } 上图我们看到，bitmap和arena_start指向了同一个地址，这是因为bitmap的地址是从高到低增长的，所以他们指向的内存位置相同。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175156/:3:3","tags":null,"title":"1-1.Go内存管理","uri":"/lang/go/go_advanced/20250515175156/"},{"categories":null,"content":"\r4 7. 分配流程 变量是在栈上分配还是在堆上分配，是由逃逸分析的结果决定的。通常情况下，编译器是倾向于将变量分配到栈上的，因为它的开销小，最极端的就是\"zero garbage\"，所有的变量都会在栈上分配，这样就不会存在内存碎片，垃圾回收之类的东西。 Go的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）。 大体上的分配流程： \u003e32KB 的对象，直接从mheap上分配； \u003c=16B 的对象使用mcache的tiny分配器分配； (16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配； 如果mcache没有相应规格大小的mspan，则向mcentral申请 如果mcentral没有相应规格大小的mspan，则向mheap申请 如果mheap中也没有合适大小的mspan，则向操作系统申请 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175156/:4:0","tags":null,"title":"1-1.Go内存管理","uri":"/lang/go/go_advanced/20250515175156/"},{"categories":null,"content":"\r5 8. 总结 Go语言的内存分配非常复杂，它的一个原则就是能复用的一定要复用。一般而言，了解它的原理，到这个程度也可以了。 Go在程序启动时，会向操作系统申请一大块内存，之后自行管理。 Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。 mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的mspan；mcentral管理全局的mspan供所有线程使用；mheap管理Go的所有动态分配内存。 极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。 ","date":"2025-05-15","objectID":"/lang/go/go_advanced/20250515175156/:5:0","tags":null,"title":"1-1.Go内存管理","uri":"/lang/go/go_advanced/20250515175156/"},{"categories":null,"content":" 在go语言里，对泛型的争议从未停止过，go也在1.18支持了泛型 原文参考：https://www.jb51.net/article/277511.htm ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:0:0","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r泛型初识 在强类型语言中（java，go），因为存在类型的强制约束，导致了数据类型在应用时没有弱类型语言（go、python）灵活 问题假如一个求和函数, 无法计算int类型之外的和.如果想计算浮点或者字符串的和该怎么办？ func Add(a int, b int) int { return a + b } 泛型引入之前，解决办法之一就是为不同类型定义不同的函数 func AddFloat32(a float32, b float32) float32 { return a + b } func AddString(a string, b string) string { return a + b } 在引入泛型之后 func[T int | float32 | string](a, b T) T { return a + b } 在上面这段伪代码中， T 被称为 类型形参(type parameter)，它不是具体的类型，在定义函数时类型并不确定。因为 T 的类型并不确定，所以需要像函数的形参那样，在调用函数的时候再传入具体的类型。这样我们不就能一个函数同时支持多个不同的类型了, 在这里被传入的具体类型被称为 类型实参(type argument) 通过引入 类型形参 和 类型实参 这两个概念，让一个函数获得了处理多种不同类型数据的能力，这种编程方式被称为 泛型编程 通过Go的 接口+反射 不也能实现这样的动态数据处理吗？是的，泛型能实现的功能通过接口+反射也基本能实现, 但是go的反射机制存在很多问题：用起来麻烦、失去了编译时的类型检查、性能不太理想 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:1:0","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r泛型基础概念 通过引入 类型形参 和 类型实参 这两个概念，让一个函数获得了处理多种不同类型数据的能力，这种编程方式被称为 泛型编程 Go在1.18 泛型中引入了很多全新的概念 类型形参 (Type parameter): type Slice[T int|float32|float64 ] []T T 就是类型形参(Type parameter)在定义Slice类型的时候 T 代表的具体类型并不确定，类似一个占位符 类型实参(Type argument) var b Slice[float32] = []float32{1.0, 2.0, 3.0} float32 就是类型实参 类型形参列表( Type parameter list) 中括号里的T int|float32|float64 这一整串因为定义了所有的类型形参(在这个例子里只有一个类型形参T），所以我们称其为 类型形参列表(type parameter list) 类型约束(Type constraint) 类型约束 指定了类型形参可接受的类型集合，只有属于这个集合中的类型才能替换形参用于实例化 int|float32|float64 这部分被称为类型约束(Type constraint)，中间的 | 的意思是告诉编译器，类型形参 T 只可以接收 int 或 float32 或 float64 这三种类型的实参 泛型类型(Generic type) type Slice[T int|float32|float64 ] []T这种类型定义的方式中带了类型形参，将这种类型定义中带 类型形参 的类型，称之为 泛型类型(Generic type) 实例化(Instantiations) var a Slice[int] = []int{1, 2, 3} 泛型类型不能直接拿来使用，必须传入类型实参(Type argument) 将其确定为具体的类型之后才可使用。而传入类型实参确定具体类型的操作被称为 实例化(Instantiations) : 泛型接收器(Generic receiver) 泛型函数(Generic function) … ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:2:0","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r泛型基本使用","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:3:0","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r1. demo // 定义了一个普通的类型 Slice[int] ，它的底层类型是 []int type Slice[int] []int // MyMap类型定义了两个类型形参 KEY 和 VALUE。分别为两个形参指定了不同的类型约束 // 这个泛型类型的名字叫： MyMap[KEY, VALUE] type MyMap[KEY int | string, VALUE float32 | float64] map[KEY]VALUE // 用类型实参 string 和 flaot64 替换了类型形参 KEY 、 VALUE，泛型类型被实例化为具体的类型：MyMap[string, float64] var a MyMap[string, float64] = map[string]float64{ \"jack_score\": 9.6, \"bob_score\": 8.4, } // 一个泛型类型的结构体。可用 int 或 sring 类型实例化 type MyStruct[T int | string] struct { Name string Data T } // 一个泛型接口(关于泛型接口在后半部分会详细讲解） type IPrintData[T int | float32 | string] interface { Print(data T) } // 一个泛型通道，可用类型实参 int 或 string 实例化 type MyChan[T int | string] chan T ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:3:1","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r2. 类型形参的互相套用和约束 类型形参是可以互相套用 type WowStruct[T int | float32, S []T] struct { Data S MaxValue T MinValue T } // 实例化 var ws WowStruct[int, []int] // 泛型类型 WowStuct[T, S] 被实例化后的类型名称就叫 WowStruct[int, []int] 上面为T传入了实参 int，然后因为 S 的定义是 []T ，所以 S 的实参自然是 []int ，实例化之后 WowStruct[T,S] 的定义类似如下 type WowStruct[int, []int] struct { Data []int MaxValue int MinValue int } 下面两种定义作用一样 type WowStruct[T int|string] struct { Name string Data []T } type WowStruct2[T []int|[]string] struct { Name string Data T } 推荐使用方式 ype WowStruct3[T int | string] struct { Data []T MaxValue T MinValue T } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:3:2","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r3. 泛型的嵌套和约束 泛型和普通的类型一样，可以互相嵌套定义出更加复杂的新类型 // 先定义个泛型类型 Slice[T] type Slice[T int|string|float32|float64] []T // ✗ 错误。泛型类型Slice[T]的类型约束中不包含uint, uint8 type UintSlice[T uint|uint8] Slice[T] // ✓ 正确。基于泛型类型Slice[T]定义了新的泛型类型 FloatSlice[T] 。FloatSlice[T]只接受float32和float64两种类型 type FloatSlice[T float32|float64] Slice[T] // ✓ 正确。基于泛型类型Slice[T]定义的新泛型类型 IntAndStringSlice[T] type IntAndStringSlice[T int|string] Slice[T] // ✓ 正确 基于IntAndStringSlice[T]套娃定义出的新泛型类型 type IntSlice[T int] IntAndStringSlice[T] // 在map中套一个泛型类型Slice[T] type WowMap[T int|string] map[string]Slice[T] // 在map中套Slice[T]的另一种写法 type WowMap2[T Slice[int] | Slice[string]] map[string]T ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:3:3","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r4. 动态判断变量的类型 使用接口的时候经常会用到类型断言或 type swith 来确定接口具体的类型，然后对不同类型做出不同的处理; var i interface{} = 123 i.(int) // 类型断言 // type switch switch i.(type) { case int: // do something case string: // do something default: // do something } } 对于 valut T 这样通过类型形参定义的变量，我们能不能判断具体类型然后对不同类型做出不同处理呢？答案是不允许的 func (q *Queue[T]) Put(value T) { value.(int) // 错误。泛型类型定义的变量不能使用类型断言 // 错误。不允许使用type switch 来判断 value 的具体类型 switch value.(type) { case int: // do something case string: // do something default: // do something } // ... } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:3:4","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r5. ~ 指定底层类型 var s1 Slice[int] // 正确 type MyInt int var s2 Slice[MyInt] // ✗ 错误。MyInt类型底层类型是int但并不是int类型，不符合 Slice[T] 的类型约束 泛型类型 Slice[T] 允许的是 int 作为类型实参，而不是 MyInt （虽然 MyInt 类型底层类型是int，但它依旧不是 int 类型） 为了解决这个问题，Go新增了一个符号 ~ ，在类型约束中使用类似 ~int 这种写法的话，就代表着不光是 int ，所有以 int 为底层类型的类型也都可用于实例化 ~使用限制 ~后面的类型不能为接口 ~后面的类型必须为基本类型 demo type Int interface { ~int | ~int8 | ~int16 | ~int32 | ~int64 } type Uint interface { ~uint | ~uint8 | ~uint16 | ~uint32 } type Float interface { ~float32 | ~float64 } type Slice[T Int | Uint | Float] []T var s Slice[int] // 正确 type MyInt int var s2 Slice[MyInt] // MyInt底层类型是int，所以可以用于实例化 type MyMyInt MyInt var s3 Slice[MyMyInt] // 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化 type MyFloat32 float32 // 正确 var s4 Slice[MyFloat32] ---------------------------------- type MyInt int type _ interface { ~[]byte // 正确 ~MyInt // 错误，~后的类型必须为基本类型 ~error // 错误，~后的类型不能为接口 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:3:5","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r6. 常见使用错误 定义泛型类型的时候，基础类型不能只有类型形参 // 错误，类型形参不能单独使用 type CommonType[T int|string|float32] T 当类型约束的一些写法会被编译器误认为是表达式时会报错 //✗ 错误。T *int会被编译器误认为是表达式 T乘以int，而不是int指针 type NewType[T *int] []T // 上面代码再编译器眼中：它认为你要定义一个存放切片的数组，数组长度由 T 乘以 int 计算得到 type NewType [T * int][]T //✗ 错误。和上面一样，这里不光*被会认为是乘号，| 还会被认为是按位或操作 type NewType2[T *int|*float64] []T //✗ 错误 type NewType2 [T (int)] []T ///////////// 解决方式 ///////////// // 推荐统一用 interface{} 解决问题 type NewType[T interface{*int}] []T type NewType2[T interface{*int|*float64}] []T // 如果类型约束中只有一个类型，可以添加个逗号消除歧义 type NewType3[T *int,] []T //✗ 错误。如果类型约束不止一个类型，加逗号是不行的 type NewType4[T *int|*float32,] []T 匿名结构体不支持泛型 // 下面的用法是错误的： testCase := struct[T int|string] { caseName string got T want T }[int]{ caseName: \"test OK\", got: 100, want: 100, } 虽然type switch和类型断言不能用，但我们可通过反射机制达到目的： func (receiver Queue[T]) Put(value T) { // Printf() 可输出变量value的类型(底层就是通过反射实现的) fmt.Printf(\"%T\", value) // 通过反射可以动态获得变量value的类型从而分情况处理 v := reflect.ValueOf(value) switch v.Kind() { case reflect.Int: // do something case reflect.String: // do something } // ... } 为了避免使用反射而选择了泛型，结果到头来又为了一些功能在在泛型中使用反射, 当出现这种情况的时候你可能需要重新思考一下，自己的需求是不是真的需要用泛型（毕竟泛型机制本身就很复杂了，再加上反射的复杂度，增加的复杂度并不一定值得） ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:3:6","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r泛型接收器(receiver)","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:4:0","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r1. 泛型切片 单纯的泛型类型实际上对开发来说用处并不大。但是如果将泛型类型和接下来要介绍的泛型receiver相结合的话，泛型就有了非常大的实用性了 type MySlice[T int | float32] []T func (s MySlice[T]) Sum() T { var sum T for _, value := range s { sum += value } return sum } var s MySlice[int] = []int{1, 2, 3, 4} fmt.Println(s.Sum()) // 输出：10 var s2 MySlice[float32] = []float32{1.0, 2.0, 3.0, 4.0} fmt.Println(s2.Sum()) // 输出：10.0 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:4:1","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r2. 泛型结构体 泛型结构体和泛型方法 package main import \"fmt\" type MyStruct[T int | string | float32] struct { Res T } func (m *MyStruct[T]) Add(a ...T) { var r T for _, i := range a { r += i } fmt.Println(r) } func main() { m1 := MyStruct[int]{} m1.Add(1, 2, 3, 4, 5) m2 := MyStruct[float32]{} m2.Add(1.0, 2.0, 3.1, 4.2, 5.1) m3 := MyStruct[string]{} m3.Add(\"1.0\", \"2\", \"3\", \"4\", \"5\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:4:2","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r3. 泛型队列 队列是一种先入先出的数据结构 // 这里类型约束使用了空接口，代表的意思是所有类型都可以用来实例化泛型类型 Queue[T] (关于接口在后半部分会详细介绍） type Queue[T interface{}] struct { elements []T } // 将数据放入队列尾部 func (q *Queue[T]) Put(value T) { q.elements = append(q.elements, value) } // 从队列头部取出并从头部删除对应数据 func (q *Queue[T]) Pop() (T, bool) { var value T if len(q.elements) == 0 { return value, true } value = q.elements[0] q.elements = q.elements[1:] return value, len(q.elements) == 0 } // 队列大小 func (q Queue[T]) Size() int { return len(q.elements) } ----------------------------------------------------- var q1 Queue[int] // 可存放int类型数据的队列 q1.Put(1) q1.Put(2) q1.Put(3) q1.Pop() // 1 q1.Pop() // 2 q1.Pop() // 3 var q2 Queue[string] // 可存放string类型数据的队列 q2.Put(\"A\") q2.Put(\"B\") q2.Put(\"C\") q2.Pop() // \"A\" q2.Pop() // \"B\" q2.Pop() // \"C\" var q3 Queue[struct{Name string}] var q4 Queue[[]int] // 可存放[]int切片的队列 var q5 Queue[chan int] // 可存放int通道的队列 var q6 Queue[io.Reader] // 可存放接口的队列 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:4:3","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r泛型函数","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:5:0","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r1. 泛型函数 泛型函数定义 func Add[T int | float32 | float64](a T, b T) T { return a + b } 泛型函数调用 声明调用 Add[int](1,2) // 传入类型实参int，计算结果为 3 Add[float32](1.0, 2.0) // 传入类型实参float32, 计算结果为 3.0 Go还支持类型实参的自动推导 Add(1, 2) // 1，2是int类型，编译请自动推导出类型实参T是int Add(1.0, 2.0) // 1.0, 2.0 是浮点，编译请自动推导出类型实参T是float32 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:5:1","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r2. 匿名函数 匿名函数不支持泛型，匿名函数不能自己定义类型形参 匿名函数不能自己定义类型形参 // 错误，匿名函数不能自己定义类型实参 fnGeneric := func[T int | float32](a, b T) T { return a + b } 匿名函数可以使用别处定义好的类型实参 func MyFunc[T int | float32 | float64](a, b T) { // 匿名函数可使用已经定义好的类型形参 fn2 := func(i T, j T) T { return i*2 - j*2 } fn2(a, b) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:5:2","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r3. 泛型方法 目前Go的方法并不支持泛型 type A struct { } // 错误 不支持泛型方法 func (receiver A) Add[T int | float32 | float64](a T, b T) T { return a + b } 但是receiver支持泛型， 所以通过receiver使用类型形参在方法中使用泛型的话 type A[T int | float32 | float64] struct { } // 方法可以使用类型定义中的形参 T func (receiver A[T]) Add(a T, b T) T { return a + b } // 用法： var a A[int] a.Add(1, 2) var aa A[float32] aa.Add(1.0, 2.0) ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:5:3","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r泛型接口","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:6:0","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r1. 泛型接口定义 有时候使用泛型编程时会书写长长的类型约束 // 一个可以容纳所有int,uint以及浮点类型的泛型切片 type Slice[T int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64] []T 为了方便维护，go支持如下定义 type IntUintFloat interface { int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64 } type Slice[T IntUintFloat] []T 也可以通过接口组合，更加灵活 type Int interface { int | int8 | int16 | int32 | int64 } type Uint interface { uint | uint8 | uint16 | uint32 } type Float interface { float32 | float64 } type Slice[T Int | Uint | Float] []T // 使用 '|' 将多个接口类型组合 接口嵌套 type SliceElement interface { Int | Uint | Float | string // 组合了三个接口类型并额外增加了一个 string 类型 } type Slice[T SliceElement] []T ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:6:1","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r2. 从方法集到类型集 在Go1.18之前，Go官方对 接口(interface) 的定义是：接口是一个方法集(method set) An interface type specifies a method set called its interface. ReadWriter 接口定义了一个接口(方法集)，这个集合中包含了 Read() 和 Write() 这两个方法。所有同时定义了这两种方法的类型被视为实现了这一接口。 type ReadWriter interface { Read(p []byte) (n int, err error) Write(p []byte) (n int, err error) } 如果换一个角度来重新思考上面这个接口的话，会发现接口的定义实际上还能这样理解：可以把 ReaderWriter 接口看成代表了一个 类型的集合，所有实现了 Read() Writer() 这两个方法的类型都在接口代表的类型集合当中。 通过换个角度看待接口，在我们眼中接口的定义就从 方法集(method set) 变为了 类型集(type set)。而Go1.18开始就是依据这一点将接口的定义正式更改为了 类型集(Type set)。 接口类型 Float 代表了一个 类型集合， 所有以 float32 或 float64 为底层类型的类型，都在这一类型集之中; 而 type Slice[T Float] []T 中， 类型约束 的真正意思是：类型约束 指定了类型形参可接受的类型集合，只有属于这个集合中的类型才能替换形参用于实例化 var s Slice[int] // int 属于类型集 Float ，所以int可以作为类型实参 var s Slice[chan int] // chan int 类型不在类型集 Float 中，所以错误 接口实现(implement)定义的变化：既然接口定义发生了变化，那么从Go1.18开始 接口实现(implement) 的定义自然也发生了变化：当满足以下条件时，可以说 类型 T 实现了接口 I ( type T implements interface I)： T 不是接口时：类型 T 是接口 I 代表的类型集中的一个成员 (T is an element of the type set of I)。 T 是接口时： T 接口代表的类型集是 I 代表的类型集的子集(Type set of T is a subset of the type set of I)。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:6:2","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r3. 类型的交集和并集 并集| type Uint interface { // 类型集 Uint 是 ~uint 和 ~uint8 等类型的并集 ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 } 交集 type AllInt interface { ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint32 } type Uint interface { ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 } type A interface { // 接口A代表的类型集是 AllInt 和 Uint 的交集 ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 AllInt Uint } type B interface { // 接口B代表的类型集是 AllInt 和 ~int 的交集 ~int AllInt ~int } 空集 type Bad interface { int float32 } // 类型 int 和 float32 没有相交的类型，所以接口 Bad 代表的类型集为空 没有任何一种类型属于空集。虽然这样的写法是可以编译的，但实际上并没有什么意义。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:6:3","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r4. interface{} 和 any Go1.18开始接口的定义发生了改变，所以 interface{} 的定义也发生了一些变更： 空接口代表了所有类型的集合 对于Go1.18之后的空接口应该这样理解： 虽然空接口内没有写入任何的类型，但它代表的是所有类型的集合，而非一个空集。 类型约束中指定 空接口 的意思是指定了一个包含所有类型的类型集，并不是类型约束限定了只能使用 空接口 来做类型形参。 // 空接口代表所有类型的集合。写入类型约束意味着所有类型都可拿来做类型实参 type Slice[T interface{}] []T var s1 Slice[int] // 正确 var s2 Slice[map[string]string] // 正确 var s3 Slice[chan int] // 正确 var s4 Slice[interface{}] // 正确 在Go1.18+中，any 等价于 interface{} , 这个是官方提供为了方便使用而设定的新的关键字 type Slice[T any] []T // 代码等价于 type Slice[T interface{}] []T any 的定义就位于Go语言的 builtin.go 文件中（参考如下）， any 实际上就是 interaface{} 的别名(alias)，两者完全等价。 // any is an alias for interface{} and is equivalent to interface{} in all ways. type any = interface{} 所以从 Go 1.18 开始，所有可以用到空接口的地方其实都可以直接替换为any： var s []any // 等价于 var s []interface{} var m map[string]any // 等价于 var m map[string]interface{} func MyPrint(value any){ fmt.Println(value) } 如果你高兴的话，项目迁移到 Go1.18 之后可以使用下面这行命令直接把整个项目中的空接口全都替换成 any。当然因为并不强制，所以到底是用 interface{} 还是 any 全看自己喜好。 gofmt -w -r 'interface{} -\u003e any' ./... Go语言项目中就曾经有人提出过把Go语言中所有 interface{ }替换成 any 的 issue，然后因为影响范围过大过而且影响因素不确定，理所当然被驳回了。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:6:4","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r5. comparable和 ordered comparable(可比较) 和 可排序(ordered) 对于一些数据类型，我们需要在类型约束中限制只接受能 != 和 == 对比的类型，以Go直接内置了一个叫 comparable 的接口，它代表了所有可用 != 以及 == 对比的类型： // 错误。因为 map 中键的类型必须是可进行 != 和 == 比较的类型 type MyMap[KEY any, VALUE any] map[KEY]VALUE // 正确 type MyMap[KEY comparable, VALUE any] map[KEY]VALUE comparable 比较容易引起误解的一点是很多人容易把他与可排序搞混淆。可比较指的是 可以执行 != == 操作的类型，并没确保这个类型可以执行大小比较（ \u003e,\u003c,\u003c=,\u003e= ）。、 type OhMyStruct struct { a int } var a, b OhMyStruct a == b // 正确。结构体可使用 == 进行比较 a != b // 正确 a \u003e b // 错误。结构体不可比大小 而可进行大小比较的类型被称为 Orderd 。目前Go语言并没有像 comparable 这样直接内置对应的关键词，所以想要的话需要自己来定义相关接口，比如我们可以参考Go官方包 golang.org/x/exp/constraints 如何定义： // Ordered 代表所有可比大小排序的类型 type Ordered interface { Integer | Float | ~string } type Integer interface { Signed | Unsigned } type Signed interface { ~int | ~int8 | ~int16 | ~int32 | ~int64 } type Unsigned interface { ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr } type Float interface { ~float32 | ~float64 } 虽然可以直接使用官方包 golang.org/x/exp/constraints ，但因为这个包属于实验性质的 x 包，今后可能会发生非常大变动，所以并不推荐直接使用 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:6:5","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r6. 接口的两种类型 Go1.18开始将接口分为了两种类型 基本接口(Basic interface) 通用接口(General interface) 基本接口(Basic interface):接口定义中如果只有方法的话，那么这种接口被称为基本接口(Basic interface)。这种接口就是Go1.18之前的接口，用法也基本和Go1.18之前保持一致。 type MyError interface { // 接口中只有方法，所以是基本接口 Error() string } // 用法和 Go1.18之前保持一致 var err MyError = fmt.Errorf(\"hello world\") // io.Reader 和 io.Writer 都是基本接口，也可以用在类型约束中 type MySlice[T io.Reader | io.Writer] []Slice 通用接口(General interface):果接口内不光只有方法，还有类型的话，这种接口被称为 通用接口(General interface) ；通用接口，只能用于类型约束，不得用于变量定义， 这一限制保证了一般接口的使用被限定在了泛型之中，不会影响到Go1.18之前的代码，同时也极大减少了书写代码时的心智负担 type Uint interface { // 接口 Uint 中有类型，所以是通用接口 ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 } type ReadWriter interface { // ReadWriter 接口既有方法也有类型，所以是通用接口 ~string | ~[]rune Read(p []byte) (n int, err error) Write(p []byte) (n int, err error) } // 类型 StringReadWriter 实现了接口 Readwriter type StringReadWriter string func (s StringReadWriter) Read(p []byte) (n int, err error) { // ... } func (s StringReadWriter) Write(p []byte) (n int, err error) { // ... } // 类型BytesReadWriter 没有实现接口 Readwriter // StringReadWriter 存在于接口 ReadWriter 代表的类型集中，而 BytesReadWriter 因为底层类型是 []byte（既不是string也是不[]rune） ，所以它不属于 ReadWriter 代表的类型集 type BytesReadWriter []byte func (s BytesReadWriter) Read(p []byte) (n int, err error) { ... } func (s BytesReadWriter) Write(p []byte) (n int, err error) { ... } -------------------------------- type Uint interface { ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 } var uintInf Uint // 错误。Uint是通用接口，只能用于类型约束，不得用于变量定义 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:6:6","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\rgo泛型的其他限制 用 | 连接多个类型的时候，类型之间不能有相交的部分(即必须是不交集）; 但是相交的类型中是接口的话，则不受这一限制 类型的并集中不能有类型形参 接口不能直接或间接地并入自己 接口的并集成员个数大于一的时候不能直接或间接并入 comparable 接口 带方法的接口(无论是基本接口还是一般接口)，都不能写入接口的并集中 用 | 连接多个类型的时候，类型之间不能有相交的部分(即必须是不交集）; 但是相交的类型中是接口的话，则不受这一限制： type MyInt int // 错误，MyInt的底层类型是int,和 ~int 有相交的部分 type _ interface { ~int | MyInt } type MyInt int type _ interface { ~int | interface{ MyInt } // 正确 } type _ interface { interface{ ~int } | MyInt // 也正确 } type _ interface { interface{ ~int } | interface{ MyInt } // 也正确 } 类型的并集中不能有类型形参 type MyInf[T ~int | ~string] interface { ~float32 | T // 错误。T是类型形参 } type MyInf2[T ~int | ~string] interface { T // 错误 } 接口不能直接或间接地并入自己 type Bad interface { Bad // 错误，接口不能直接并入自己 } type Bad2 interface { Bad1 } type Bad1 interface { Bad2 // 错误，接口Bad1通过Bad2间接并入了自己 } type Bad3 interface { ~int | ~string | Bad3 // 错误，通过类型的并集并入了自己 } 接口的并集成员个数大于一的时候不能直接或间接并入 comparable 接口 type OK interface { comparable // 正确。只有一个类型的时候可以使用 comparable } type Bad1 interface { []int | comparable // 错误，类型并集不能直接并入 comparable 接口 } type CmpInf interface { comparable } type Bad2 interface { chan int | CmpInf // 错误，类型并集通过 CmpInf 间接并入了comparable } type Bad3 interface { chan int | interface{comparable} // 理所当然，这样也是不行的 } 带方法的接口(无论是基本接口还是一般接口)，都不能写入接口的并集中 type _ interface { ~int | ~string | error // 错误，error是带方法的接口(一般接口) 不能写入并集中 } type DataProcessor[T any] interface { ~string | ~[]byte Process(data T) (newData T) Save(data T) error } // 错误，实例化之后的 DataProcessor[string] 是带方法的一般接口，不能写入类型并集 type _ interface { ~int | ~string | DataProcessor[string] } type Bad[T any] interface { ~int | ~string | DataProcessor[T] // 也不行 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175146/:7:0","tags":null,"title":"13.go 泛型","uri":"/lang/go/go_base/20250515175146/"},{"categories":null,"content":"\r1 编译函数 Compile函数或MustCompile函数是将正则表达式进行编译，返回优化的 Regexp 结构体 Compile: 返回两个参数*Regexp,error类型 MustCompile: 只返回*Regexp类型 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:1:0","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\r2 正则匹配","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:2:0","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\r2.1 1. MatchString 返回的第一个参数是bool类型即匹配结果，第二个参数是error类型 demo sourceStr := `my email is gerrylon@163.com` matched, _ := regexp.MatchString(`[\\w-]+@[\\w]+(?:\\.[\\w]+)+`, sourceStr) fmt.Printf(\"%v\", matched) // true ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:2:1","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\r2.2 2. FindString 返回一个字符串，该字符串具有最左边匹配的文本。如果找不到匹配项，则返回空字符串。 demo r,_:=regexp.Compile(\"p([a-z]+)ch\") //查找匹配的字符串 fmt.Println(r.FindString(\"peach punch\")) //打印结果：peach ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:2:2","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\r2.3 3. FindStringIndex 查找第一个匹配字符串开始和结束位置的索引，而不是匹配内容 demo r,_:=regexp.Compile(\"p([a-z]+)ch\") // 查找匹配字符串开始和结束位置的索引，而不是匹配内容[0 5] fmt.Println(r.FindStringIndex(\"peach punch\")) //打印结果： [0 5] ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:2:3","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\r2.4 4. FindStringSubmatch 查找第一个， 返回完全匹配和局部匹配的字符串 dmeo r,_:=regexp.Compile(\"p([a-z]+)ch\") //返回完全匹配和局部匹配的字符串，例如，这里会返回 p([a-z]+)ch 和 `([a-z]+) 的信息 fmt.Println(r.FindStringSubmatch(\"peach punch\")) //打印结果：[peach ea] ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:2:4","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\r2.5 5. FindAllString 查找字符串中所有符合规则的，可以指定个数 demo r, _ := regexp.Compile(\"p([a-z]+)ch\") fmt.Println(r.FindAllString(\"aapeach punch pqwerch\", 2)) //打印结果： [peach punch] ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:2:5","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\r2.6 6. FindStringIndex 查找全部 匹配字符串开始和结束位置的索引，而不是匹配内容 demo r, _ := regexp.Compile(\"p([a-z]+)ch\") fmt.Println(r.FindAllStringIndex(\"aapeach punch pqwerch\", 2)) //打印结果： [[2 7] [8 13]] ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:2:6","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\r2.7 7. FindAllStringSubmatch 返回全部的 完全匹配和局部匹配的字符串，可以指定个数 demo r, _ := regexp.Compile(\"p([a-z]+)ch\") fmt.Println(r.FindAllStringSubmatch(\"aapeach punch pqwerch\", 2)) //打印结果： [[peach ea] [punch un]] ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:2:7","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\r2.8 7. ReplaceAllString 将匹配的结果，替换成新输入的结果, 没有匹配到返回原string demo r, _ := regexp.Compile(\"p([a-z]+)ch\") fmt.Println(r.ReplaceAllString(\"aapeach punch pqwerch\", \"-\")) //打印结果： aa- - - ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:2:8","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\r2.9 8. ReplaceAllFunc demo //Func 变量允许传递匹配内容到一个给定的函数中， in:=[]byte(\"a peach\") out:=r1.ReplaceAllFunc(in,bytes.ToUpper) fmt.Printf(string(out)) //打印结果： a PEACH ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175142/:2:9","tags":null,"title":"12. 正则表达式","uri":"/lang/go/go_base/20250515175142/"},{"categories":null,"content":"\rContext 在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:0:0","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r1 为什么需要Context 下面以取消一个goroutine做示例说明为什么需要Context ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:1:0","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r1.1 1. 基本示例 package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup // 初始的例子 func worker() { for { fmt.Println(\"worker\") time.Sleep(time.Second) } // 如何接收外部命令实现退出 wg.Done() } func main() { wg.Add(1) go worker() // 如何优雅的实现结束子goroutine wg.Wait() fmt.Println(\"over\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:1:1","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r1.2 2. 全局变量方式 package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup var exit bool // 全局变量方式存在的问题： // 1. 使用全局变量在跨包调用时不容易统一 // 2. 如果worker中再启动goroutine，就不太好控制了。 func worker() { for { fmt.Println(\"worker\") time.Sleep(time.Second) if exit { break } } wg.Done() } func main() { wg.Add(1) go worker() time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出 exit = true // 修改全局变量实现子goroutine的退出 wg.Wait() fmt.Println(\"over\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:1:2","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r1.3 3. 通道方式 package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup // 管道方式存在的问题： // 1. 使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channel func worker(exitChan chan struct{}) { LOOP: for { fmt.Println(\"worker\") time.Sleep(time.Second) select { case \u003c-exitChan: // 等待接收上级通知 break LOOP default: } } wg.Done() } func main() { var exitChan = make(chan struct{}) wg.Add(1) go worker(exitChan) time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出 exitChan \u003c- struct{}{} // 给子goroutine发送退出信号 close(exitChan) wg.Wait() fmt.Println(\"over\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:1:3","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r1.4 4. 官方版的方案 package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func worker(ctx context.Context) { LOOP: for { fmt.Println(\"worker\") time.Sleep(time.Second) select { case \u003c-ctx.Done(): // 等待上级通知 break LOOP default: } } wg.Done() } func main() { ctx, cancel := context.WithCancel(context.Background()) wg.Add(1) go worker(ctx) time.Sleep(time.Second * 3) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(\"over\") } 当子goroutine又开启另外一个goroutine时，只需要将ctx传入即可： package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func worker(ctx context.Context) { go worker2(ctx) LOOP: for { fmt.Println(\"worker\") time.Sleep(time.Second) select { case \u003c-ctx.Done(): // 等待上级通知 break LOOP default: } } wg.Done() } func worker2(ctx context.Context) { LOOP: for { fmt.Println(\"worker2\") time.Sleep(time.Second) select { case \u003c-ctx.Done(): // 等待上级通知 break LOOP default: } } } func main() { ctx, cancel := context.WithCancel(context.Background()) wg.Add(1) go worker(ctx) time.Sleep(time.Second * 3) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(\"over\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:1:4","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r2 Context初识 Go1.7加入了一个新的标准库context，它定义了Context类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。 对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用WithCancel、WithDeadline、WithTimeout或WithValue创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:2:0","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r3 Context接口context.Context是一个接口，该接口定义了四个需要实现的方法。具体签名如下： type Context interface { Deadline() (deadline time.Time, ok bool) Done() \u003c-chan struct{} Err() error Value(key interface{}) interface{} } Deadline方法需要返回当前Context被取消的时间，也就是完成工作的截止时间（deadline）； Done方法需要返回一个Channel，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用Done方法会返回同一个Channel； Err方法会返回当前Context结束的原因，它只会在Done返回的Channel被关闭时才会返回非空的值； 如果当前Context被取消就会返回Canceled错误； 如果当前Context超时就会返回DeadlineExceeded错误； Value方法会从Context中返回键对应的值，对于同一个上下文来说，多次调用Value 并传入相同的Key会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据； ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:3:0","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r3.1 1. Background()和TODO()Go内置两个函数：Background()和TODO()，这两个函数分别返回一个实现了Context接口的background和todo。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的partent context，衍生出更多的子上下文对象。 Background()主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。 TODO()，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个。 background和todo本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:3:1","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r4 With系列函数","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:4:0","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r4.1 1. WithCancel WithCancel的函数签名如下： func WithCancel(parent Context) (ctx Context, cancel CancelFunc) WithCancel返回带有新Done通道的父节点的副本。当调用返回的cancel函数或当关闭父上下文的Done通道时，将关闭返回上下文的Done通道，无论先发生什么情况。 取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。 func gen(ctx context.Context) \u003c-chan int { dst := make(chan int) n := 1 go func() { for { select { case \u003c-ctx.Done(): return // return结束该goroutine，防止泄露 case dst \u003c- n: n++ } } }() return dst } func main() { ctx, cancel := context.WithCancel(context.Background()) defer cancel() // 当我们取完需要的整数后调用cancel for n := range gen(ctx) { fmt.Println(n) if n == 5 { break } } } 上面的示例代码中，gen函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免gen启动的内部goroutine发生泄漏。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:4:1","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r4.2 2. WithDeadline WithDeadline的函数签名如下： func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) 返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。 取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。 func main() { d := time.Now().Add(50 * time.Millisecond) ctx, cancel := context.WithDeadline(context.Background(), d) // 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。 // 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。 defer cancel() select { case \u003c-time.After(1 * time.Second): fmt.Println(\"overslept\") case \u003c-ctx.Done(): fmt.Println(ctx.Err()) } } 上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用context.WithDeadline(context.Background(), d)得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个select让主程序陷入等待：等待1秒后打印overslept退出或者等待ctx过期后退出。 因为ctx50秒后就过期，所以ctx.Done()会先接收到值，上面的代码会打印ctx.Err()取消原因。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:4:2","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r4.3 3. WithTimeout WithTimeout的函数签名如下： func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) WithTimeout返回WithDeadline(parent, time.Now().Add(timeout))。 取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制。具体示例如下： package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) // context.WithTimeout var wg sync.WaitGroup func worker(ctx context.Context) { LOOP: for { fmt.Println(\"db connecting ...\") time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒 select { case \u003c-ctx.Done(): // 50毫秒后自动调用 break LOOP default: } } fmt.Println(\"worker done!\") wg.Done() } func main() { // 设置一个50毫秒的超时 ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50) wg.Add(1) go worker(ctx) time.Sleep(time.Second * 5) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(\"over\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:4:3","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r4.4 4. WithValue WithValue函数能够将请求作用域的数据与 Context 对象建立关系。声明如下： func WithValue(parent Context, key, val interface{}) Context WithValue返回父节点的副本，其中与key关联的值为val。 仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数。 所提供的键必须是可比较的，并且不应该是string类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。WithValue的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型struct{}。或者，导出的上下文关键变量的静态类型应该是指针或接口。 package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) // context.WithValue type TraceCode string var wg sync.WaitGroup func worker(ctx context.Context) { key := TraceCode(\"TRACE_CODE\") traceCode, ok := ctx.Value(key).(string) // 在子goroutine中获取trace code if !ok { fmt.Println(\"invalid trace code\") } LOOP: for { fmt.Printf(\"worker, trace code:%s\\n\", traceCode) time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒 select { case \u003c-ctx.Done(): // 50毫秒后自动调用 break LOOP default: } } fmt.Println(\"worker done!\") wg.Done() } func main() { // 设置一个50毫秒的超时 ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50) // 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合 ctx = context.WithValue(ctx, TraceCode(\"TRACE_CODE\"), \"12512312234\") wg.Add(1) go worker(ctx) time.Sleep(time.Second * 5) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(\"over\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:4:4","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r5 使用Context的注意事项 推荐以参数的方式显示传递Context 以Context作为参数的函数方法，应该把Context作为第一个参数。 给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO() Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数 Context是线程安全的，可以放心的在多个goroutine中传递 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:5:0","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r6 客户端超时取消示例(小爬虫)调用服务端API时如何在客户端实现超时控制？ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:6:0","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r6.1 server // context_timeout/server/main.go package main import ( \"fmt\" \"math/rand\" \"net/http\" \"time\" ) // server端，随机出现慢响应 func indexHandler(w http.ResponseWriter, r *http.Request) { number := rand.Intn(2) if number == 0 { time.Sleep(time.Second * 10) // 耗时10秒的慢响应 fmt.Fprintf(w, \"slow response\") return } fmt.Fprint(w, \"quick response\") } func main() { http.HandleFunc(\"/\", indexHandler) err := http.ListenAndServe(\":8000\", nil) if err != nil { panic(err) } } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:6:1","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r6.2 client // context_timeout/client/main.go package main import ( \"context\" \"fmt\" \"io/ioutil\" \"net/http\" \"sync\" \"time\" ) // 客户端 type respData struct { resp *http.Response err error } func doCall(ctx context.Context) { transport := http.Transport{ // 请求频繁可定义全局的client对象并启用长链接 // 请求不频繁使用短链接 DisableKeepAlives: true, } client := http.Client{ Transport: \u0026transport, } respChan := make(chan *respData, 1) req, err := http.NewRequest(\"GET\", \"http://127.0.0.1:8000/\", nil) if err != nil { fmt.Printf(\"new requestg failed, err:%v\\n\", err) return } req = req.WithContext(ctx) // 使用带超时的ctx创建一个新的client request var wg sync.WaitGroup wg.Add(1) defer wg.Wait() go func() { resp, err := client.Do(req) fmt.Printf(\"client.do resp:%v, err:%v\\n\", resp, err) rd := \u0026respData{ resp: resp, err: err, } respChan \u003c- rd wg.Done() }() select { case \u003c-ctx.Done(): //transport.CancelRequest(req) fmt.Println(\"call api timeout\") case result := \u003c-respChan: fmt.Println(\"call server api success\") if result.err != nil { fmt.Printf(\"call server api failed, err:%v\\n\", result.err) return } defer result.resp.Body.Close() data, _ := ioutil.ReadAll(result.resp.Body) fmt.Printf(\"resp:%v\\n\", string(data)) } } func main() { // 定义一个100毫秒的超时 ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100) defer cancel() // 调用cancel释放子goroutine资源 doCall(ctx) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:6:2","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r7 坑","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:7:0","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r7.1 1. WithCancel withCancel的使用要非常明确程序什么时候被取消 由于go大量的官方库、第三方库使用了context，所以调用接收context的函数时要小心，要清楚context在什么时候cancel，什么行为会触发cancel ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:7:1","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r7.2 2. WithValue 所提供的键必须是可比较的，并且不应该是string类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。WithValue的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型struct{}。或者，导出的上下文关键变量的静态类型应该是指针或接口。 type TraceCode string func main() { ctx := context.Background() ctx = context.WithValue(ctx, TraceCode(\"TRACE_CODE\"), \"1\") fmt.Println(ctx.Value(\"TRACE_CODE\")) // nil fmt.Println(ctx.Value(TraceCode(\"TRACE_CODE\"))) // 1 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:7:2","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r7.3 3. context 函数传递是值传递 error demo type ctxType string func main() { ctx := context.WithValue(context.Background(), ctxType(\"key\"), 1) valueChange(ctx) log.Println(ctx.Value(ctxType(\"key\"))) // 1; 并不会更改值 } func valueChange(ctx context.Context) { context.WithValue(ctx, ctxType(\"key\"), 2) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175139/:7:3","tags":null,"title":"11. Context","uri":"/lang/go/go_base/20250515175139/"},{"categories":null,"content":"\r内置函数","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:0:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r1 closeclose 用于 channel 通讯。使用它来关闭 channel ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:1:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r2 deletedelete 用于在 map 中删除实例。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:2:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r3 len 和 caplen 和 cap 可用于不同的类型，len 用于返回字符串、slice 和数组的长度。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:3:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r4 newnew 用于各种类型的内存分配, new 返回一个指针类型,但是不会初始化变量, 会将值全部置为零值 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:4:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r5 makemake 用于内建类型（map、slice 和 channel）的内存分配。返回这三个的引用变量 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:5:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r6 copycopy 用于复制 slice。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:6:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r7 appendappend 用于追加 slice ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:7:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r8 panicpanic 和 recover 用于异常处理机制。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:8:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r9 print 和 printlnprint 和 println 是底层打印函数，可以在不引入 fmt 包的情况下使用。它们主要用于调试。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:9:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r10 complex、real 和 imagcomplex、real 和 imag 全部用于处理 复数 库/包\rOS os.Args 获取命令行参数,返回值是一个切片,第一个参数是可执行文件名称 go run main.go // os.Args[1] = \"n\" ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:10:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r1 container/list list是一个双向链表。该结构具有链表的所有功能。 type Element func (e *Element) Next() *Element //返回该元素的下一个元素，如果没有下一个元素则返回nil func (e *Element) Prev() *Element//返回该元素的前一个元素，如果没有前一个元素则返回nil。 element.Value 获取元素的值 type Element struct { Value interface{} //在元素中存储的值 } type List func New() *List //返回一个初始化的list func (l *List) Back() *Element //获取list l的最后一个元素 func (l *List) Front() *Element //获取list l的第一个元素 func (l *List) Init() *List //list l初始化或者清除list l func (l *List) InsertAfter(v interface{}, mark *Element) *Element //在list l中元素mark之后插入一个值为v的元素，并返回该元素，如果mark不是list中元素，则list不改变。 func (l *List) InsertBefore(v interface{}, mark *Element) *Element//在list l中元素mark之前插入一个值为v的元素，并返回该元素，如果mark不是list中元素，则list不改变。 func (l *List) Len() int //获取list l的长度 func (l *List) MoveAfter(e, mark *Element) //将元素e移动到元素mark之后，如果元素e或者mark不属于list l，或者e==mark，则list l不改变。 func (l *List) MoveBefore(e, mark *Element)//将元素e移动到元素mark之前，如果元素e或者mark不属于list l，或者e==mark，则list l不改变。 func (l *List) MoveToBack(e *Element)//将元素e移动到list l的末尾，如果e不属于list l，则list不改变。 func (l *List) MoveToFront(e *Element)//将元素e移动到list l的首部，如果e不属于list l，则list不改变。 func (l *List) PushBack(v interface{}) *Element//在list l的末尾插入值为v的元素，并返回该元素。 func (l *List) PushBackList(other *List)//在list l的尾部插入另外一个list，其中l和other可以相等。 func (l *List) PushFront(v interface{}) *Element//在list l的首部插入值为v的元素，并返回该元素。 func (l *List) PushFrontList(other *List)//在list l的首部插入另外一个list，其中l和other可以相等。 func (l *List) Remove(e *Element) interface{}//如果元素e属于list l，将其从list中删除，并返回元素e的值。 举例说明其用法。 package main import ( \"container/list\" \"fmt\" ) func main() { l := list.New() //创建一个新的list for i := 0; i \u003c 5; i++ { l.PushBack(i) } for e := l.Front(); e != nil; e = e.Next() { fmt.Print(e.Value) //输出list的值,01234 } fmt.Println(\"\") fmt.Println(l.Front().Value) //输出首部元素的值,0 fmt.Println(l.Back().Value) //输出尾部元素的值,4 l.InsertAfter(6, l.Front()) //首部元素之后插入一个值为10的元素 for e := l.Front(); e != nil; e = e.Next() { fmt.Print(e.Value) //输出list的值,061234 } fmt.Println(\"\") l.MoveBefore(l.Front().Next(), l.Front()) //首部两个元素位置互换 for e := l.Front(); e != nil; e = e.Next() { fmt.Print(e.Value) //输出list的值,601234 } fmt.Println(\"\") l.MoveToFront(l.Back()) //将尾部元素移动到首部 for e := l.Front(); e != nil; e = e.Next() { fmt.Print(e.Value) //输出list的值,460123 } fmt.Println(\"\") l2 := list.New() l2.PushBackList(l) //将l中元素放在l2的末尾 for e := l2.Front(); e != nil; e = e.Next() { fmt.Print(e.Value) //输出l2的值,460123 } fmt.Println(\"\") \u003cspan style=\"color:#FF0000;\"\u003el.Init() //清空l\u003c/span\u003e fmt.Print(l.Len()) //0 for e := l.Front(); e != nil; e = e.Next() { fmt.Print(e.Value) //输出list的值,无内容 } } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:11:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r2 sync.WaitGroup WaitGroup提供3个方法实现优雅退出 Add() ：每收到http/mq请求，会在计数器+1 Done()：每执行完http/mq请求，会在计数器-1 Wait()：计数器=0，即没有正在处理的 请求 import \"sync\" import \"os/signal\" import \"fmt\" func main() { var wg sync.WaitGroup sig := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) httpHandle() go func() { sig := \u003c-sig wg.Wait() done \u003c- true }() \u003c-done fmt.println(\"quit success\") } func httpHandle() { wg.Add(1) defer wg.Done() xxx } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:12:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r3 sync.Map() 支持并发的map type Map //删除指定key func (m *Map) Delete(key interface{}) //查询指定key func (m *Map) Load(key interface{}) (value interface{}, ok bool) //查询，查不到则追加 func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) //遍历map func (m *Map) Range(f func(key, value interface{}) bool) //添加 func (m *Map) Store(key, value interface{}) ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175137/:13:0","tags":null,"title":"10. 内置函数\u0026库","uri":"/lang/go/go_base/20250515175137/"},{"categories":null,"content":"\r计算机网络基础 常见的两种架构: C/S 微信,qq,迅雷等需要安装客户端的应用. client 客户端 serve 服务端 B/S 百度,知乎,博客园登不需要客户端,通过一个浏览器即可实现相关服务 browser 浏览器 server 服务端 协议 server和client得到的内容都是二进制,所以每一位代表什么就需要事先规定好,再按照约定进行发送和解析,这个约定就是协议. arp协议(重点) 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。 由交换机完成:交换机先广播再单播完成通讯 arp协议:通过ip地址获取mac地址 交换机通过arp协议识别一台机器 IP协议 规定网络地址的协议叫ip协议 规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址32位2进制表示范围0.0.0.0-255.255.255.255 一个ip地址通常写成四段十进制数，例：172.16.10.1 IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:0","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\rTCP协议 可靠,速度慢,全双工通信 建立连接三次握手,断开连接四次挥手 建立起链接之后,发送每条消息都有回执,为了保证数据的完整性,还有重传机制 数据传输:有收必有发,收发必相等 长连接:会一直占用对方端口 IO操作(input/output),IO操作的输入输出时相对内存来说 write-send (输出ouput) read-recv (输入input) #三次握手 TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK[1]，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接。[1] TCP三次握手的过程如下： 客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。 服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。 客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。 三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。 #四次挥手 (1) 某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。 (2) 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。 注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。 (3) 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。 (4) 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。[1] 既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:1","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\rUDP协议 不需要建立连接,速度特别快,可能会丢消息. ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:2","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\r小结(TCP/UDP重点) 应用场景 TCP:文件上传下载(邮件,网盘) UDP:即时通讯(微信,qq) 传输文件长度: TCP 长度无限 UDP 能够传输的数据航都是有限的,根据数据传递设备的设置有关系 osi七层模型 ‘应表会传网数物’ 也叫osi五层模型,专业七层,开发人员掌握五层模型,表示层会话层了解 应用层:python代码 表示层 会话层 传输层:tcp协议 udp协议 端口 网络层:ipv4/ipv6协议 数据链路层:mac地址 arp协议 物理层: 每层运行常见协议/物理设备 tcp/ip五层 每层运行常见协议 每层运行常见物理设备 5应用层 python代码/http/https/ftp/smtp/ 4传输层 tcp/udp协议 端口 四层交换机/四层路由器 3网络层 ipv4/ipv6协议 三层路由器/三层交换机 2数据链路层 mac地址/arp协议 网卡/交换机/二层交换机 1物理层 socket 中文名字:套接字 Socket是应用层与传输层中间的抽象层，Socket帮助去组织拼接信息数据，以符合指定的协议。 用来描述IP地址和端口,是一个通信的句柄,用来实现不同计算机之间的通信 socket对于程序员来说,已经是网络操作的底层了 粘包","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:3","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\r粘包概念: TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。 粘包可能由发送方造成，也可能由接收方造成。 只有TCP有粘包现象，UDP永远不会粘包 粘包不一定会发生 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:4","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\r粘包原因:所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。 发送端原因: 由于TCP协议本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会维持一个连接（Channel），数据在连接不断开的情况下，可以持续不断地将多个数据包发往服务器，但是如果发送的网络数据包太小，那么他本身会启用Nagle算法（可配置是否启用）对较小的数据包进行合并（基于此，TCP的网络延迟要UDP的高些）然后再发送（超时或者包大小足够）。那么这样的话，服务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包. 接收端原因: 服务器在接收到数据库后，放到缓冲区中，如果消息没有被及时从缓存区取走，下次在取数据的时候可能就会出现一次取出多个数据包的情况，造成粘包现象。 tcp粘包解决办法","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:5","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\rpython版 在每次使用tcp协议发送数据流时,在开头标记一个数据流长度信息,并固定该报文长度(自定义协议).在客户端接收数据时先接收该长度字节数据,判断客户端发送数据流长度,并只接收该长度字节数据,就可以实现拆包,完美解决tcp粘包问题. #struct模块 #该模块可以把一个类型，如数字，转成固定长度为4的bytes类型 import struct res = struct.pack('i',12345) #i表示整数int print(res,len(res),type(res)) #长度是4 res2 = struct.pack('i',12345111) print(res,len(res),type(res2)) #长度也是4 unpack_res =struct.unpack('i',res2) print(unpack_res) #(12345111,) print(unpack_res[0]) #12345111 ###################客户端client################### #!/usr/bin/env python # -*- coding:utf-8 -*- import socket import struct sock=socket.socket() sock.connect(('127.0.0.1', 13459)) content1='我好'.encode('utf-8') #要发送消息 content2='他也好'.encode('utf-8') con1_len=struct.pack('i',len(content1)) # 计算要发送消息(字节)的长度,并使用struct模块转化为长度为4的字节b'\\x06\\x00\\x00\\x00' sock.send(con1_len) #先把这个4字节的报文发送 sock.send(content1) #发送内容 con2_len=struct.pack('i',len(content2)) sock.send(con2_len) sock.send(content2) sock.close() ###################服务端server################### #!/usr/bin/env python # -*- coding:utf-8 -*- import struct import socket sock = socket.socket() #买手机 sock.bind(('127.0.0.1', 13459)) #插卡 sock.listen(10) #开机(同时最大连接10) conn, addr = sock.accept() #(受)与cilent端connect(攻)对应. msg = conn.recv(4) #首先接收4个字节(4个字节由client端struct模块转化) len_msg= struct.unpack('i',msg) #struct模块读取报文,判断跟随数据长度.返回值是一个元祖(6,) size_msg=len_msg[0] #取值判断跟随数据长度 msg = conn.recv(size_msg) #接收报文读取长度字节 print(msg.decode('utf-8')) #解码输出 msg=conn.recv(4) len_msg=struct.unpack('i',msg) size_msg=len_msg[0] msg = conn.recv(size_msg) print(msg.decode('utf-8')) conn.close() sock.close() !重要struct模块转化与读取都是对字节进行操作! ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:6","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\rGo将消息长度转为int32(len(msg)),4个字节 协议代码 package proto import ( \"bufio\" \"bytes\" \"encoding/binary\" ) func Encode(message string) ([]byte, error) { // 读取消息的长度转换成int32类型（4字节） var length = int32(len(message)) var pkg = new(bytes.Buffer) // 写入消息头 err := binary.Write(pkg, binary.LittleEndian, length) if err != nil { return nil, err } // 写入包体 err = binary.Write(pkg, binary.LittleEndian, []byte(message)) if err != nil { return nil, err } return pkg.Bytes(), nil } // 解码 func Decode(reader *bufio.Reader) (string, error) { // 读消息长度 lengthByte, _ := reader.Peek(4) lengthBuff := bytes.NewBuffer(lengthByte) var length int32 err := binary.Read(lengthBuff, binary.LittleEndian, \u0026length) if err != nil { return \"\", err } // buffer返回缓冲中现有的可读的字节数 if int32(reader.Buffered()) \u003c length+4 { return \"\", err } // 读取真正的数据 pack := make([]byte, int(4+length)) _, err = reader.Read(pack) if err != nil { return \"\", err } return string(pack[4:]), nil } server code package main import ( \"20_tcp/03_粘包/proto\" \"bufio\" \"fmt\" \"io\" \"net\" ) func main() { // 本地端口启动服务 listener, err := net.Listen(\"tcp\", \"localhost:20000\") if err != nil { fmt.Println(\"服务器启动失败....\", err) return } fmt.Println(\"监听成功...\") // 等待连接 for { conn, err := listener.Accept() if err != nil { fmt.Println(\"连接建立失败...\", err) break } fmt.Println(\"连接成功...\") go Process(conn) } // 通信 } func Process(conn net.Conn) { defer conn.Close() reader := bufio.NewReader(conn) for { msg, err := proto.Decode(reader) fmt.Println(\"收到消息：\", msg) if err == io.EOF { return } if err != nil { fmt.Println(\"decode失败，err:\", err) } } } client package main import ( \"20_tcp/03_粘包/proto\" \"fmt\" \"net\" ) func main() { conn, err := net.Dial(\"tcp\", \"127.0.0.1:20000\") if err != nil { fmt.Println(\"连接失败,err:\", err) return } defer conn.Close() msg := \"hello socket\" for i := 0; i \u003c 20; i++ { // 调用协议编码协议 b, err := proto.Encode(msg) if err != nil { fmt.Println(\"Encode失败，err:\", err) } conn.Write(b) fmt.Println(\"发送成功...,msg：\", b) } } TCP代码实现 golang中使用net包实现socker编程; net常用的函数: Dial 拨号 Listen 监听 Accept 接受 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:7","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\rTCP客户端 tcp客户端 package main import ( \"fmt\" \"log\" \"net\" ) func main() { // 尝试连接百度服务器 conn,err:= net.Dial(\"tcp\",\"www.baidu.com:80\") if err!= nil { fmt.Println(err) } defer conn.Close() log.Println(\"连接成功\") // 发送数据 conn.Write([]byte(\"test\\n\")) // 接收数据 buf:= make([]byte,10) conn.Read(buf) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:8","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\rTCP服务端 服务端 package main import ( \"fmt\" \"log\" \"net\" \"time\" ) func main() { listener,err:= net.Listen(\"tcp\",\":80\") if err!=nil { fmt.Println(err) } defer listener.Close() log.Println(\"启动成功...\") // 阻塞等待客户端连接 conn,err:= listener.Accept() // 设置连接超时时间 conn.SetDeadline(time.Now().Add(time.Second)) // 设置读取超时时间 conn.SetReadDeadline(time.Now().Add(time.Second)) // 设置写入超时时间 conn.SetWriteDeadline(time.Now().Add(time.Second)) } UDP代码实现","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:9","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\rUDP客户端 与tcp类似; 将Dial第一个参数改为udp package main import ( \"fmt\" \"log\" \"net\" ) func main() { // 尝试连接百度服务器 conn,err:= net.Dial(\"udp\",\"www.baidu.com:80\") if err!= nil { fmt.Println(err) } defer conn.Close() log.Println(\"连接成功\") // 发送数据 conn.Write([]byte(\"test\\n\")) // 接收数据 buf:= make([]byte,10) conn.Read(buf) log.Println(string(buf)) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:10","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":"\rUDP服务端 package main import ( \"fmt\" \"log\" \"net\" ) func checkErr(err error) { if err!=nil { log.Println(err) } } func main() { // 创建一个UDP地址 udpaddr, err:= net.ResolveUDPAddr(\"udp4\",\":1234\") checkErr(err) // 创建udp服务 conn,err:= net.ListenUDP(\"udp\",udpaddr) checkErr(err) defer conn.Close() fmt.Println(\"UDP服务创建成功\") buf:= make([]byte,1024) conn.Read(buf) log.Println(string(buf)) _,raddr,err:= conn.ReadFromUDP(buf) conn.Write([]byte(\"hello word\\r\\n\")) conn.WriteToUDP([]byte(\"hello word\\r\\n\"),raddr) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175134/:0:11","tags":null,"title":"9. Socket编程","uri":"/lang/go/go_base/20250515175134/"},{"categories":null,"content":" Go语言内置的net/http包十分的优秀， 压力测试数据 # mac 配置 8核 16G内存 # goland 多核模式 16 threads and 200 connections Thread Stats Avg Stdev Max +/- Stdev Latency 5.75ms 14.07ms 224.91ms 90.89% Req/Sec 9.46k 6.90k 100.80k 80.15% 4403567 requests in 30.09s, 596.34MB read Socket errors: connect 0, read 56, write 0, timeout 0 Requests/sec: 146360.93 # 每秒并发数高达 14.6w 是sanic 10进程的3倍 Transfer/sec: 19.82MB HTTP客户端有两个非常重要的类型client和request ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175131/:0:0","tags":null,"title":"8. nethttp模块","uri":"/lang/go/go_base/20250515175131/"},{"categories":null,"content":"\r1. Client Client 结构体共有四个成员 Transport 指定独立单次HTTP请求的机制 CheckRedirect 指定处理重定向策略 Jar 指定cookie管理器 Timeout 指定文本类型的执行请求的时间限制 import \"time\" type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request)error Jar CookieJar Timeout time.Duration } Client类型主要充当浏览器角色; 它拥有一下方法: Do get和post都是基于do方法进行的封装 Head Get Post PostForm ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175131/:1:0","tags":null,"title":"8. nethttp模块","uri":"/lang/go/go_base/20250515175131/"},{"categories":null,"content":"\r1.1 启动client /* * @date: 2021/12/6 * @desc: ... */ package main import ( \"fmt\" \"io/ioutil\" \"net\" \"net/http\" \"time\" ) func main() { // 创建连接池 transport := \u0026http.Transport{ DialContext: (\u0026net.Dialer{ Timeout: 30 * time.Second, // 连接超时 KeepAlive: 30 * time.Second, // 长连接保持时间 }).DialContext, MaxIdleConns: 100, // 最大空闲连接 IdleConnTimeout: 90 * time.Second, //空闲超时时间 TLSHandshakeTimeout: 10 * time.Second, //tls 握手超时时间 (https使用) ExpectContinueTimeout: 1 * time.Second, //100-continue状态码超时时间 } // 创建客户端 client := http.Client{ Timeout: time.Second * 30, // 请求超时时间 Transport: transport, } // 请求数据 resp, err := client.Get(\"http://127.0.0.1:8080/bye\") if err != nil { panic(err) } defer resp.Body.Close() // 读取body内容 bds, err := ioutil.ReadAll(resp.Body) if err != nil { panic(err) } fmt.Println(string(bds)) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175131/:1:1","tags":null,"title":"8. nethttp模块","uri":"/lang/go/go_base/20250515175131/"},{"categories":null,"content":"\r2. Request request是对请求体的封装吗任何形式的http请求都可以由request来构造, 构造完成之后使用Client发送请求; type Request struct { Method string //请求方法 Url *url.URL //请求地址 Proto string //协议版本 Header Header //请求头 Body io.ReadCloser //请求体 Form url.Values //解析好的表单数据,包括URL字段的query参数和post或者put的表单数据 //... } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175131/:2:0","tags":null,"title":"8. nethttp模块","uri":"/lang/go/go_base/20250515175131/"},{"categories":null,"content":"\r3. Get和Post的区别 get是从服务器上获取数据, post是向服务器推送数据 get和post传递参数的方式不同, get将参数放在url后面,post是将表单数据放在请求体中 get数据不安全,用户提交的数据用户能看到, post对用户不可见; GET请求传输数据量很小, 而POST请求可以传输大量的数据 POST传输数据可以通过设置编码的方式正确转化中文, 而GET请求传输的数据没有变化 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175131/:3:0","tags":null,"title":"8. nethttp模块","uri":"/lang/go/go_base/20250515175131/"},{"categories":null,"content":"\r3.1 发起GET请求 简单请求 不带参数 package main import ( \"fmt\" \"io\" \"io/ioutil\" \"net/http\" ) func main() { get, err := http.Get(\"http://www.baidu.com\") if err != nil { fmt.Println(\"get error\", err) return } defer func(Body io.ReadCloser) { fmt.Println(\"close error\") err := Body.Close() if err != nil { } }(get.Body) all, err := ioutil.ReadAll(get.Body) if err != nil { fmt.Println(\"read error\") return } fmt.Println(string(all)) } 带参数 关于GET请求的参数需要使用Go语言内置的net/url这个标准库来处理。 func main() { apiUrl := \"http://127.0.0.1:9090/get\" // URL param data := url.Values{} data.Set(\"name\", \"小王子\") data.Set(\"age\", \"18\") u, err := url.ParseRequestURI(apiUrl) if err != nil { fmt.Printf(\"parse url requestUrl failed, err:%v\\n\", err) } u.RawQuery = data.Encode() // URL encode fmt.Println(u.String()) resp, err := http.Get(u.String()) if err != nil { fmt.Printf(\"post failed, err:%v\\n\", err) return } defer resp.Body.Close() b, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Printf(\"get resp failed, err:%v\\n\", err) return } fmt.Println(string(b)) } 对应的Server端HandlerFunc如下： func getHandler(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() data := r.URL.Query() fmt.Println(data.Get(\"name\")) fmt.Println(data.Get(\"age\")) answer := `{\"status\": \"ok\"}` w.Write([]byte(answer)) } 自定义get 请求 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func main() { client := \u0026http.Client{} request, err := http.NewRequest(\"GET\", \"http://www.baidu.com\", nil) if err != nil { fmt.Println(err) } response, err := client.Do(request) if err != nil { fmt.Println(err) } fmt.Println(response.StatusCode) // 响应码 res, err := ioutil.ReadAll(response.Body) fmt.Println(string(res)) // 获取的代码 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175131/:3:1","tags":null,"title":"8. nethttp模块","uri":"/lang/go/go_base/20250515175131/"},{"categories":null,"content":"\r3.2 发起Post请求 简单post请求 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"strings\" ) // net/http post demo func main() { url := \"http://127.0.0.1:9090/post\" // 表单数据 //contentType := \"application/x-www-form-urlencoded\" //data := \"name=小王子\u0026age=18\" // json contentType := \"application/json\" data := `{\"name\":\"小王子\",\"age\":18}` resp, err := http.Post(url, contentType, strings.NewReader(data)) if err != nil { fmt.Printf(\"post failed, err:%v\\n\", err) return } defer resp.Body.Close() b, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Printf(\"get resp failed, err:%v\\n\", err) return } fmt.Println(string(b)) } 对应的Server端HandlerFunc如下： func postHandler(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() // 1. 请求类型是application/x-www-form-urlencoded时解析form数据 r.ParseForm() fmt.Println(r.PostForm) // 打印form数据 fmt.Println(r.PostForm.Get(\"name\"), r.PostForm.Get(\"age\")) // 2. 请求类型是application/json时从r.Body读取数据 b, err := ioutil.ReadAll(r.Body) if err != nil { fmt.Printf(\"read request.Body failed, err:%v\\n\", err) return } fmt.Println(string(b)) answer := `{\"status\": \"ok\"}` w.Write([]byte(answer)) } 自定义post请求 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"strings\" ) func main() { resq, err:= http.Post(\"http://www.baidu.com\", \"application/x-www-form-urlencoded\", strings.NewReader(\"user=admin\u0026pass=admin\")) if err !=nil{ fmt.Println(err) } defer resq.Body.Close() body, err:= ioutil.ReadAll(resq.Body) if err!=nil{ fmt.Println(err) } fmt.Println(body) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175131/:3:2","tags":null,"title":"8. nethttp模块","uri":"/lang/go/go_base/20250515175131/"},{"categories":null,"content":"\r4. curl工具 curl 是一个利用URL语法在命令行工作的文件传输工具, 一般称之为下载工具 Curl 基础命令 curl URL // get请求获取页面, 如果是一个图片,将会下载图片 curl -o URL // 下载到本地 curl -i URL // 显示头信息 curl -v URL // 显示一次http通信的整个过程 curl -X POST --data \"data=xxx\" URL //发送post请求 curl --user-agent \"[USER AGENT]\" URL // 添加useragent curl --cokie \"cookie\" URL //添加cookie curl --head \"head\" URL //添加请求头 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175131/:4:0","tags":null,"title":"8. nethttp模块","uri":"/lang/go/go_base/20250515175131/"},{"categories":null,"content":"\r5. 启动server服务 方式一 package main import ( \"fmt\" \"math/rand\" \"net/http\" \"time\" ) func indexHandler(w http.ResponseWriter, r *http.Request) { rand.Seed(time.Now().UnixNano()) randNum := rand.Intn(2) if randNum == 0 { time.Sleep(5 * time.Second) } fmt.Fprintf(w, \"quick response\") } func main() { http.HandleFunc(\"/\", indexHandler) err := http.ListenAndServe(\":8000\", nil) if err != nil { panic(err) } } 方式二: package main import ( \"log\" \"net/http\" \"time\" ) const ADDR = \"127.0.0.1:8080\" func sayBay(w http.ResponseWriter, r *http.Request) { time.Sleep(time.Second * 1) _, err := w.Write([]byte(\"bye bye!\")) if err != nil { return } } func main() { // 创建路由器 mux := http.NewServeMux() // 设置路由规则 mux.HandleFunc(\"/bye\", sayBay) // 创建服务器 server := \u0026http.Server{ Addr: ADDR, WriteTimeout: time.Second * 3, Handler: mux, } // 监听端口并提供服务 log.Println(\"starting http server at: \" + ADDR) log.Fatal(server.ListenAndServe()) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175131/:5:0","tags":null,"title":"8. nethttp模块","uri":"/lang/go/go_base/20250515175131/"},{"categories":null,"content":"\r常见错误码 200 成功状态吗 301 临时重定向 302 永久重定向 400 客户端 语法错误 401 客户端身份认证失败 403 拒绝访问 404 找不到资源 500 服务器内部错误 501 服务器不支持 502 错误的网关 503 服务器过载 504 网关超时 505 http协议错误 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175131/:6:0","tags":null,"title":"8. nethttp模块","uri":"/lang/go/go_base/20250515175131/"},{"categories":null,"content":"\r反射定义","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:1:0","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\rPython 反射 python一切皆对象,所以想要通过字符串的形式操作内部成员都可以通过反射去完成操作. py文件 包 类 对象…(导入包操作类调用方法) 反射:根据字符串的形式去某个对象操作对象的成员. getattr(对象名,“方法名”) 根据字符串的形式去某个对象中获取对象的成员. attribute属性 class Foo(object): def __init__(self,name): self.name = name def login(self): pass obj = Foo('alex') # 获取变量 v1 = getattr(obj,'name') # 获取方法 method_name = getattr(obj,'login') method_name() setattr(对象名称,“变量”,值 ) 根据字符串的形式去某个对象中设置成员. class Foo: pass obj = Foo() obj.k1 = 999 setattr(obj,'k1',123) # obj.k1 = 123 print(obj.k1) hasattr(对象名称,“方法名”) 根据字符串的形式去某个对象中判断是否含有某成员.返回布尔类型 class Foo: pass obj = Foo() obj.k1 = 999 hasattr(obj,'k1') print(obj.k1) delattr(对象,“方法名”) 根据字符串的形式去某个对象中删除某成员. class Foo: pass obj = Foo() obj.k1 = 999 delattr(obj,'k1') print(obj.k1) importlib 用字符串的形式导入模块 模块 = importlib.import_module('utils.redis') 示例: import importlib #用字符串的模式导入模块 redis = importlib.import_module(\"utils.redis\") #用字符串的形式去对象(模块)找到他的成员 getattr(redis,\"func\")() self.MIDDLEWARE_CLASSES = [ 'utils.session.SessionMiddleware', 'utils.auth.AuthMiddleware', 'utils.csrf.CrsfMiddleware', ] for mes in self.MIDDLEWARE_CLASSES: module_path,class_name=mes.rsplit('.',maxsplit=1) #切割路径和类名 module_object = importlib.import_module(module_path) #插入模块-字符串操作 cla=getattr(module_object,class_name) #根据模块对象找到类名(字符串操作-反射) obj = cla() #实例化对象 obj.process() #运行内部函数process ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:1:1","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\rGolang反射 反射是指程序在运行期间，动态地更新、获取变量的值，包括获取字段类型、名称、调用类变量对应的方法等。 在运行时更新变量和检查他们的值并调用他们的方法和他们支持的内在操作, 但是在编译时b并不知道这些变量的具体类型; 这种机制叫做反射 python的反射和Golang反射的区别 python反射: 确认对象的类 确认类中所有的成员变量和方法 动态调用任意一个对象的方法 golang反射 不支持对字符串解析! 获取对象的值和类型,获取结构体成员的类型, 调用结构体方法 只能作用于已经存在的对象上 变量包括两部分: 类型信息, 这部分是原信息, 是预定义好的 值类型, 这部分在程序运行过程中是动态改变的 反射与空接口 在运行时动态的获取一个变量的类型信息和值信息就是反射 reflect reflect.TypeOf() 获取变量类型信息, 返回一个type接口 reflect.ValueOf() 获取变量值信息 reflect.Kind() 获取变量类型 package main import ( \"fmt\" \"reflect\" ) func main() { var x float64 = 3.4 t := reflect.TypeOf(x) // t是一个type对象 fmt.Println(reflect.TypeOf(t)) //*reflect.rtype fmt.Println(\"type:\", t.Kind()) // float64 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:1:2","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r反射的基本用法 reflect t := reflect.TypeOf() 获取变量类型信息, 返回一个type接口 t := reflect.ValueOf() 获取变量值信息 t.Kind() 获取变量类型 t.Elem() 反射获取指针变量所指向的元素类型 t.Name() 获取变量类型名称 reflect.Kind() 获取到的变量种类: const ( Invalid Kind = iota // 非法类型 Bool Int //有符号整形 Int8 // 有符号8位整形 Int16 Int32 Int64 Uint //无符号整形 Uint8 // 无符号8位整形 Uint16 Uint32 Uint64 Uintptr //指针 Float32 Float64 Complex64 //64位复数 Complex128 //128位复数 Array Chan Func Interface Map Ptr //指针 Slice String Struct UnsafePointer //底层指针 ) ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:2:0","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r获取类型信息 reflect.TypeOf() 获取变量类型信息, 返回一个type接口 package main import ( \"fmt\" \"reflect\" ) type Number int type Person struct { } func checkType(t reflect.Type) { if t.Kind() == reflect.Ptr { fmt.Printf(\"变量的类型名称:%v; 指向的变量为:%s\\n\", t.Kind(), t.Elem()) } fmt.Printf(\"变量的类型名称=\u003e %v; ;类型种类=\u003e:%s\\n\", t.Name(), t.Kind()) } func main() { var number Number = 1 typeOfNumber := reflect.TypeOf(number) fmt.Println(\"type of number:\") checkType(typeOfNumber) var person Person typeOfPerson := reflect.TypeOf(person) fmt.Println(\"type of person\") checkType(typeOfPerson) typeOfPersonPtr := reflect.TypeOf(\u0026person) fmt.Println(\"type of \u0026person\") checkType(typeOfPersonPtr) } /** type of number: 变量的类型名称=\u003e Number; ;类型种类=\u003e:int type of person 变量的类型名称=\u003e Person; ;类型种类=\u003e:struct type of \u0026person 变量的类型名称:ptr; 指向的变量为:main.Person 变量的类型名称=\u003e ; ;类型种类=\u003e:ptr */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:2:1","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r获取类型的值 t :=reflect.ValueOf() 获取变量值信息 获取变量的值和反射调用函数都需要使用reflect.ValueOf() t.Kind() == reflect.TypeOf() t.SetInt( intnumber ) 改变类型的值,因为是值传递,必须传入指针才能改变值 package main import ( \"fmt\" \"reflect\" ) func getVlaue(arg interface{}) { argReflectValue := reflect.ValueOf(arg) fmt.Printf(\"arg value : %v\\n\", argReflectValue) fmt.Printf(\"arg type :%v\\n\", argReflectValue.Kind()) switch argReflectValue.Kind() { case reflect.Int: fmt.Println(\"arg type is int\") case reflect.Float32: // fmt.Println(\"arg type is float32\") res := argReflectValue.Elem() res.SetFloat(2.6) fmt.Println(res) case reflect.Ptr: fmt.Println(\"arg type is pointer\") res := argReflectValue.Elem() res.SetFloat(2.6) // 改变传入参数的值, 必须传入指针类型才可以改变 fmt.Println(res) default: fmt.Println(\"not fond\") } } func main() { var f float32 = 1.3 getVlaue(\u0026f) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:2:2","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r反射调用函数 反射调用函数: 使用reflect.ValueOf() 方法传入想要反射的函数名, 获取到reflect.Value对象, 再通过该对象啊的call方法调用该函数; Call 方法需要提前声明; func (v Value) Call (in []Value) []Value call 方法输入的参数in调用v持有的函数. 例如, 如果len(in) == 3, v.Call(in) 代表调用v(int[0],int[1],int[2]), 其中value值表示其持有值. 如果v的kind不是func将会panic.. 它返回函数所有输出结果的Value封装的切片。和Go代码一样,每一个输入实参的持有值都必须可以直接赋值给函数对应输入参数的类型。如果v持有值是可变参数函数,Call方法会自行创建一个代表可变参数的切片,将对应可变参数的值都拷贝到里面。 package main import ( \"fmt\" \"reflect\" ) func Equal(a, b int) bool { if a == b { return true } return false } func main() { // reflect.Value 类型 valueOfFunc := reflect.ValueOf(Equal) // 构造函数参数 args := []reflect.Value{reflect.ValueOf(1), reflect.ValueOf(2)} // 同各国反射调用函数计算 result := valueOfFunc.Call(args) fmt.Println(\"函数运行结果: \", result[0].Bool()) // 函数运行结果: false } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:2:3","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r结构体反射 反射可以获取结构体成员的类型、结构体成员的值、以及调用结构体的方法 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:3:0","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r1. 获取结构体成员类型 t := reflect.TypeOf(“结构体”) // t是reflect.Type类型 t.NumField() 获取结构体成员的数量 t.Field(index) 可以根据索引返回结构体字段详细信息; 具体信息如下 type StructField struct{ Name string //字段名 PkgPath string //字段路径 Type Type //字段反射类型对象 Tag StruntTag //字段结构体标签 Offset uinptr //字段在结构体中的偏移 Index []int //字段的索引值 Anonymous bool //是否为匿名字段 } t.FieldByName(name string) 通过字段名来获取字段信息 t.FieldByIndex(index []int) 通过下标来获取字段信息 // type StructField struct{ // Name string //字段名 // PkgPath string //字段路径 // Type Type //字段反射类型对象 // Tag StruntTag //字段结构体标签 // Offset uinptr //字段在结构体中的偏移 // Index []int //字段的索引值 // Anonymous bool //是否为匿名字段 // } package main import ( \"fmt\" \"reflect\" ) type Person struct { Name string Age int `json:\"age\"` string } func main() { person := Person{\"Evan\", 18, \"备注\"} typeOfPerson := reflect.TypeOf(person) // 遍历结构体成员, 获取字段信息 for i := 0; i \u003c typeOfPerson.NumField(); i++ { field := typeOfPerson.Field(i) name := field.Name tag := field.Tag anonymous := field.Anonymous fmt.Printf(\"字段名:%v 字段标签:%v 是否为匿名字段:%v \\n\", name, tag, anonymous) } // 通过字段名获取字段信息 if field, ok := typeOfPerson.FieldByName(\"Age\"); ok { fmt.Println(\"通过字段名\") fmt.Printf(\"字段名:%v 字段标签中json为: %v \\n\", field.Name, field.Tag.Get(\"json\")) } // 通过下标获取字段信息 field := typeOfPerson.FieldByIndex([]int{1}) fmt.Printf(\"字段名:%v 字段标签: %v \\n\", field.Name, field.Tag) } /** 字段名:Name 字段标签: 是否为匿名字段:false 字段名:Age 字段标签:json:\"age\" 是否为匿名字段:false 字段名:string 字段标签: 是否为匿名字段:true 通过字段名 字段名:Age 字段标签中json为: age 字段名:Age 字段标签: json:\"age\" */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:3:1","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r2. 获取结构体成员字段的值 t := reflect.Valueof(“结构体”) t.NumField() 获取结构体成员的数量 t.Feild(index) 根据 索引返回的对应结构体字段的reflect.Value 反射类型 // type StructField struct{ // Name string //字段名 // PkgPath string //字段路径 // Type Type //字段反射类型对象 // Tag StruntTag //字段结构体标签 // Offset uinptr //字段在结构体中的偏移 // Index []int //字段的索引值 // Anonymous bool //是否为匿名字段 // } package main import ( \"fmt\" \"reflect\" ) type Person struct { Name string Age int `json:\"age\"` string } func main() { person := Person{\"Evan\", 18, \"备注\"} valueOfPerson := reflect.ValueOf(person) // 结构体字段数量 fieldNum := valueOfPerson.NumField() fmt.Printf(\"结构体字段数量: %d \\n\", fieldNum) //结构体字段数量: 3 // 通过下标获取字段值 field1 := valueOfPerson.Field(1) fmt.Printf(\"字段值:%v \\n\", field1.Int()) //字段值:18 field2 := valueOfPerson.Field(0) fmt.Printf(\"字段值:%v \\n\", field2.String()) //字段值:Evan // 通过字段名获取字段信息 field := valueOfPerson.FieldByName(\"Age\") fmt.Printf(\"字段值: %v \\n\", field.Interface()) // // 通过下标索引获取字段信息 field = valueOfPerson.FieldByIndex([]int{1}) fmt.Printf(\"字段值: %v \\n\", field.Interface()) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:3:2","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r3. 反射执行结构体方法 结构体方法需要使用reflect.ValueOf() 获取reflect.Value对象, 然后调用该对象的MethodByName(name) 函数, 找到对应要反射调用的方法, 再通过Call函数进行反射调用 package main import ( \"fmt\" \"reflect\" ) type Person struct { Name string Age int `json:\"age\"` string } func (p Person)GetName(a int) { fmt.Println(p.Name) // Evan fmt.Println(a) // 1 } func main() { valueOfPerson := reflect.ValueOf(Person{\"Evan\",18,\"备注\"}) callObj := valueOfPerson.MethodByName(\"GetName\") callObj.Call([]reflect.Value{reflect.ValueOf(1)}) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:3:3","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r4. 获取结构体tag的值 package main import ( \"fmt\" \"reflect\" // 这里引入reflect模块 ) type User struct { Name string `json:\"user_name\"` Passwd string `json:\"user_password\"` } func main() { user := \u0026User{\"chronos\", \"pass\"} s := reflect.TypeOf(user).Elem() //通过反射获取type定义 for i := 0; i \u003c s.NumField(); i++ { fmt.Println(s.Field(i).Tag.Get(\"json\")) //将tag输出出来 } } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:3:4","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r反射三定律","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:4:0","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r1. 接口到反射类型的转换 反射类型: relect.Type 和 relect.Value 反射可以将接口类型变量转换为反射类型变量 reflect.TypeOf() 函数将换入的interface{}类型的变量进行解析后返回refluect.Type类型 reflect.ValueOf() 函数将换入的interface{}类型的变量进行解析后返回reflect.Value类型 package main import ( \"fmt\" \"reflect\" ) type Person struct { Name string Age int `json:\"age\"` string } func main() { person := Person{} reflectType := reflect.TypeOf(person) reflectValue := reflect.ValueOf(person) fmt.Printf(\"person type:%T\\n\",person) //person type:main.Person fmt.Printf(\"reflectType type:%T\\n\",reflectType) //reflectType type:*reflect.rtype fmt.Printf(\"reflectValue type:%T\\n\",reflectValue) //reflectValue type:reflect.Value } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:4:1","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r2. 反射到接口类型的转换 反射可以将反射类型转换为接口类型 reflect.Value 对象的 interface() 方法, 可以将反射类型变量转换为接口变量 package main import ( \"fmt\" \"reflect\" ) func main() { var num = 1 valueOfNum := reflect.ValueOf(num) fmt.Println(valueOfNum.Interface()) // 1 fmt.Printf(\"%T\",valueOfNum.Interface()) // int } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:4:2","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r3. 修改反射类型对象 想要使用反射修改变量的值, 其值必须是可写的( CanSet ).这个值必须满足两个条件: 变量可以被寻址(CanAddr) 变量时可以导出的(结构体字段名首字母大写) package main import ( \"fmt\" \"reflect\" ) type Person struct { Name string age int `json:\"age\"` string } func main() { person := Person{\"Evan\",28,\"备注\"} fmt.Printf(\"修改前: %v\",person) valueOfPerson := reflect.ValueOf(\u0026person) res := valueOfPerson.Elem() res.Field(0).SetString(\"Jerry\") res.Field(1).SetInt(26) //res.Field(2).SetString(\"啊啊\") // panic fmt.Printf(\"修改后: %v\",person) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:4:3","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r反射的性能 Golang反射性能极差 , 如果需要考虑性能的地方不推荐使用 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175128/:5:0","tags":null,"title":"7. 反射","uri":"/lang/go/go_base/20250515175128/"},{"categories":null,"content":"\r1. 前言 channel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统的方法来解决。 channel存在3种状态： nil，未初始化的状态，只进行了声明，或者手动赋值为nil active，正常的channel，可读或者可写 closed，已关闭，千万不要误认为关闭channel后，channel的值是nil ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175124/:1:0","tags":null,"title":"6-2. channel 原理和坑","uri":"/lang/go/go_base/20250515175124/"},{"categories":null,"content":"\r2. chan数据结构src/runtime/chan.go:hchan定义了channel的数据结构： type hchan struct { qcount uint // 当前队列中剩余元素个数 dataqsiz uint // 环形队列长度，即可以存放的元素个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小 closed uint32 // 标识关闭状态 elemtype *_type // 元素类型 sendx uint // 队列下标，指示元素写入时存放到队列中的位置 recvx uint // 队列下标，指示元素从队列的该位置读出 recvq waitq // 等待读消息的goroutine队列 sendq waitq // 等待写消息的goroutine队列 lock mutex // 互斥锁，chan不允许并发读写 } 从数据结构可以看出channel由队列、类型信息、goroutine等待队列组成，下面分别说明其原理。 ​ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175124/:2:0","tags":null,"title":"6-2. channel 原理和坑","uri":"/lang/go/go_base/20250515175124/"},{"categories":null,"content":"\r2.1 环形队列chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。 下图展示了一个可缓存6个元素的channel示意图： dataqsiz指示了队列长度为6，即可缓存6个元素； buf指向队列的内存，队列中还剩余两个元素； qcount表示队列中还有两个元素； sendx指示后续写入的数据存储的位置，取值[0, 6)； recvx指示从该位置读取数据, 取值[0, 6)； ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175124/:2:1","tags":null,"title":"6-2. channel 原理和坑","uri":"/lang/go/go_base/20250515175124/"},{"categories":null,"content":"\r2.2 等待队列从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。 向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。 被阻塞的goroutine将会挂在channel的等待队列中： 因读阻塞的goroutine会被向channel写入数据的goroutine唤醒； 因写阻塞的goroutine会被从channel读数据的goroutine唤醒； 下图展示了一个没有缓冲区的channel，有几个goroutine阻塞等待读数据： 注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175124/:2:2","tags":null,"title":"6-2. channel 原理和坑","uri":"/lang/go/go_base/20250515175124/"},{"categories":null,"content":"\r2.3 类型信息一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。 elemtype代表类型，用于数据传递过程中的赋值； elemsize代表类型大小，用于在buf中定位元素位置。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175124/:2:3","tags":null,"title":"6-2. channel 原理和坑","uri":"/lang/go/go_base/20250515175124/"},{"categories":null,"content":"\r2.4 锁一个channel同时仅允许被一个goroutine读写。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175124/:2:4","tags":null,"title":"6-2. channel 原理和坑","uri":"/lang/go/go_base/20250515175124/"},{"categories":null,"content":"\r3. channel读写和关闭 关闭值为nil的channel panic 关闭已经被关闭的channel panic 向已经关闭的 channel写数据 panic 读已经关闭的channel ,如果channel有值则读出,如果没有读出的数据是 channel中可插入类型的零值,第二个返回值一直为false. 如果使用select case 去hold一个已经关闭的channel, 永远都会取到一个channel中可插入类型的零值. for range 如果channel有值则读出, 如果每有值读取已关闭channel 会结束遍历 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175124/:3:0","tags":null,"title":"6-2. channel 原理和坑","uri":"/lang/go/go_base/20250515175124/"},{"categories":null,"content":"\r4. select使用select可以监控多channel，比如监控多个channel，当其中某一个channel有数据时，就从其读出数据。 一个简单的示例程序如下： package main import ( \"fmt\" \"time\" ) func addNumberToChan(chanName chan int) { for { chanName \u003c- 1 time.Sleep(1 * time.Second) } } func main() { var chan1 = make(chan int, 10) var chan2 = make(chan int, 10) go addNumberToChan(chan1) go addNumberToChan(chan2) for { select { case e := \u003c- chan1 : fmt.Printf(\"Get element from chan1: %d\\n\", e) case e := \u003c- chan2 : fmt.Printf(\"Get element from chan2: %d\\n\", e) default: fmt.Printf(\"No element in chan1 and chan2.\\n\") time.Sleep(1 * time.Second) } } } 程序中创建两个channel： chan1和chan2。函数addNumberToChan()函数会向两个channel中周期性写入数据。通过select可以监控两个channel，任意一个可读时就从其中读出数据。 如果使用select case 去hold一个已经关闭的channel, 永远都会取到一个channel中可插入类型的零值. ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175124/:4:0","tags":null,"title":"6-2. channel 原理和坑","uri":"/lang/go/go_base/20250515175124/"},{"categories":null,"content":"\r并发基础","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:0:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r1.并发,并行并发和并行都可以处理“多任务”，二者的主要区别在于是否是“同时进行”多个的任务。 并发:交替做不同事情的能力,不同的代码块交替执行 并行:同时做不同事情的能力,不同的代码块同时执行 #帮助理解 并发：老师甲先给学生A去讲思路，A听懂了自己书写过程并且检查，而甲老师在这期间直接去给B讲思路，讲完思路再去给C讲思路，让B自己整理步骤。这样老师就没有空着，一直在做事情，很快就完成了三个任务。与顺序执行不同的是，顺序执行，老师讲完思路之后学生在写步骤，这在这期间，老师是完全空着的，没做事的，所以效率低下。 并行：直接让三个老师甲、乙、丙三个老师“同时”给三个学生辅导作业，也完成的很快。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:1:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r2.同步,异步同步和异步关注的是--消息通信机制--同步与异步是针对应用程序与内核的交互而言的 同步:就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。 调用者主动等待这个调用的结果。 异步:在异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者. 调用者不会等待这个调用的结果。 #针对IO操作而言 同步过程中进程触发IO操作,并等待或者轮询的去查看IO操作是否完成。 异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:2:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r3.阻塞,非阻塞同步异步是个操作方式，阻塞非阻塞是线程的一种状态。涉及到CPU线程调度 阻塞:调用结果返回前，线程挂起. 非阻塞:调用不会阻塞线程，而且立即返回. #涉及到CPU线程调度 - 阻塞，就是调用结果返回之前，该执行线程会被挂起，不释放CPU执行权，线程不能做其它事情，只能等待，只有等到调用结果返回了，才能接着往下执行； - 非阻塞，就是在没有获取调用结果时，不是一直等待，线程可以往下执行，如果是同步的，通过轮询的方式检查有没有调用结果返回，如果是异步的，会通知回调。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:3:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r4.进程、线程、协程 进程，计算机中资源分配的最小单元。 高计算的时候使用多进程 线程，计算机中被cpu调度的最小单元。 协程，又称为“微线程”，与进程、线程不同，进程线程是计算机中真实存在，协程是程序员级别人为创造出来的，本质上通过一个线程实现并发的操作。 io多的时候使用线程 进程，计算机中资源分配的最小单元。 高计算的时候使用多进程 线程，计算机中被cpu调度的最小单元。 协程，又称为“微线程”，与进程、线程不同，进程线程是计算机中真实存在，协程是程序员级别人为创造出来的，本质上通过一个线程实现并发的操作。 io多的时候使用线程 一个进程中可以有多个线程、一个线程中有多个协程，他们都可以帮助我们完成并发操作，特殊协程只有遇到IO切换才有意义，否则效率反倒会降低。 ----------------- # 进程(process): 进程是计算机中最小的资源分配单位,创建和销毁都需要一定的开销,进程有自己的pid,进程有三个状态,分别是就绪,运行和阻塞;数据隔离,数据不安全,由操作系统进行控制,可以利用多核; # 线程(threading): 线程是cpu最小的调度单位,创建和销毁也需要一定的开销,但是相对进程来说较小,也是由操作系统控制,数据共享,数据不安全,在cpython解析器下不能利用多核,因为gil锁； # 协程: 创建和销毁的开销极小,数据共享但是数据安全,不同利用多核,协程是通过代码来实现的 一个进程中可以有多个线程、一个线程中有多个协程，他们都可以帮助我们完成并发操作，特殊协程只有遇到IO切换才有意义，否则效率反倒会降低。 --计算密集型用多进程、IO密集型用多线程。 ------- #应用场景: # 在哪些地方用到了线程和协程 1.自己用线程、协程完成爬虫任务 2.但是后来有了比较丰富的爬虫框架 # 了解到 scrapy /beautyful soup/aiogttp爬虫框架 哪些用到了线程，哪些用到了协程？ 3.web框架中的并发是如何实现的 # 传统框架 ： django 多线程 # flask 优先选用协程 其次使用线程 # socketserver ：多线程 # 异步框架 ：tornado，sanic底层都是协程 CSP 并发模型 CSP(Communication Sequential Process 通讯顺序进程 ) 模型 CSP 并发模型不关注发送消息的实体,而只关注发送消息时使用的通信管道; 换句话说就是:CSP模型提倡通过通信来实现内存共享, 而不是通过内存共享而实现通信 golang并发基于CSP并发模型, channal 类型的引入就是CSP模型的体现 goroutine 并发 golang并发优势: golang在代码底层实现了并发, 开发者不用再担心并发的底层逻辑和内存管理, 只需要担心业务逻辑即可 golang通过goroutine 实现协程并发编程, 在底层实现了内存共享, 比线程更加易用高效. 每一个并发的执行单元都是一个goroutine; 通过使用go关键字实现并发; 一旦使用go关键字, 就不能使用函数的返回值来和主进程进行数据交换, 只能使用channel进行数据交换 当一个程序启动时, 其主函数就在一个单独的goroutine 中运行,当main函数后面没有代码逻辑时main函数就会停止, 而所有goroutine在main函数结束时会一并结束! 终止goroutine的最好方法是在goroutine内部结束goroutine ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:4:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r1. runtime包 runtime包是一个小型的任务调度器, 可以高效的将CPU资源分配给每一个任务 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:5:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r1.1 Gosched runtime.GOsched() 方法会将当前任务单元放弃处理器, 让其他Go协程运行; 等到其他goroutine结束后就会重启改任务单元; 一版goroutine出现以下几种情况, goroutine就会发生调度 syscall C函数调用(本质和sysycall类似) 主动调用runtime.Gosched() 方法 某个goroutine调用时间超过100ms, 并且这个goroutine调用了非内联函数 内联函数是指当编译器发现某段代码在调用一个内联函数时, 他不是去调用函数而是将该函数的代码整段插入到当前位置, 省去了调用过程, 加快程序运行速度. ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:5:1","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r2.2 Goexit runtime.Goexit() 终止调用他的携程, 但是不会影响其他协程, 并在终止之前会调用defer的函数 main函数调用此方法main函数结束,程序崩溃 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:5:2","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r3.3 GOMAXPROCS runtime.GOMAXPROCS(n int)函数 可以设置程序在运行中所使用的CPU函数 go语言程序默认会使用最大CPU数进行计算: runtime.GOMAXPROCS(n int)设置可同时执行的最大CPU个数,并返回先前的设置. 若n\u003c1, 不会改变当前设置, 本地机器的CPU个数可以通过NumCPU查询 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:5:3","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r2. Sync.WaitGroup 等待goroutine结束 package main import ( \"sync\" ) type httpPkg struct{} func (httpPkg) Get(url string) {} var http httpPkg func main() { var wg sync.WaitGroup var urls = []string{ \"http://www.golang.org/\", \"http://www.google.com/\", \"http://www.somestupidname.com/\", } for _, url := range urls { // waitgroup计数. wg.Add(1) // Launch a goroutine to fetch the URL. go func(url string) { // 函数完事之后告诉wg结束 defer wg.Done() // Fetch the URL. http.Get(url) }(url) } // 等待所有的goroutine结束. wg.Wait() } channel 通道 特点: 空读写阻塞，写关闭异常，读关闭空零 channel是一种特殊的类型, 与map类似; channel可以使用make创建的底层数据结构的引用 用于多个goroutine的通信, 内部实现了同步, 保证数据安全 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:6:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r1. channel类型 创建channal类型 var 通道变量 chan 通道类型 make(chan Type) //等价于 make(chan Type ,0) 无缓冲阻塞通道 make(chan Type, capacity) // 有缓冲通道 channal的零值是nil 当capacity 的值为0时, channal 是无缓冲阻塞读写, 当capacity 的值大于0时 ,channal是有缓冲物阻塞读写 channal使用\u003c-来接收和发送数据 k v channal \u003c- value 发送value值到channal \u003c-channal 接收并将其丢弃 x:= \u003c- channal 从channal中接收数据赋值给x x, ok:= \u003c- channal 同上,并检查通道是否关闭, 将此状态赋值给ok, 开启是true, 关闭是false 默认情况下, channal是阻塞的, 除非接收端和发送端同时准备好才能完成发送和接收操作 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:7:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r2. 缓冲机制 通道可以分为有缓冲通道和无缓冲通道; 无缓冲通道在接收之前没有能力保存任何值的通道 无缓冲阻塞, 要求接收方和发送发同时准备好 , 才能完成接收和发送的动作,否则会导致先接收或者发送的goroutine 阻塞等待 接收和发送是同步的, 谁也离不开谁 package main import \"fmt\" func main() { var cha = make(chan int) go func() { for i := 0; i \u003c 3; i++ { cha \u003c- i } }() for { fmt.Println(\u003c-cha) // 阻塞 } } 有缓冲通道在接收之前就能存储一个或多个值得通道 有缓冲通道不会强制要求goroutine之间必须同时完成接收和发送; 只有在通道中没有要接收的值得时候接收端才会阻塞; 只有在通道中没有可用缓冲区容纳发送的值时, 发送端就会阻塞 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:8:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r3. close和range 当发送者知道没有更多的数据发送时, 让接收者知道没有更多的数据可以接收,可以让接收者停止不必要的等待; 可以通过close和range实现 close关闭通道时注意: channal不能和文件一样去经常关闭,除非你确定没有数据需要传输; 或者想显示的关闭range()之类的才回去关闭channal; 关闭channal之后, 无法再次向channal发送数据 关闭channal之后,可以继续从channal接收数据 对于nil的channal, 无论接收和发送都会被阻塞 range package main import \"fmt\" func main() { var cha = make(chan int) go func() { for i := 0; i \u003c 3; i++ { cha \u003c- i } close(cha) }() for data:= range cha{ fmt.Println(data) } } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:9:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r4. 单向channal channal默认是双向的 定义单向channal var cha1 chan int //双向通道 var cha1 chan\u003c- int // 单向接收通道 var \u003c-chan int // 单向发送通道 可以将双向channal隐式转换为单向通道, 但是不能将单向channal转为双向channal 单向channal的应用: 定时器 package main import ( \"fmt\" \"time\" ) func main() { ticker := time.NewTicker(time.Second) for { \u003c- ticker.C fmt.Println(\"loop\") } } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:10:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r5. select Select 关键字监听channal的数据流动,select 的用法和switch非常相似 select有较多的限制;其中最大的限制就是每一个case语句中都要是一个I/O操作 select{ case cha\u003c-: // do case \u003c-cha: // do default: // do } select 阻塞; 满足条件时会从满足条件中的可执行语句中随机选择一个执行,没有执行default; 为了避免长时间阻塞; 使用time.After()执行超时操作 package main import ( \"fmt\" \"time\" ) func main() { ch := make(chan int) done := make(chan bool) go func() { for{ select { case val:= \u003c-ch: fmt.Println(val) case \u003c- time.After(time.Second*3): fmt.Println(\"已超时!\") done \u003c- true } } }() for i :=0; i\u003c10 ;i++{ ch \u003c-i } \u003c-done fmt.Println(\"程序终止\") } /** 0 1 2 3 4 5 6 7 8 9 已超时! 程序终止 */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175119/:11:0","tags":null,"title":"6-1. 并发与通道","uri":"/lang/go/go_base/20250515175119/"},{"categories":null,"content":"\r读 //csv文件读取 func ReadCsv(filepath string) { //打开文件(只读模式)，创建io.read接口实例 opencast,err:=os.Open(filepath) if err!=nil{ log.Println(\"csv文件打开失败！\") } defer opencast.Close() //创建csv读取接口实例 ReadCsv:=csv.NewReader(opencast) //获取一行内容，一般为第一行内容 read,_:=ReadCsv.Read() //返回切片类型：[chen hai wei] log.Println(read) //读取所有内容 ReadAll,err:=ReadCsv.ReadAll()//返回切片类型：[[s s ds] [a a a]] log.Println(ReadAll) /* 说明： 1、读取csv文件返回的内容为切片类型，可以通过遍历的方式使用或Slicer[0]方式获取具体的值。 2、同一个函数或线程内，两次调用Read()方法时，第二次调用时得到的值为每二行数据，依此类推。 3、大文件时使用逐行读取，小文件直接读取所有然后遍历，两者应用场景不一样，需要注意。 */ } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175114/:1:0","tags":null,"title":"5-1. go 操作csv","uri":"/lang/go/go_base/20250515175114/"},{"categories":null,"content":"\r写 //csv文件写入 func WriterCSV(path string) { //OpenFile读取文件，不存在时则创建，使用追加模式 File,err:=os.OpenFile(path,os.O_RDWR|os.O_APPEND|os.O_CREATE,0666) if err!=nil{ log.Println(\"文件打开失败！\") } defer File.Close() //创建写入接口 WriterCsv:=csv.NewWriter(File) str:=[]string{\"chen1\",\"hai1\",\"wei1\"} //需要写入csv的数据，切片类型 //写入一条数据，传入数据为切片(追加模式) err1:=WriterCsv.Write(str) if err1!=nil{ log.Println(\"WriterCsv写入文件失败\") } WriterCsv.Flush() //刷新，不刷新是无法写入的 log.Println(\"数据写入成功...\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175114/:2:0","tags":null,"title":"5-1. go 操作csv","uri":"/lang/go/go_base/20250515175114/"},{"categories":null,"content":"\r读数据库写入csv package main // 从Mysql中导出数据到CSV文件。 import ( \"database/sql\" \"encoding/csv\" \"fmt\" \"os\" _ \"github.com/go-sql-driver/mysql\" ) var ( tables = []string{\"goods\"} count = len(tables) ch = make(chan bool, count) ) func main() { db, err := sql.Open(\"mysql\", \"root:Abcd@123456@tcp(127.0.0.1:3306)/mxshop_goods_srv?charset=utf8\") defer db.Close() if err != nil { panic(err.Error()) } for _, table := range tables { go querySQL(db, table, ch) } for i := 0; i \u003c count; i++ { \u003c-ch } fmt.Println(\"Done!\") } func querySQL(db *sql.DB, table string, ch chan bool) { fmt.Println(\"开始处理：\", table) rows, _ := db.Query(fmt.Sprintf(\"SELECT * from %s\", table)) columns, err := rows.Columns() if err != nil { panic(err.Error()) } //values：一行的所有值，长度==列数 values := make([]sql.RawBytes, len(columns)) scanArgs := make([]interface{}, len(values)) for i := range values { scanArgs[i] = \u0026values[i] } var totalValues [][]string for rows.Next() { var s []string err = rows.Scan(scanArgs...) //把每行的内容添加到scanArgs，也添加到了values if err != nil { panic(err.Error()) } for _, v := range values { s = append(s, string(v)) fmt.Println(s) } totalValues = append(totalValues, s) } if err = rows.Err(); err != nil { panic(err.Error()) } writeToCSV(table+\".csv\", columns, totalValues) ch \u003c- true } func writeToCSV(file string, columns []string, totalValues [][]string) { // fmt.Println(columns) f, err := os.Create(file) if err != nil { panic(err) } f.WriteString(\"\\xEF\\xBB\\xBF\") //写入UTF-8 格式 defer f.Close() w := csv.NewWriter(f) for a, i := range totalValues { if a == 0 { w.Write(columns) w.Write(i) } else { // fmt.Println(i) w.Write(i) } } w.Flush() fmt.Println(\"处理完毕：\", file) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175114/:3:0","tags":null,"title":"5-1. go 操作csv","uri":"/lang/go/go_base/20250515175114/"},{"categories":null,"content":" 文件操作设计的I/O操作库 io – 提供基本的接口 io/ioutil – 封装了一些常用的接口 fmt – 实现格式化IO. 类似c语言中的printf和scanf bufio – 实现缓存I/O io/ioutil 读取文件目录 ReadDir(), 返回一个列表[]os.FileInfo, 列表中包含指定目录的目录信息 type FileInfo interface{ Name() string // 文件名称 Size() int64 // 文件大小 Mode() FileMode //打开模式 ModTime() time.Time //文件修改时间 IsDIr() bool // 是否是目录 Sys() interface{} // 基础数据源 } demo : 查看文件夹中所有文件, 并输出文件名 package main import ( \"fmt\" \"io/ioutil\" ) func getFileName(filePath string) { dir, err := ioutil.ReadDir(filePath) if err != nil { fmt.Println(err) } for _,file := range dir{ fileName := file.Name() fmt.Println(fileName) } } func main() { filePath := \"../../\" getFileName(filePath) } path/filepath Walk() 获取目录下所有文件和文件夹 package main import ( \"fmt\" \"io/fs\" \"path/filepath\" ) //walk() 获取指定目录下的所有文件和文件夹 func WalkDir(dirPath string) { err := filepath.Walk(dirPath, func(path string, info fs.FileInfo, err error) error { if info ==nil{ return err } if info.IsDir(){ return nil } fmt.Println(path) return nil }) if err != nil{ fmt.Printf(\"filepath.Walk() returned %v\\n\",err) } } func main() { WalkDir(\"./\") } OS os.Makedir创建文件夹,需要指定权限 创建文件夹没有权限会报错 os.MkdirAll创建文件夹 , 需要制定权限 创建文件夹, 不存在就创建, 存在返回nil os.Remove() 删除指定文件夹, 非空不能删除 os.RemoveAll() 删除指定文件夹, 非空也删除 os.OpenFile() 创建/读取文件 os.Open() 读文件 os.ModePerm 返回值: -rwxrwxrwx,类似0777 0.0.0.0.1 os.Open 与读的方式f ,e := os.OpenFile(“data.csv”) 0.0.0.0.2 os.OpenFile 读写方式f ,e := os.OpenFile(“data.csv”, os.O_CREATE|os.O_RDWR, 0644) ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:0","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.1 FileInfoFileInfo 接口中定义了 File 信息相关的方法。 type FileInfo interface { Name() string // base name of the file 文件名.扩展名 aa.txt Size() int64 // 文件大小，字节数 12540 Mode() FileMode // 文件权限 -rw-rw-rw- ModTime() time.Time // 修改时间 2020-09-23 16:30:53 +0800 CST IsDir() bool // 是否文件夹 Sys() interface{} // 基础数据源接口(can return nil) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:1","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.2 权限至于操作权限 perm，除非创建文件时才需要指定，不需要创建新文件时可以将其设定为０。虽然 Golang 语言给 perm 权限设定了很多的常量，但是习惯上也可以直接使用数字，如 0666 (具体含义和 Unix 系统的一致)。 权限控制： linux 下有2种文件权限表示方式，即“符号表示”和“八进制表示”。 （1）符号表示方式: - --- --- --- type owner group others 文件的权限是这样子分配的 读 写 可执行 分别对应的是 r w x 如果没有那一个权限，用 - 代替 (-文件 d目录 |连接符号) 例如：-rwxr-xr-x （2）八进制表示方式： r ——\u003e 004 w ——\u003e 002 x ——\u003e 001 - ——\u003e 000 0755 0777 0555 0444 0666 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:2","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.3 创建文件夹 os.MkDir(“dirName”,os.ModePerm )，创建一层 os.MkDirAll(“dirName”,os.ModePerm )，可以创建多层 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:3","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.4 创建文件 os.Create()，创建文件 采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会替换它（为空文件） ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:4","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.5 打开/关闭文件 os.Open(fileName) 只读 os.OpenFile(filename,mode,perm) –文件名称|文件的打开方式|文件的权限 file4,err := os.OpenFile(fileName1,os.O_RDONLY|os.O_WRONLY,os.ModePerm) 第一个参数：文件名称 第二个参数：文件的打开方式 模式 含义 os.O_WRONLY 只写 os.O_CREATE 创建文件 os.O_RDONLY 只读 os.O_RDWR 读写 os.O_TRUNC 清空 os.O_APPEND 追加 const ( // Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified. O_RDONLY int = syscall.O_RDONLY // open the file read-only. O_WRONLY int = syscall.O_WRONLY // open the file write-only. O_RDWR int = syscall.O_RDWR // open the file read-write. // The remaining values may be or'ed in to control behavior. O_APPEND int = syscall.O_APPEND // append data to the file when writing. O_CREATE int = syscall.O_CREAT // create a new file if none exists. O_EXCL int = syscall.O_EXCL // used with O_CREATE, file must not exist. O_SYNC int = syscall.O_SYNC // open for synchronous I/O. O_TRUNC int = syscall.O_TRUNC // truncate regular writable file when opened. ) 第三个参数：文件的权限：文件不存在创建文件，需要指定权限 package main import ( // \"fmt\" \"fmt\" \"os\" ) func main() { file, err := os.Open(\"word.txt\") // 读取文件 if err != nil { fmt.Println(\"error:\", err) return } defer file.Close() fileinfo, err := file.Stat() if err != nil { fmt.Println(err) return } fileSize := fileinfo.Size() // 文件大小 buffer := make([]byte, fileSize) bytesread, err := file.Read(buffer) //获取文件内容 if err != nil { fmt.Println(\"err::\", err) } fmt.Println(\"bytes read: \", bytesread) fmt.Println(\"bytestream to string: \", string(buffer)) } file.Close() 关闭文件 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:5","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.6 创建/删除文件/目录 os.Create()，创建文件 采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会替换它（为空文件） 删除文件 os.Remove() 删除文件夹 os.RemoveAll() //删除文件 err := os.Remove(\"/Users/ruby/Documents/pro/a/aa.txt\") if err != nil{ fmt.Println(\"err:\",err) return } fmt.Println(\"删除文件成功。。\") //删除目录 err := os.RemoveAll(\"/Users/ruby/Documents/pro/a/cc\") if err != nil{ fmt.Println(\"err:\",err) return } fmt.Println(\"删除目录成功。。\") ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:6","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.7 判断文件是否存在Golang 判断文件或文件夹是否存在的方法为使用 os.Stat() 函数返回的错误值进行判断。 如果返回的错误为 nil，说明文件或文件夹存在 如果返回的错误类型使用 os.IsNotExist() 判断为 true，说明文件或文件夹不存在 package main import ( \"log\" \"os\" ) func main() { fileInfo,err:=os.Stat(\"/Users/ruby/Documents/pro/a/aa.txt\") if err!=nil{ if os.IsNotExist(err){ log.Fatalln(\"file does not exist\") } } log.Println(\"file does exist. file information:\") log.Println(fileInfo) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:7","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.8 读取文件内容 读文件方式一：利用ioutil.ReadFile直接从文件读取到[]byte中 func Read0() (string){ f, err := ioutil.ReadFile(\"file/test\") if err != nil { fmt.Println(\"read fail\", err) } return string(f) } 读文件方式二：先从文件读取到file中，在从file读取到buf, buf在追加到最终的[]byte func Read1() (string){ //获得一个file f, err := os.Open(\"file/test\") if err != nil { fmt.Println(\"read fail\") return \"\" } //把file读取到缓冲区中 defer f.Close() var chunk []byte buf := make([]byte, 1024) for { //从file读取到buf中 n, err := f.Read(buf) if err != nil \u0026\u0026 err != io.EOF{ fmt.Println(\"read buf fail\", err) return \"\" } //说明读取结束 if n == 0 { break } //读取到最终的缓冲区中 chunk = append(chunk, buf[:n]...) } return string(chunk) //fmt.Println(string(chunk)) } 读文件方式三：先从文件读取到file, 在从file读取到Reader中，从Reader读取到buf, buf最终追加到[]byte //先从文件读取到file, 在从file读取到Reader中，从Reader读取到buf, buf最终追加到[]byte，这个排第三 func Read2() (string) { fi, err := os.Open(\"file/test\") if err != nil { panic(err) } defer fi.Close() r := bufio.NewReader(fi) var chunks []byte buf := make([]byte, 1024) for { n, err := r.Read(buf) if err != nil \u0026\u0026 err != io.EOF { panic(err) } if 0 == n { break } //fmt.Println(string(buf)) chunks = append(chunks, buf...) } return string(chunks) //fmt.Println(string(chunks)) } 读文件方式四：读取到file中，再利用ioutil将file直接读取到[]byte中 //读取到file中，再利用ioutil将file直接读取到[]byte中, 这是最优 func Read3() (string){ f, err := os.Open(\"file/test\") if err != nil { fmt.Println(\"read file fail\", err) return \"\" } defer f.Close() fd, err := ioutil.ReadAll(f) if err != nil { fmt.Println(\"read to fd fail\", err) return \"\" } return string(fd) } 四种方式读的速度排名是：前者为优 方式四 \u003e 方式一 \u003e 方式三 \u003e 方式二 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:8","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.9 写文件内容 写文件方式一：使用 io.WriteString 写入文件 func Write0() { fileName := \"file/test1\" strTest := \"测试测试\" var f *os.File var err error if CheckFileExist(fileName) { //文件存在 f, err = os.OpenFile(fileName, os.O_APPEND, 0666) //打开文件 if err != nil{ fmt.Println(\"file open fail\", err) return } }else { //文件不存在 f, err = os.Create(fileName) //创建文件 if err != nil { fmt.Println(\"file create fail\") return } } //将文件写进去 n, err1 := io.WriteString(f, strTest) if err1 != nil { fmt.Println(\"write error\", err1) return } fmt.Println(\"写入的字节数是：\", n) } 写文件方式二：使用 ioutil.WriteFile 写入文件 func Write1() { fileName := \"file/test2\" strTest := \"测试测试\" var d = []byte(strTest) err := ioutil.WriteFile(fileName, d, 0666) if err != nil { fmt.Println(\"write fail\") } fmt.Println(\"write success\") } 写文件方式三：使用 File(Write,WriteString) 写入文件 func Write2() { fileName := \"file/test3\" strTest := \"测试测试\" var d1 = []byte(strTest) f, err3 := os.Create(fileName) //创建文件 if err3 != nil{ fmt.Println(\"create file fail\") } defer f.Close() n2, err3 := f.Write(d1) //写入文件(字节数组) fmt.Printf(\"写入 %d 个字节n\", n2) n3, err3 := f.WriteString(\"writesn\") //写入文件(字节数组) fmt.Printf(\"写入 %d 个字节n\", n3) f.Sync() } // 或者 func WriteFile(fPath string) { //f, _ := os.OpenFile(fPath,os.O_APPEND,0666) f, err := os.OpenFile(fPath, os.O_CREATE|os.O_WRONLY, os.ModeAppend) defer f.Close() writeString, err := f.WriteString(\"你好\") if err != nil { fmt.Println(writeString) panic(err) return } fmt.Println(writeString) } 写文件方式四：使用 bufio.NewWriter 写入文件 func Write3() { fileName := \"file/test3\" f, err3 := os.Create(fileName) //创建文件 if err3 != nil{ fmt.Println(\"create file fail\") } w := bufio.NewWriter(f) //创建新的 Writer 对象 n4, err3 := w.WriteString(\"bufferedn\") fmt.Printf(\"写入 %d 个字节n\", n4) w.Flush() f.Close() } JSON文件操作","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:9","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.10 编码JSON 编码json: 从其他类型编码成json字符串 encoding/json Marshal 返回interface{}类型 的json编码, 通常interface{}类型会使用map或者结构体 MarshalIndent 类似于Marshal, 会使用缩进输出格式化json 使用map创建json package main import ( \"encoding/json\" \"fmt\" ) /** map创建json */ func main() { m:=make(map[string]interface{},3) m[\"name\"] = \"evan\" m[\"age\"] = 27 m[\"language\"] = []string{\"python\",\"golang\",\"javascript\"} result,_:=json.Marshal(m) resultMarshalIndent,_:=json.MarshalIndent(m,\"\",\" \") fmt.Println(string(result)) fmt.Println(string(resultMarshalIndent)) } /** {\"age\":27,\"language\":[\"python\",\"golang\",\"javascript\"],\"name\":\"evan\"} { \"age\": 27, \"language\": [ \"python\", \"golang\", \"javascript\" ], \"name\": \"evan\" } */ 使用结构体创建json(常用) 当在定义struct 的时, 可以在后面添加标签来控制编码和解码的过程; 是否要编码或者解码某个字段, JSON中的名字字段名称是什么, 可以选择的控制字段有三种 “-” :表示不要解析该字段 “omitempty” : 当字段为空的时候不要解析该字段, 比如: false 0 nil 长度为0的array map slice string “FieldName” : 当解析JSON的时候使用这个名字 package main import ( \"encoding/json\" \"fmt\" ) type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` Sex bool `json:\"sex\"` Birthday string `json:\"birthday\"` Company string `json:\"company,omitempty\"` Language []string `json:\"language\"` } func main() { person :=Person{\"Evan\",28,true,\"1994\",\"DCITS\",[]string{ \"python\",\"golang\", }} //result,err :=json.Marshal(person) result,err :=json.MarshalIndent(person,\"\",\" \") if err !=nil{ fmt.Println(err) return } fmt.Println(string(result)) } /** { \"name\": \"Evan\", \"age\": 28, \"sex\": true, \"birthday\": \"1994\", \"company\": \"DCITS\", \"language\": [ \"python\", \"golang\" ] } */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:10","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.11 解析JSON Unmarshal() 解析json,是Marshal()的反向操作 要将json数据解码写入一个接口类型值, 函数会将解码数据为如下对照关系写入接口 interface类型 json类型 Bool 布尔类型 Float64 数字类型 string 字符串类型 []interface{} 数组 map 对象 nil null 如果json的值不满足或者不匹配给出的目标类型, 或者JSON数字写入目标类型时溢出, unmarsha()函数会跳过该字段, 尽可能满足其余的解码操作 struce 解码json(推荐使用) package main import ( \"encoding/json\" \"fmt\" ) type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` Sex bool `json:\"sex\"` Birthday string `json:\"birthday\"` Company string `json:\"company,omitempty\"` Language []string `json:\"language\"` } func main() { jsonStr := ` { \"name\":\"evan\", \"age\":28, \"sex\":true, \"birthday\":\"1994\", \"company\":\"DCITS\", \"language\":[\"python\",\"golang\",\"javascript\"] } ` var person Person err:=json.Unmarshal([]byte(jsonStr),\u0026person) if err!=nil { fmt.Println(err) return } fmt.Println(person) } // {evan 28 true 1994 DCITS [python golang javascript]} ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:11","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r0.12 拓展 fastjson 速度是原生json操作速度的10倍 地址: https://github.com/valyala/fastjson XML文件操作 XML是一门标记语言 XML对大小写敏感 Xml 文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003cWrapper\u003e \u003cNote\u003e \u003cTo\u003eGeorge\u003c/To\u003e \u003cFrom\u003eJohn\u003c/From\u003e \u003cBody\u003e \u003cBodychild\u003ebc1\u003c/Bodychild\u003e \u003cBodychild\u003ebc2\u003c/Bodychild\u003e \u003c/Body\u003e \u003c/Note\u003e \u003cNote\u003e \u003cTo\u003eGeorge2\u003c/To\u003e \u003cFrom\u003eJohn2\u003c/From\u003e \u003cBody\u003e \u003cBodychild\u003ebc1\u003c/Bodychild\u003e \u003cBodychild\u003ebc2\u003c/Bodychild\u003e \u003c/Body\u003e \u003c/Note\u003e \u003c/Wrapper\u003e golang code package main import ( \"encoding/xml\" \"fmt\" \"io/ioutil\" ) type Wrapper struct { Note []Note } type Note struct{ To string From string Body Body } type Body struct { Bodychild []string } func main() { var res Wrapper content,err:=ioutil.ReadFile(\"test.xml\") if err!=nil{ fmt.Println(err) return } err = xml.Unmarshal(content,\u0026res) if err !=nil { fmt.Println(err) return } fmt.Println(\"解析后的xml文件为:\") fmt.Println(res) } 按行读文件 方法一 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) const FilePath = \"./test.txt\" func readLineOfOne() { f, err := os.Open(FilePath) if err!=nil { fmt.Println(err) os.Exit(2) } defer f.Close() bufReader := bufio.NewReader(f) i := 0 for { i++ //fmt.Println(i) line,err:= bufReader.ReadBytes('\\n') fmt.Println(\"-\u003e\",string(line)) if err== io.EOF { fmt.Println(\"read file finished.\") break }else if err!= nil { fmt.Println(err) os.Exit(2) } } } func main() { readLineOfOne() } bufReader.ReadBytes(’\\n’)和 bufReader.ReadString(’\\n’)在读到文件最后一行时，会同时返回内容line和io.EOF bufio.Reader 方法一(一行一行读) f, err := os.Open(\"./src/day1/file_read/1.txt\") if err != nil{ fmt.Println(err) os.Exit(2) } defer f.Close() bufReader := bufio.NewReader(f) var i = 0 for{ i++ fmt.Println(i) line,err := bufReader.ReadBytes('\\n') fmt.Println(string(line)) if err == io.EOF { fmt.Println(\"read the file finished\") break } if err != nil{ fmt.Println(err) os.Exit(2) } } 方法二 f, err := os.Open(\"./src/day1/file_read/1.txt\") if err != nil{ fmt.Println(err) os.Exit(2) } defer f.Close() bufReader := bufio.NewReader(f) var buf [256]byte var i = 0 for{ i++ fmt.Println(i) n,err := bufReader.Read(buf[:]) if err == io.EOF { fmt.Println(\"read the file finished\") break } if err != nil{ fmt.Println(err) os.Exit(2) } fmt.Println(string(buf[:n])) } bufReader.ReadBytes(’\\n’)和 bufReader.ReadString(’\\n’)在读到文件最后一行时，会同时返回内容line和io.EOF。而bufReader.Read()读取到末尾时，会先返回内容，然后再下一次迭代时才返回io.EOF 读写文件的四种方式","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:0:12","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r1 读文件读取的文件放在file/test：也就是file包下的test这个文件，里面写多一点文件 读文件方式一：利用ioutil.ReadFile直接从文件读取到[]byte中 ioutil.ReadFile 将文件全部读到内存 func Read0() (string){ f, err := ioutil.ReadFile(\"file/test\") if err != nil { fmt.Println(\"read fail\", err) } return string(f) } 读文件方式二：先从文件读取到file中，在从file读取到buf, buf在追加到最终的[]byte os.Open 文件流的方式读取文件 func Read1() (string){ //获得一个file f, err := os.Open(\"file/test\") if err != nil { fmt.Println(\"read fail\") return \"\" } //把file读取到缓冲区中 defer f.Close() var chunk []byte buf := make([]byte, 1024) for { //从file读取到buf中 n, err := f.Read(buf) if err != nil \u0026\u0026 err != io.EOF{ fmt.Println(\"read buf fail\", err) return \"\" } //说明读取结束 if n == 0 { break } //读取到最终的缓冲区中 chunk = append(chunk, buf[:n]...) } return string(chunk) //fmt.Println(string(chunk)) } 读文件方式三：先从文件读取到file, 在从file读取到Reader中，从Reader读取到buf, buf最终追加到[]byte //先从文件读取到file, 在从file读取到Reader中，从Reader读取到buf, buf最终追加到[]byte，这个排第三 func Read2() (string) { fi, err := os.Open(\"file/test\") if err != nil { panic(err) } defer fi.Close() r := bufio.NewReader(fi) var chunks []byte buf := make([]byte, 1024) for { n, err := r.Read(buf) if err != nil \u0026\u0026 err != io.EOF { panic(err) } if 0 == n { break } //fmt.Println(string(buf)) chunks = append(chunks, buf...) } return string(chunks) //fmt.Println(string(chunks)) } 读文件方式四：读取到file中，再利用ioutil将file直接读取到[]byte中 //读取到file中，再利用ioutil将file直接读取到[]byte中, 这是最优 func Read3() (string){ f, err := os.Open(\"file/test\") if err != nil { fmt.Println(\"read file fail\", err) return \"\" } defer f.Close() fd, err := ioutil.ReadAll(f) if err != nil { fmt.Println(\"read to fd fail\", err) return \"\" } return string(fd) } 读取速度比较 经过我的测试，这四种方式读的速度排名是：前者为优 方式四 \u003e 方式一 \u003e 方式三 \u003e 方式二 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:1:0","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r2 写文件 写文件方式一：使用 io.WriteString 写入文件 func Write0() { fileName := \"file/test1\" strTest := \"测试测试\" var f *os.File var err error if CheckFileExist(fileName) { //文件存在 f, err = os.OpenFile(fileName, os.O_APPEND, 0666) //打开文件 if err != nil{ fmt.Println(\"file open fail\", err) return } }else { //文件不存在 f, err = os.Create(fileName) //创建文件 if err != nil { fmt.Println(\"file create fail\") return } } //将文件写进去 n, err1 := io.WriteString(f, strTest) if err1 != nil { fmt.Println(\"write error\", err1) return } fmt.Println(\"写入的字节数是：\", n) } 写文件方式二：使用 ioutil.WriteFile 写入文件 func Write1() { fileName := \"file/test2\" strTest := \"测试测试\" var d = []byte(strTest) err := ioutil.WriteFile(fileName, d, 0666) if err != nil { fmt.Println(\"write fail\") } fmt.Println(\"write success\") } 写文件方式三：使用 File(Write,WriteString) 写入文件 func Write2() { fileName := \"file/test3\" strTest := \"测试测试\" var d1 = []byte(strTest) f, err3 := os.Create(fileName) //创建文件 if err3 != nil{ fmt.Println(\"create file fail\") } defer f.Close() n2, err3 := f.Write(d1) //写入文件(字节数组) fmt.Printf(\"写入 %d 个字节n\", n2) n3, err3 := f.WriteString(\"writesn\") //写入文件(字节数组) fmt.Printf(\"写入 %d 个字节n\", n3) f.Sync() } 写文件方式四：使用 bufio.NewWriter 写入文件 func Write3() { fileName := \"file/test3\" f, err3 := os.Create(fileName) //创建文件 if err3 != nil{ fmt.Println(\"create file fail\") } w := bufio.NewWriter(f) //创建新的 Writer 对象 n4, err3 := w.WriteString(\"bufferedn\") fmt.Printf(\"写入 %d 个字节n\", n4) w.Flush() f.Close() } 检查文件是否存在： func CheckFileExist(fileName string) bool { _, err := os.Stat(fileName) if os.IsNotExist(err) { return false } return true } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175110/:2:0","tags":null,"title":"5-0. 文件操作","uri":"/lang/go/go_base/20250515175110/"},{"categories":null,"content":"\r1 空结构体 空结构体不包含任何字段struct{}{} 空结构体不占内存空间 package main import ( \"fmt\" \"unsafe\" ) func main() { fmt.Println(unsafe.Sizeof(struct{}{})) // 0 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175106/:1:0","tags":null,"title":"4-3. 空结构体","uri":"/lang/go/go_base/20250515175106/"},{"categories":null,"content":"\r2 空结构的作用","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175106/:2:0","tags":null,"title":"4-3. 空结构体","uri":"/lang/go/go_base/20250515175106/"},{"categories":null,"content":"\r2.1 1. 与map结合实现set Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间 将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。 type Set map[string]struct{} func (s Set) Has(key string) bool { _, ok := s[key] return ok } func (s Set) Add(key string) { s[key] = struct{}{} } func (s Set) Delete(key string) { delete(s, key) } func main() { s := make(Set) s.Add(\"Tom\") s.Add(\"Sam\") fmt.Println(s.Has(\"Tom\")) fmt.Println(s.Has(\"Jack\")) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175106/:2:1","tags":null,"title":"4-3. 空结构体","uri":"/lang/go/go_base/20250515175106/"},{"categories":null,"content":"\r2.2 2. 制造伪迭代器 for range make([]struct{}, 100) { fmt.Println(\"迭代器\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175106/:2:2","tags":null,"title":"4-3. 空结构体","uri":"/lang/go/go_base/20250515175106/"},{"categories":null,"content":"\r2.3 3. 不发送数据的channel func worker(ch chan struct{}) { \u003c-ch fmt.Println(\"do something\") close(ch) } func main() { ch := make(chan struct{}) go worker(ch) ch \u003c- struct{}{} } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175106/:2:3","tags":null,"title":"4-3. 空结构体","uri":"/lang/go/go_base/20250515175106/"},{"categories":null,"content":"\r2.4 4. 仅包含方法的结构体 type Door struct{} func (d Door) Open() { fmt.Println(\"Open the door\") } func (d Door) Close() { fmt.Println(\"Close the door\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175106/:2:4","tags":null,"title":"4-3. 空结构体","uri":"/lang/go/go_base/20250515175106/"},{"categories":null,"content":"\r接口 接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。 牢记接口（interface）是一种类型。 接口类型是一种抽象的类型, 不会暴露出他所代表的内部属性的结构, 只会展示出他自己的方法,因此接口不能被实例化; **Golang中的接口没有数据字段, 只有定义的方法;**接口是方法的集合 接口命名规范: 单个函数的接口名以\"er\"作为后缀, 接口的实现则去掉\"er\" 两个函数的接口名综合两个函数名, 以\"er\"作为后缀, 接口的实现则去掉\"er\" 三个以上函数以上的接口名, 抽象这个接口的功能, 类似于结构体命名; ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:0:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r1 1. 鸭子类型 鸭子模型: 当看到一只鸟走起来像鸭子,游泳像鸭子, 叫起来像鸭子, 那这只鸟就可以被称为鸭子; 在程序设计中, 鸭子模型 是动态类型语言的一种风格;一个对象有效的语义, 不是由继承自特定的类或实现特定的接口来决定, 而是由当前方法和属性的集合决定; go语言通过接口实现了鸭子模型, 对于Go来说, 我们不关心对象是什么类型,或者到底是不是鸭子, 我们只关心行为, 关心他是如何使用的. 一般来说, 静态类型语言在编译时便已经确定了变量的类型, 但是go是在编译时推断变量的类型 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:1:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r2 2. 接口的定义Go语言提倡面向接口编程。 每个接口由数个方法组成，接口的定义格式如下： type 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … } 其中： 接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。 举个例子： type writer interface{ Write([]byte) error } 当你看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:2:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r3 3. 接口的实现 一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。 一个类型可以实现多个接口, 多个类型也可以实现同一个接口, 任何一个类型都实现了空接口; package main import \"fmt\" type Animal interface { Talk() Eat() Name() string } type Dog struct { } func (d Dog) Talk() { fmt.Println(\"汪汪汪\") } func (d Dog) Eat() { fmt.Println(\"我在吃骨头\") } func (d Dog) Name() string { fmt.Println(\"我的名字叫旺财\") return \"旺财\" } func main() { var d Dog // Dog 中需要全部实现AnimaI的方法集合 var a Animal a = d // 接口赋值 a.Name() a.Eat() a.Talk() } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:3:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r4 4. 接口类型变量那实现了接口有什么用呢？ 接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量。 func main() { var x Sayer // 声明一个Sayer类型的变量x a := cat{} // 实例化一个cat b := dog{} // 实例化一个dog x = a // 可以把cat实例直接赋值给x x.say() // 喵喵喵 x = b // 可以把dog实例直接赋值给x x.say() // 汪汪汪 } Tips： 观察下面的代码，体味此处_的妙用 // 摘自gin框架routergroup.go type IRouter interface{ ... } type RouterGroup struct { ... } var _ IRouter = \u0026RouterGroup{} // 确保RouterGroup实现了接口IRouter ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:4:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r5 5. 接口赋值 用户自定义的类型实现了某个接口类型的所有方法, 那么这个用户自定义的类型的值就可以赋值给这个接口. 这个赋值会把用户定义类型的值存入到接口类型变量中; 接口变量: 接口变量存储了两部分信息, 一部分是分配给接口变量的具体值(接口实现者的值), 二是值得类型的描述器(接口实现者的类型) 接口赋值存在两种情况 将对象实例赋值给接口 将一个接口赋值给另一个接口 只要两个接口拥有相同的方法集就可以, 就可以相互赋值 如果两个接口方法集不同, 接口A的方法集是接口B的方法集的子集, 那么接口A可以赋值给接口B, 反之不成立 将对象实例赋值给接口 package main import \"fmt\" type IDatabaser interface { Connect() error DisConnect() error } type Redis struct { DBName string } func (redis Redis) Connect() error { fmt.Println(\"redis connect DB=\u003e \" + redis.DBName) fmt.Println(\"redis connect success!\") return nil } func (redis Redis) DisConnect() error { fmt.Println(\"redis disconnect success!\") return nil } func main() { var redisObj = Redis{DBName: \"Evan\"} var idb IDatabaser // 接口变量 idb = redisObj //接口赋值: redisObj这个类型实例实现了接口中的所有方法 _ = idb.Connect() _ = idb.DisConnect() } /** redis connect DB=\u003e Evan redis connect success! redis disconnect success! */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:5:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r6 6. 接口嵌套(继承) 接口的嵌入也叫接口组合, 在python中叫继承如果接口A作为接口B的一个嵌入字段, 那么接口B中就包含了接口A中的所有方法 一个接口只接受其它接口的嵌入, 嵌入结构体和其他类型会报错 一个接口不能嵌入接口本身, 包括直接嵌入和间接嵌入 type Peopler1 interface { GetName() string } type Peopler2 interface { Peopler1 GetAge() int } type Peopler3 interface { Peopler2 GetHeight() int } type People struct { name string age int height int } func (p People) GetHeight() int { return p.height } func (p People) GetName() string { return p.name } func (p People) GetAge() int { return p.age } func main() { var p = People{\"evan\",18,180} fmt.Println(p.GetName()) fmt.Println(p.GetAge()) fmt.Println(p.GetHeight()) var p3 Peopler3 p3 = p fmt.Println(p3.GetName()) fmt.Println(p3.GetAge()) fmt.Println(p3.GetHeight()) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:6:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r7 7. 空接口 空接口 interface{}是golang中最特殊的接口, 在python3中,任何一个类都会继承Object基类, 而go中的空接口interface{}类似于python3中的基类Object 空接口中不包含热河方法, 所以类型其实都实现了空接口;空接口可以接收任何值; 不能将空接口赋值到其他类型, 如果需要这么做必须使用类型断言. package main import \"fmt\" func main() { var a = \"1\" var nullInterface interface{} = a var b string = nullInterface.(string) // 类型断言,接口类型向普通类型转换 fmt.Println(b) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:7:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r7.1 7.1 空接口的应用 空接口作为函数的参数 使用空接口实现可以接收任意类型的函数参数。 // 空接口作为函数参数 func show(a interface{}) { fmt.Printf(\"type:%T value:%v\\n\", a, a) } 空接口作为map的值 使用空接口实现可以保存任意值的字典。 // 空接口作为map值 var studentInfo = make(map[string]interface{}) studentInfo[\"name\"] = \"沙河娜扎\" studentInfo[\"age\"] = 18 studentInfo[\"married\"] = false fmt.Println(studentInfo) ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:7:1","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r8 8. 断言 断言是使用在接口变量上的操作, 简单来说,接口类型向普通类型转换就是类型断言 断言语法 t, ok := X.(T) // 判断接口变量X的类型是不是T, 如果断言成功,则ok为true,t的值为X动态值; 否则ok为false,t的值为类型T的初始值, t的类型始终是T 断言有两种方式 Ok-pattern 适用于接口类型较少 if value , ok := X.(T); ok ==true{ } switch-type 要断言的接口类型较多 switch value := 接口变量.(type){ case type1: // dosomething case type2: // dosomething default: // 当接口类型没有被捕获到的时候do } 示例 package main import ( \"fmt\" ) type e interface {} func Map(f func(a e)e ,arr []e) []e{ res := make([]e,0,1) for _ ,item := range arr{ _res := f(item) res = append(res,_res) } return res } func main() { a:= []e{\"1\",\"2\",\"3\",1,2,3} b:= []e{1,2,3,4,5} fu := func(arg e)e{ var res e switch arg.(type) { // 断言 case string: res = arg.(string)+\"--\" case int: res = arg.(int)* 2 } return res } res:= Map(fu,a) fmt.Println(res) res = Map(fu,b) fmt.Println(res) } /** *[1-- 2-- 3-- 2 4 6] *[2 4 6 8 10] */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:8:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r9 9. 侵入式接口和非侵入式接口 侵入式接口和非侵入式接口的区别 侵入式接口: 需要显式的创建一个类去实现某一个接口 非侵入式接口: 不需要显式的创建一个类去实现接口; 非侵入式更加简洁灵活, 更注重实用性. 在golang中, 接口是非侵入式的, 非侵入式的优点: 去掉了繁琐的继承体系, golang中类的继承并无意义, 你只需要知道这个类实现了哪些方法, 每个方法是何含义就可以了; 实现类的接口时, 只需要关心自己应该提供哪些方法, 不用纠结接口需要拆分的多细才合适, 接口由使用方按需定义, 而不用事前规划; 不用为了实现一个接口而导入一个包, 多引用一个外部的包, 就意味着更多的耦合, 接口由使用方按需定义, 使用方不用关心是否有其他模块定义过类似的接口 代码 package main import ( \"fmt\" ) type IPhoner interface { Call() error Video() error Game() error } type Phone struct { Name string } func (p *Phone) Call() error { fmt.Println(p.Name , \"start call\") return nil } func (p *Phone) Video() error{ fmt.Println(p.Name , \"start video\") return nil } func (p *Phone) Game() error{ fmt.Println(p.Name, \"start game\") return nil } func main() { var iphone IPhoner = \u0026Phone{Name: \"iphone\"} var huawei IPhoner = \u0026Phone{Name: \"huawei\"} iphone.Call() huawei.Game() } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:9:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r10 10. 值接收者和指针接收者实现接口的区别使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。 我们有一个Mover接口和一个dog结构体。 type Mover interface { move() } type dog struct {} ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:10:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r10.1 10.1 值接收者实现接口 func (d dog) move() { fmt.Println(\"狗会动\") } 此时实现接口的是dog类型： func main() { var x Mover var wangcai = dog{} // 旺财是dog类型 x = wangcai // x可以接收dog类型 var fugui = \u0026dog{} // 富贵是*dog类型 x = fugui // x可以接收*dog类型 x.move() } 从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值*fugui。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:10:1","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r10.2 10.2 指针接收者实现接口同样的代码我们再来测试一下使用指针接收者有什么区别： func (d *dog) move() { fmt.Println(\"狗会动\") } func main() { var x Mover var wangcai = dog{} // 旺财是dog类型 x = wangcai // x不可以接收dog类型 var fugui = \u0026dog{} // 富贵是*dog类型 x = fugui // x可以接收*dog类型 } 此时实现Mover接口的是*dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储*dog类型的值。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:10:2","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r11 11. 类型与接口的关系","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:11:0","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r11.1 11.1 一个类型实现多个接口一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： Mover接口。 // Sayer 接口 type Sayer interface { say() } // Mover 接口 type Mover interface { move() } dog既可以实现Sayer接口，也可以实现Mover接口。 type dog struct { name string } // 实现Sayer接口 func (d dog) say() { fmt.Printf(\"%s会叫汪汪汪\\n\", d.name) } // 实现Mover接口 func (d dog) move() { fmt.Printf(\"%s会动\\n\", d.name) } func main() { var x Sayer var y Mover var a = dog{name: \"旺财\"} x = a y = a x.say() y.move() } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:11:1","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r11.2 11.2 多个类型实现同一接口(多态)Go语言中不同的类型还可以实现同一接口 首先我们定义一个Mover接口，它要求必须由一个move方法。 // Mover 接口 type Mover interface { move() } 例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系： type dog struct { name string } type car struct { brand string } // dog类型实现Mover接口 func (d dog) move() { fmt.Printf(\"%s会跑\\n\", d.name) } // car类型实现Mover接口 func (c car) move() { fmt.Printf(\"%s速度70迈\\n\", c.brand) } 这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的move方法就可以了。 func main() { var x Mover var a = dog{name: \"旺财\"} var b = car{brand: \"保时捷\"} x = a x.move() x = b x.move() } 上面的代码执行结果如下： 旺财会跑 保时捷速度70迈 并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。 // WashingMachine 洗衣机 type WashingMachine interface { wash() dry() } // 甩干器 type dryer struct{} // 实现WashingMachine接口的dry()方法 func (d dryer) dry() { fmt.Println(\"甩一甩\") } // 海尔洗衣机 type haier struct { dryer //嵌入甩干器 } // 实现WashingMachine接口的wash()方法 func (h haier) wash() { fmt.Println(\"洗刷刷\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175100/:11:2","tags":null,"title":"4-2. 接口","uri":"/lang/go/go_base/20250515175100/"},{"categories":null,"content":"\r结构体 Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。 Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。 Go语言中通过struct来实现面向对象。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:0:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r1 0. Struct转换成map","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:1:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r1.1 0.1 Struct转json再转map mport ( \"encoding/json\" \"fmt\" \"reflect\" \"time\" ) type Persion struct { Id int Name string Address string } func main() { StructToMapViaJson() //StructToMapViaReflect() } func StructToMapViaJson() { m := make(map[string]interface{}) t := time.Now() person := Persion{ Id: 98439, Name: \"zhaondifnei\", Address: \"大沙地\", } j, _ := json.Marshal(person) json.Unmarshal(j, \u0026m) fmt.Println(m) fmt.Println(time.Now().Sub(t)) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:1:1","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r1.2 0.2 反射Struct 转map 是方法一速度的两倍 func StructToMapViaReflect() { m := make(map[string]interface{}) t := time.Now() person := Persion{ Id: 98439, Name: \"zhaondifnei\", Address: \"大沙地\", } elem := reflect.ValueOf(\u0026person).Elem() relType := elem.Type() for i := 0; i \u003c relType.NumField(); i++ { m[relType.Field(i).Name] = elem.Field(i).Interface() } fmt.Println(m) fmt.Printf(\"duration:%d\", time.Now().Sub(t)) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:1:2","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r2 1. 结构体的定义 使用type和struct关键字来定义结构体，具体代码格式如下： type 类型名 struct { 字段名 字段类型 字段名 字段类型 … } 类型名：标识自定义结构体的名称，在同一个包内不能重复。 字段名：表示结构体字段名。结构体中的字段名必须唯一。 字段类型：表示结构体字段的具体类型。 举个例子，我们定义一个Person（人）结构体，代码如下： type person struct { name string city string age int8 } 同样类型的字段也可以写在一行， type person1 struct { name, city string age int8 } 结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:2:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r3 2. 结构体实例化 只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。 结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。 var 结构体实例 结构体类型 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:3:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r3.1 2.1 基本实例化 type person struct { name string city string age int8 } func main() { var p1 person p1.name = \"沙河娜扎\" p1.city = \"北京\" p1.age = 18 fmt.Printf(\"p1=%v\\n\", p1) //p1={沙河娜扎 北京 18} fmt.Printf(\"p1=%#v\\n\", p1) //p1=main.person{name:\"沙河娜扎\", city:\"北京\", age:18} } 我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:3:1","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r3.2 2.2 匿名结构体 在定义一些临时数据结构等场景下还可以使用匿名结构体。 package main import ( \"fmt\" ) func main() { var user struct{Name string; Age int} user.Name = \"小王子\" user.Age = 18 fmt.Printf(\"%#v\\n\", user) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:3:2","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r3.3 2.3 创建指针类型结构体 我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下： var p2 = new(person) fmt.Printf(\"%T\\n\", p2) //*main.person fmt.Printf(\"p2=%#v\\n\", p2) //p2=\u0026main.person{name:\"\", city:\"\", age:0} 需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。 var p2 = new(person) p2.name = \"小王子\" p2.age = 28 p2.city = \"上海\" fmt.Printf(\"p2=%#v\\n\", p2) //p2=\u0026main.person{name:\"小王子\", city:\"上海\", age:28} ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:3:3","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r3.4 2.4 取结构体的地址实例化使用\u0026对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。 p3 := \u0026person{} fmt.Printf(\"%T\\n\", p3) //*main.person fmt.Printf(\"p3=%#v\\n\", p3) //p3=\u0026main.person{name:\"\", city:\"\", age:0} p3.name = \"七米\" p3.age = 30 p3.city = \"成都\" fmt.Printf(\"p3=%#v\\n\", p3) //p3=\u0026main.person{name:\"七米\", city:\"成都\", age:30} p3.name = \"七米\"其实在底层是(*p3).name = \"七米\"，这是Go语言帮我们实现的语法糖。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:3:4","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r4 3. 结构体初始化没有初始化的结构体，其成员变量都是对应其类型的零值。 type person struct { name string city string age int8 } func main() { var p4 person fmt.Printf(\"p4=%#v\\n\", p4) //p4=main.person{name:\"\", city:\"\", age:0} } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:4:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r4.1 3.1 使用键值对初始化 使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。 p5 := person{ name: \"小王子\", city: \"北京\", age: 18, } fmt.Printf(\"p5=%#v\\n\", p5) //p5=main.person{name:\"小王子\", city:\"北京\", age:18} 也可以对结构体指针进行键值对初始化，例如： p6 := \u0026person{ name: \"小王子\", city: \"北京\", age: 18, } fmt.Printf(\"p6=%#v\\n\", p6) //p6=\u0026main.person{name:\"小王子\", city:\"北京\", age:18} 当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。 p7 := \u0026person{ city: \"北京\", } fmt.Printf(\"p7=%#v\\n\", p7) //p7=\u0026main.person{name:\"\", city:\"北京\", age:0} ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:4:1","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r4.2 3.2 使用值的列表初始化初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值： p8 := \u0026person{ \"沙河娜扎\", \"北京\", 28, } fmt.Printf(\"p8=%#v\\n\", p8) //p8=\u0026main.person{name:\"沙河娜扎\", city:\"北京\", age:28} 使用这种格式初始化时，需要注意： 必须初始化结构体的所有字段。 初始值的填充顺序必须与字段在结构体中的声明顺序一致。 该方式不能和键值初始化方式混用。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:4:2","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r5 4. 结构体内存布局结构体占用一块连续的内存。 type test struct { a int8 b int8 c int8 d int8 } n := test{ 1, 2, 3, 4, } fmt.Printf(\"n.a %p\\n\", \u0026n.a) fmt.Printf(\"n.b %p\\n\", \u0026n.b) fmt.Printf(\"n.c %p\\n\", \u0026n.c) fmt.Printf(\"n.d %p\\n\", \u0026n.d) 输出： n.a 0xc0000a0060 n.b 0xc0000a0061 n.c 0xc0000a0062 n.d 0xc0000a0063 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:5:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r6 5.构造函数Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。 func newPerson(name, city string, age int8) *person { return \u0026person{ name: name, city: city, age: age, } } 调用构造函数 p9 := newPerson(\"张三\", \"沙河\", 90) fmt.Printf(\"%#v\\n\", p9) //\u0026main.person{name:\"张三\", city:\"沙河\", age:90} ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:6:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r7 6.方法和接收者**Go语言中的方法（Method）是一种作用于特定类型变量的函数。**这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。 方法的定义格式如下： func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) { 函数体 } 其中， 接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。 方法名、参数列表、返回参数：具体格式与函数定义相同。 举个例子： //Person 结构体 type Person struct { name string age int8 } //NewPerson 构造函数 func NewPerson(name string, age int8) *Person { return \u0026Person{ name: name, age: age, } } //Dream Person做梦的方法 func (p Person) Dream() { fmt.Printf(\"%s的梦想是学好Go语言！\\n\", p.name) } func main() { p1 := NewPerson(\"Evan\", 27) p1.Dream() } 方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:7:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r7.1 6.1 指针类型的接收者指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。 // SetAge 设置p的年龄 // 使用指针接收者 func (p *Person) SetAge(newAge int8) { p.age = newAge } 调用该方法： func main() { p1 := NewPerson(\"小王子\", 25) fmt.Println(p1.age) // 25 p1.SetAge(30) fmt.Println(p1.age) // 30 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:7:1","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r7.2 6.2 值类型的接收者当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。 // SetAge2 设置p的年龄 // 使用值接收者 func (p Person) SetAge2(newAge int8) { p.age = newAge } func main() { p1 := NewPerson(\"小王子\", 25) p1.Dream() fmt.Println(p1.age) // 25 p1.SetAge2(30) // (*p1).SetAge2(30) fmt.Println(p1.age) // 25 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:7:2","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r7.3 6.3 什么时候应该使用指针类型接收者 需要修改接收者中的值 接收者是拷贝代价比较大的大对象 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:7:3","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r7.4 6.4 任意类型添加方法在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。 //MyInt 将int定义为自定义MyInt类型 type MyInt int //SayHello 为MyInt添加一个SayHello的方法 func (m MyInt) SayHello() { fmt.Println(\"Hello, 我是一个int。\") } func main() { var m1 MyInt m1.SayHello() //Hello, 我是一个int。 m1 = 100 fmt.Printf(\"%#v %T\\n\", m1, m1) //100 main.MyInt } 注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:7:4","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r8 7. 结构体的匿名字段结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。 //Person 结构体Person类型 type Person struct { string int } func main() { p1 := Person{ \"小王子\", 18, } fmt.Printf(\"%#v\\n\", p1) //main.Person{string:\"北京\", int:18} fmt.Println(p1.string, p1.int) //北京 18 } **注意：**这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:8:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r9 8. 嵌套结构体 结构体嵌入接口值，结构体初始化后可以返回嵌入的接口值类型 一个结构体中可以嵌套包含另一个结构体或结构体指针，就像下面的示例代码那样。 //Address 地址结构体 type Address struct { Province string City string } //User 用户结构体 type User struct { Name string Gender string Address Address } func main() { user1 := User{ Name: \"小王子\", Gender: \"男\", Address: Address{ Province: \"山东\", City: \"威海\", }, } fmt.Printf(\"user1=%#v\\n\", user1)//user1=main.User{Name:\"小王子\", Gender:\"男\", Address:main.Address{Province:\"山东\", City:\"威海\"}} } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:9:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r9.1 8.1 嵌套匿名字段上面user结构体中嵌套的Address结构体也可以采用匿名字段的方式，例如： //Address 地址结构体 type Address struct { Province string City string } //User 用户结构体 type User struct { Name string Gender string Address //匿名字段 } func main() { var user2 User user2.Name = \"小王子\" user2.Gender = \"男\" user2.Address.Province = \"山东\" // 匿名字段默认使用类型名作为字段名 user2.City = \"威海\" // 匿名字段可以省略 fmt.Printf(\"user2=%#v\\n\", user2) //user2=main.User{Name:\"小王子\", Gender:\"男\", Address:main.Address{Province:\"山东\", City:\"威海\"}} } 当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:9:1","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r9.2 8.2 嵌套结构体的字段名冲突嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。 //Address 地址结构体 type Address struct { Province string City string CreateTime string } //Email 邮箱结构体 type Email struct { Account string CreateTime string } //User 用户结构体 type User struct { Name string Gender string Address Email } func main() { var user3 User user3.Name = \"沙河娜扎\" user3.Gender = \"男\" // user3.CreateTime = \"2019\" //ambiguous selector user3.CreateTime user3.Address.CreateTime = \"2000\" //指定Address结构体中的CreateTime user3.Email.CreateTime = \"2000\" //指定Email结构体中的CreateTime } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:9:2","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r10 9. 结构体的“继承”Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。 //Animal 动物 type Animal struct { name string } func (a *Animal) move() { fmt.Printf(\"%s会动！\\n\", a.name) } //Dog 狗 type Dog struct { Feet int8 *Animal //通过嵌套匿名结构体实现继承 } func (d *Dog) wang() { fmt.Printf(\"%s会汪汪汪~\\n\", d.name) } func main() { d1 := \u0026Dog{ Feet: 4, Animal: \u0026Animal{ //注意嵌套的是结构体指针 name: \"乐乐\", }, } d1.wang() //乐乐会汪汪汪~ d1.move() //乐乐会动！ } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:10:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r11 10. 结构体与JSON序列化JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号\"\"包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。 //Student 学生 type Student struct { ID int Gender string Name string } //Class 班级 type Class struct { Title string Students []*Student } func main() { c := \u0026Class{ Title: \"101\", Students: make([]*Student, 0, 200), } for i := 0; i \u003c 10; i++ { stu := \u0026Student{ Name: fmt.Sprintf(\"stu%02d\", i), Gender: \"男\", ID: i, } c.Students = append(c.Students, stu) } //JSON序列化：结构体--\u003eJSON格式的字符串 data, err := json.Marshal(c) if err != nil { fmt.Println(\"json marshal failed\") return } fmt.Printf(\"json:%s\\n\", data) //JSON反序列化：JSON格式的字符串--\u003e结构体 str := `{\"Title\":\"101\",\"Students\":[{\"ID\":0,\"Gender\":\"男\",\"Name\":\"stu00\"},{\"ID\":1,\"Gender\":\"男\",\"Name\":\"stu01\"},{\"ID\":2,\"Gender\":\"男\",\"Name\":\"stu02\"},{\"ID\":3,\"Gender\":\"男\",\"Name\":\"stu03\"},{\"ID\":4,\"Gender\":\"男\",\"Name\":\"stu04\"},{\"ID\":5,\"Gender\":\"男\",\"Name\":\"stu05\"},{\"ID\":6,\"Gender\":\"男\",\"Name\":\"stu06\"},{\"ID\":7,\"Gender\":\"男\",\"Name\":\"stu07\"},{\"ID\":8,\"Gender\":\"男\",\"Name\":\"stu08\"},{\"ID\":9,\"Gender\":\"男\",\"Name\":\"stu09\"}]}` c1 := \u0026Class{} err = json.Unmarshal([]byte(str), c1) if err != nil { fmt.Println(\"json unmarshal failed!\") return } fmt.Printf(\"%#v\\n\", c1) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:11:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r12 11. 结构体标签（Tag）Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下： `key1:\"value1\" key2:\"value2\"` 结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。 例如我们为Student结构体的每个字段定义json序列化时使用的Tag： //Student 学生 type Student struct { ID int `json:\"id\"` //通过指定tag实现json序列化该字段时的key Gender string //json序列化是默认使用字段名作为key name string //私有不能被json包访问 } func main() { s1 := Student{ ID: 1, Gender: \"男\", name: \"沙河娜扎\", } data, err := json.Marshal(s1) if err != nil { fmt.Println(\"json marshal failed!\") return } fmt.Printf(\"json str:%s\\n\", data) //json str:{\"id\":1,\"Gender\":\"男\"} } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:12:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r13 12. 结构体和方法补充知识点因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。我们来看下面的例子： type Person struct { name string age int8 dreams []string } func (p *Person) SetDreams(dreams []string) { p.dreams = dreams } func main() { p1 := Person{name: \"小王子\", age: 18} data := []string{\"吃饭\", \"睡觉\", \"打豆豆\"} p1.SetDreams(data) // 你真的想要修改 p1.dreams 吗？ data[1] = \"不睡觉\" fmt.Println(p1.dreams) // ? } 正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。 func (p *Person) SetDreams(dreams []string) { p.dreams = make([]string, len(dreams)) copy(p.dreams, dreams) } 同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175056/:13:0","tags":null,"title":"4-1. 结构体","uri":"/lang/go/go_base/20250515175056/"},{"categories":null,"content":"\r数组 数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。 声明数组的时候必须声明长度或者用[…], 不然就是切片. 初始化数组: var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度： balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 如果设置了数组的长度，我们还可以通过指定下标来初始化元素： // 将索引为 1 和 3 的元素初始化 balance := [5]float32{1:2.0,3:7.0} 切片(slice) Go 语言切片是对数组的抽象。也可以被看做为\"动态数组\",数组的长度不可改变,切片长度可变 在做函数调用时，slice 按引用传递，array 按值传递： 切片是对数组的引用,切片本身并不包含任何元素 切片的结构包括三个部分: 地址: 切片的地址一般指切片中的第一个元素所指向的内存地址, 用十六进制表示; 长度: 切片实际存在元素的个数; 容量: 从切片的起始元素开始到其底层数组中最后一个元素的个数; 切片的长度和容量都不是固定的,追加元素会使切片的长度和容量都增大 切片如果是从其他数组或者切片中来的话, 切片容量增加但是所引用数组容量不变 切片如果是从其他数组或者切片中来的话, 当切片长度大于多引用的数组容量时; 切片容量会以 切片新容量=2*切片当前容量 的速度扩容 切片如果是从其他数组或者切片中来的话, 当前片长量大于所引用数组的容量时, 切片中的第一个元素所指向的内存地址会发生改变; 定义切片 声明一个未指定大小的数组来定义切片(切片不需要说明长度)： var identifier []type 使用 make() 函数来创建切片: var slice1 []type = make([]type, len) 也可以简写为 slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 make([]T, length, capacity) //这里 len 是数组的长度并且也是切片的初始长度。 特殊 a := []int{2: 1} // 声明切片索引为2的写入1 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175051/:0:0","tags":null,"title":"3-3. 数组和切片","uri":"/lang/go/go_base/20250515175051/"},{"categories":null,"content":"\r0.1 切片函数 len() 获取长度 cap() 获取切片容量,即最大长度 append() 往切片尾部添加一个元素 copy() 拷贝 numbers 的内容到 numbers1 /* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) 合并多个数组： package main import \"fmt\" func main() { var arr1 = []int{1,2,3} var arr2 = []int{4,5,6} var arr3 = []int{7,8,9} var s1 = append(append(arr1, arr2...), arr3...) fmt.Printf(\"s1: %v\\n\", s1) } // s1: [1 2 3 4 5 6 7 8 9] 从切片中删除元素 package main import \"fmt\" func main() { sli1:=[]int{1,2,3} c:=append(sli1[0:1],sli1[2:]...) fmt.Println(c) } // [1 3] 插入切片头部 a := []int{1, 2} a :=append([]int{1},a...) 插入切片任意位置 a := []int{1, 2, 3, 4, 5} a := append(a, 0) //先把原来的切片长度+1 index := 2 //要把新元素插入到第二个位置 copy(a[index+1:], a[index:]) a[index] = 0 //新元素的值是0 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515175051/:0:1","tags":null,"title":"3-3. 数组和切片","uri":"/lang/go/go_base/20250515175051/"},{"categories":null,"content":"\r3.Go中的指针要搞明白Go语言中的指针需要先知道三个概念 指针地址 指针类型 指针取值 Go语言中的指针操作非常简单，我们只需要记住两个符号：\u0026：取地址，*：根据地址取值 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:0","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.1 关于指针 我们知道变量是用来存储数据的，变量的本质是给存储数据的内存地址起了一个好记的别名。比如我们定义了一个变量a:=10，这个时候可以直接通过a这个变量来读取内存中保存的10这个值。在计算机底层a这个变量其实对应了一个内存地址。 指针也是一个变量，但它是一种特殊的变量，它存储的数据不是一个普通的值，而是另一个变量的内存地址。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:1","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.2 指针地址和指针类型 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。 Go 语言中使用\u0026字符放在变量前面对变量进行取地址操作。Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如： *int、，*int64、*string等 取变量指针的语法如下： ptr := \u0026v 其中： v：代表被取地址的变量，类型为T ptr：用于接收地址的变量，ptr的类型就为*T，被称做T的指针类型。* 代表指针 举个例子： package main func main() { var a = 10 var b = \u0026a println(\u0026a) //0xc00003df60 println(\u0026b) //0xc00003df68 println(b) //0xc00003df60 println(*(\u0026b)) //0xc00003df60 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:2","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.3 指针取值在对普通变量进行\u0026操作符取地址后，会获得这个变量指针，然后可以对指针使用*操作，也就是指针取值 // 指针取值 var c = 20 // 得到c的地址，赋值给d var d = \u0026c // 打印d的值，也就是c的地址 fmt.Println(d) // 取出d指针所对应的值 fmt.Println(*d) // c对应地址的值，改成30 *d = 30 // c已经变成30了 fmt.Println(c) 改变内存中的值，会直接改变原来的变量值 // 这个类似于值传递 func fn4(x int) { x = 10 } // 这个类似于引用数据类型 func fn5(x *int) { *x = 20 } func main() { x := 5 fn4(x) fmt.Println(x) fn5(\u0026x) fmt.Println(x) } 我们创建了两个方法，一个是传入局部变量，一个是传入指针类型，最后运行得到的结果 5 20 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:3","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.4 new和make函数需要注意的是，指针必须在创建内存后才可以使用，这个和 slice 和 map是一样的 // 引用数据类型map、slice等，必须使用make分配空间，才能够使用 var userInfo = make(map[string]string) userInfo[\"userName\"] = \"zhangsan\" fmt.Println(userInfo) var array = make([]int, 4, 4) array[0] = 1 fmt.Println(array) 对于指针变量来说 // 指针变量初始化 var a *int *a = 100 fmt.Println(a) 执行上面的代码会引发panic，为什么呢？在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。Go 语言中new和make是内建的两个函数，主要用来分配内存。 这个时候，我们就需要使用new关键字来分配内存，new是一个内置的函数，它的函数签名如下： func new(Type) *Type 其中 Type表示类型，new函数只接受一个参数，这个参数是一个类型 *Type表示类型指针，new函数返回一个指向该类型内存地址的指针 实际开发中new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子： // 使用new关键字创建指针 aPoint := new(int) bPoint := new(bool) fmt.Printf(\"%T \\n\", aPoint) fmt.Printf(\"%T \\n\", bPoint) fmt.Println(*aPoint) fmt.Println(*bPoint) 本节开始的示例代码中 var a *int 只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:4","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.5 make和new的区别 两者都是用来做内存分配的 make只能用于slice、map以及channel的初始化，返回的还是这三个引用类型的本身 而new用于类型的内存分配，并且内存赌赢的值为类型的零值，返回的是指向类型的指针 函数 函数是基本的代码块，Go 语言最少有个 main() 函数。 函数如果使用参数，该变量可称为函数的形参。 形参就像定义在函数体内的局部变量。 调用函数，可以通过两种方式来传递参数： 传递类型 描述 值传递 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 引用传递 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:5","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.6 匿名函数 函数也是一种类型, 可以定义一个函数类型的变量 匿名函数就是一个没有名字的函数 f1 := func(a,b int) { fmt.Println(a+b) } f1(1,2) ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:6","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.7 值传递 传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。 package main import \"fmt\" func main() { /* 定义局部变量 */ var a int = 100 var b int = 200 fmt.Printf(\"交换前 a 的值为 : %d\\n\", a ) fmt.Printf(\"交换前 b 的值为 : %d\\n\", b ) /* 通过调用函数来交换值 */ swap(a, b) fmt.Printf(\"交换后 a 的值 : %d\\n\", a ) fmt.Printf(\"交换后 b 的值 : %d\\n\", b ) } /* 定义相互交换值的函数 */ func swap(x, y int) int { var temp int temp = x /* 保存 x 的值 */ x = y /* 将 y 值赋给 x */ y = temp /* 将 temp 值赋给 y*/ return temp; } /** 输出 交换前 a 的值为 : 100 交换前 b 的值为 : 200 交换后 a 的值 : 100 交换后 b 的值 : 200 */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:7","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.8 引用传递 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 package main import \"fmt\" func main() { /* 定义局部变量 */ var a int = 100 var b int = 200 fmt.Printf(\"交换前，a 的值 : %d,%p\\n\", a, \u0026a) fmt.Printf(\"交换前，b 的值 : %d,%p\\n\", b, \u0026b) /* 调用 swap() 函数 * \u0026a 指向 a 指针，a 变量的地址 * \u0026b 指向 b 指针，b 变量的地址 */ swap(\u0026a, \u0026b) fmt.Printf(\"交换后，a 的值 : %d\\n\", a) fmt.Printf(\"交换后，b 的值 : %d\\n\", b) } func swap(x *int, y *int) { fmt.Printf(\"交换中，x 的值 : %p,%p\\n\", x, \u0026x) fmt.Printf(\"交换中，y 的值 : %p,%p\\n\", y, \u0026y) var temp int temp = *x /* 保存 x 地址上的值 */ *x = *y /* 将 y 值赋给 x */ *y = temp /* 将 temp 值赋给 y */ } /** 交换前，a 的值 : 100,0x14000122008 交换前，b 的值 : 200,0x14000122010 交换中，x 的值 : 0x14000122008,0x1400011c020 交换中，y 的值 : 0x14000122010,0x1400011c028 交换后，a 的值 : 200 交换后，b 的值 : 100 */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:8","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.9 传值 VS 传指针 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。 传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:9","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.10 变量作用域 局部变量:在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 全局变量:在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。 可通过花括号来控制变量的作用域，花括号中的变量是单独的作用域，同名变量会覆盖外层。 a := 5 { a := 3 fmt.Println(\"in a = \", a) } fmt.Println(\"out a = \", a) /** in a = 3 out a = 5 */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:10","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.11 defer关键字 defer 定义的语句不会立即执行, 会在函数return之前执行 一般用作资源释放 多个defer 语句会以栈的规则执行 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:11","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.12 内置函数 close:主要用来关闭 channel len:用来求长度,比如 string、 array、 slice、map、 channe cap: 获取容器的容量大小 new:用来分配内存,主要用来分配值类型,比如iηt、 struct。返回的是指针 make:用来分配内存,主要用来分配引用类型,比如chan、map、 slice append:用来追加元素到数组、slice中 copy: 将一个slice拷贝到另一个slice中 delete: 删除map中的键值对 panic和 recover:用来做错误处理 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:12","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.13 闭包函数 闭包函数的两个必要条件: 1.嵌套函数 2. 外部引用 闭包函数的机制类似于面向对象的实例; 每一个实例对象内部的变量在实例生命周期内一直存在,只有重新创建实例时,内部变量才会被重置 package main import \"fmt\" func getSequence() func() int { i:=0 return func() int { i+=1 return i } } func main(){ /* nextNumber 为一个函数，函数 i 为 0 */ nextNumber := getSequence() /* 调用 nextNumber 函数，i 变量自增 1 并返回 */ fmt.Println(nextNumber()) fmt.Println(nextNumber()) fmt.Println(nextNumber()) /* 创建新的函数 nextNumber1，并查看结果 */ nextNumber1 := getSequence() fmt.Println(nextNumber1()) fmt.Println(nextNumber1()) } /** 1 2 3 1 2 */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:13","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.14 defer 和闭包函数 defer 直接返回函数调用 func OutputNum(num int) { fmt.Println(num) } func main() { for i := 0; i \u003c 5; i++ { defer OutputNum(i) // 4 3 2 1 0 } } defer OutputNum(i) 时, 系统会将OutputNum(i) 函数压入栈, 在main函数结束之前从栈中取出并调用,但是OutputNum(i) 函数是值传递, 将i的拷贝直接入栈, 所以传递给OutputNum 的是var i int的i值. defer 返回匿名函数 func main() { for i := 0; i \u003c 5; i++ { defer func() { fmt.Println(i) // 5 5 5 5 5 }() } } defer 匿名函数: 匿名函数中引用了外部变量i, 系统在把i 压入栈的时候记录的是i的内存地址, 所以多个匿名函数使用的是同一个i的内存地址 Python 闭包 道理和golang一样 # 题1 info = [] def func(i): def inner(): print(i) return inner for item in range(10): info.append(func(item)) info[0]() # 0 info[1]() # 1 info[4]() # 4 # 题2 def fun(): temp=[lambda x:x*i for i in range(4)] return temp for every in fun(): print(every(2)) # 6666 数组 数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。 声明数组的时候必须声明长度或者用[…], 不然就是切片. 初始化数组: var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度： balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 如果设置了数组的长度，我们还可以通过指定下标来初始化元素： // 将索引为 1 和 3 的元素初始化 balance := [5]float32{1:2.0,3:7.0} 切片(slice) Go 语言切片是对数组的抽象。也可以被看做为\"动态数组\",数组的长度不可改变,切片长度可变 在做函数调用时，slice 按引用传递，array 按值传递： 切片是对数组的引用,切片本身并不包含任何元素 切片的结构包括三个部分: 地址: 切片的地址一般指切片中的第一个元素所指向的内存地址, 用十六进制表示; 长度: 切片实际存在元素的个数; 容量: 从切片的起始元素开始到其底层数组中最后一个元素的个数; 切片的长度和容量都不是固定的,追加元素会使切片的长度和容量都增大 切片如果是从其他数组或者切片中来的话, 切片容量增加但是所引用数组容量不变 切片如果是从其他数组或者切片中来的话, 当切片长度大于多引用的数组容量时; 切片容量会以 切片新容量=2*切片当前容量 的速度扩容 切片如果是从其他数组或者切片中来的话, 当前片长量大于所引用数组的容量时, 切片中的第一个元素所指向的内存地址会发生改变; 定义切片 声明一个未指定大小的数组来定义切片(切片不需要说明长度)： var identifier []type 使用 make() 函数来创建切片: var slice1 []type = make([]type, len) 也可以简写为 slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 make([]T, length, capacity) //这里 len 是数组的长度并且也是切片的初始长度。 特殊 a := []int{2: 1} // 声明切片索引为2的写入1 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:14","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.15 切片函数 len() 获取长度 cap() 获取切片容量,即最大长度 append() 往切片尾部添加一个元素 copy() 拷贝 numbers 的内容到 numbers1 /* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) 合并多个数组： package main import \"fmt\" func main() { var arr1 = []int{1,2,3} var arr2 = []int{4,5,6} var arr3 = []int{7,8,9} var s1 = append(append(arr1, arr2...), arr3...) fmt.Printf(\"s1: %v\\n\", s1) } // s1: [1 2 3 4 5 6 7 8 9] 从切片中删除元素 package main import \"fmt\" func main() { sli1:=[]int{1,2,3} c:=append(sli1[0:1],sli1[2:]...) fmt.Println(c) } // [1 3] 映射(map) Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。 Map 是无序的，这是因为 Map 是使用 hash 表来实现的。 类似python中的字典dict, 可以使用内建函数 make 也可以使用 map 关键字来定义 Map: /* 声明变量，默认 map 是 nil */ var map_variable map[key_data_type]value_data_type /* 使用 make 函数 */ map_variable := make(map[key_data_type]value_data_type) 如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:15","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.16 删除键值对 delete(map,key) 删除键值对 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:16","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.17 sync.Mapmap不是携程安全的,在同一时刻只能由一个携程操作map; 并发操作map时要加锁; 因为加锁会消耗性能, 所以推荐使用go1.9中的sync.Map sync.Map的特点 内部通过冗余的数据结构降低加锁对性能的影响; 使用前无需初始化, 直接声明即可 sync.Map不使用map中的方式进行读取和赋值等操作 package main import ( \"fmt\" \"sync\" ) func main() { var GoMap sync.Map for i := 0; i \u003c 10000; i++ { fmt.Println(i, \"\\n\") go writeMap(GoMap, i, i) go readMap(GoMap, i) } } func readMap(goMap sync.Map, key int) int { res, ok := goMap.Load(key) //线程安全提取 if ok == true { fmt.Println(1) return res.(int) } else { return 0 } } func writeMap(goMap sync.Map, key int, value int) { goMap.Store(key, value) } Sync.Map 不能使用make()方法创建 Load() 方法的第一个返回值是一个接口类型,需要将其转换为map值得类型 syny.mao为了保证安全还是会有性能损耗,单线程推荐使用map range range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。 range表达式 第一分返回值 第二返回值 数组 index value 切片 index value 映射 key value 通道 value - 结构体 Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型; lgo语言没有class类，只是个结构体struct; 结构体传参以值方式传递; 结构体注意要点: 同一个包内结构体名称不能重复 同一个结构体内成员名不能重复 同类型的成员可以写在同一行 结构体|方法名|变量名的首字母大写时可以在当前包外使用 结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下： type struct_variable_type struct { member definition member definition ... member definition } 一旦定义了结构体类型，它就能用于变量的声明，语法格式如下： variable_name := structure_variable_type {value1, value2...valuen} 或 variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen} ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:17","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.18 结构体指针 你可以定义指向结构体的指针类似于其他指针变量，格式如下： var struct_pointer *Books 以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 \u0026 符号放置于结构体变量前： struct_pointer = \u0026Book1 使用结构体指针访问结构体成员，使用 “.” 操作符： struct_pointer.title ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:18","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.19 实例化结构体 实例化的方式: 标准实例化 new()函数实例化 取地址实例化 package main import \"fmt\" type Boy struct{ name string age int } func main() { // 标准实例化 var boy Boy boy.name=\"Evan\" fmt.Println(boy.name) //Evan //new() 函数实例化 newBoy := new(Boy) newBoy.age = 1 fmt.Println(newBoy) //取地址实例化 addrBoy := \u0026Boy{} addrBoy.name = \"Evan\" fmt.Println(addrBoy) //\u0026{Evan 0} fmt.Println(addrBoy.name) //Evan } 取值方式: 无论哪种取值方式都可以通过.的方式取值 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:19","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.20 初始化结构体 初始化方式初始化成员最后一定要有逗号 键值对初始化 类似map 列表初始化 必须按顺序初始化结构体中的全部成员 与键值对初始化方法不能混用 package main import \"fmt\" type Boy struct{ name string age int } func main() { // 初始化实例 boy :=Boy{ name: \"evan\", } boy2 :=Boy{ \"bigox\", 18, } fmt.Println(boy) fmt.Println(boy2) } /** {evan 0} {bigox 18} */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:20","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.21 结构体方法 方法: 包含了接收者的函数 结构体方法: 接收者可以使结构体类型的值后者指针 package main import \"fmt\" type Boy struct{ name string age int } // 指针类型接收 func (boy *Boy) changeName(){ boy.name = \"bigox\" } // 值类型接收 func (boy Boy) changeAge(){ boy.age = 18 } func main() { // 初始化实例 boy :=Boy{ \"evan\",17, } fmt.Println(boy) boy.changeName() fmt.Println(boy) boy.changeAge() fmt.Println(boy) } /** {evan 17} {bigox 17} {bigox 17} */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:21","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.22 结构体内嵌 结构体内嵌可以构建面向对象编程思想中的继承关系, 结构体实例化之后可以直接访问内嵌结构体中的所有成员变量和方法 package main import \"fmt\" type Book struct { title string author string num int id int } type BookBorrow struct { Book borrowTime string } type BookNotBorrow struct { Book readTime string } func main() { bookBorrow := \u0026BookBorrow{ } bookNotBorrow := \u0026BookNotBorrow{ } fmt.Println(bookBorrow) fmt.Println(bookNotBorrow) } 内嵌结构体实例化 package main import \"fmt\" type Book struct { title string author string num int id int } type BookBorrow struct { Book borrowTime string } type BookNotBorrow struct { Book readTime string } func main() { bookBorrow := \u0026BookBorrow{ Book:Book{ title :\"go\", author :\"Tom\", num :1, id :110, }, } fmt.Println(bookBorrow) bookBorrow.author = \"Jerry\" fmt.Println(bookBorrow) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:22","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.23 匿名结构体 没有名字的结构体 无需使用type关键字, 但是创建匿名结构体的时候也要创建对象 book := struct { title string id int }{ \"go\", 110, } fmt.Println(book) 匿名函数一般可用于组织全局变量| 构建数据模板|和解析JSON使用; 经常使用匿名结构体来临时存储经过解析后的JSON数据; ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:23","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r0.24 结构体匿名字段 创建结构体时, 字敦可以只有类型, 而没有字段名, 这样的字段成为匿名字段; type Person struct { Name string Age int `json:\"age\"` string // 匿名字段 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174546/:0:24","tags":null,"title":"3-2. 函数","uri":"/lang/go/go_base/20250515174546/"},{"categories":null,"content":"\r1 Go中的指针要搞明白Go语言中的指针需要先知道三个概念 指针地址 指针类型 指针取值 Go语言中的指针操作非常简单，我们只需要记住两个符号：\u0026：取地址，*：根据地址取值 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174541/:1:0","tags":null,"title":"3-1. go指针","uri":"/lang/go/go_base/20250515174541/"},{"categories":null,"content":"\r1.1 关于指针 我们知道变量是用来存储数据的，变量的本质是给存储数据的内存地址起了一个好记的别名。比如我们定义了一个变量a:=10，这个时候可以直接通过a这个变量来读取内存中保存的10这个值。在计算机底层a这个变量其实对应了一个内存地址。 指针也是一个变量，但它是一种特殊的变量，它存储的数据不是一个普通的值，而是另一个变量的内存地址。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174541/:1:1","tags":null,"title":"3-1. go指针","uri":"/lang/go/go_base/20250515174541/"},{"categories":null,"content":"\r1.2 指针地址和指针类型 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。 Go 语言中使用\u0026字符放在变量前面对变量进行取地址操作。Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如： *int、，*int64、*string等 取变量指针的语法如下： ptr := \u0026v 其中： v：代表被取地址的变量，类型为T ptr：用于接收地址的变量，ptr的类型就为*T，被称做T的指针类型。* 代表指针 举个例子： package main func main() { var a = 10 var b = \u0026a println(\u0026a) //0xc00003df60 println(\u0026b) //0xc00003df68 println(b) //0xc00003df60 println(*(\u0026b)) //0xc00003df60 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174541/:1:2","tags":null,"title":"3-1. go指针","uri":"/lang/go/go_base/20250515174541/"},{"categories":null,"content":"\r1.3 指针取值在对普通变量进行\u0026操作符取地址后，会获得这个变量指针，然后可以对指针使用*操作，也就是指针取值 // 指针取值 var c = 20 // 得到c的地址，赋值给d var d = \u0026c // 打印d的值，也就是c的地址 fmt.Println(d) // 取出d指针所对应的值 fmt.Println(*d) // c对应地址的值，改成30 *d = 30 // c已经变成30了 fmt.Println(c) 改变内存中的值，会直接改变原来的变量值 // 这个类似于值传递 func fn4(x int) { x = 10 } // 这个类似于引用数据类型 func fn5(x *int) { *x = 20 } func main() { x := 5 fn4(x) fmt.Println(x) fn5(\u0026x) fmt.Println(x) } 我们创建了两个方法，一个是传入局部变量，一个是传入指针类型，最后运行得到的结果 5 20 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174541/:1:3","tags":null,"title":"3-1. go指针","uri":"/lang/go/go_base/20250515174541/"},{"categories":null,"content":"\r1.4 new和make函数需要注意的是，指针必须在创建内存后才可以使用，这个和 slice 和 map是一样的 // 引用数据类型map、slice等，必须使用make分配空间，才能够使用 var userInfo = make(map[string]string) userInfo[\"userName\"] = \"zhangsan\" fmt.Println(userInfo) var array = make([]int, 4, 4) array[0] = 1 fmt.Println(array) 对于指针变量来说 // 指针变量初始化 var a *int *a = 100 fmt.Println(a) 执行上面的代码会引发panic，为什么呢？在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。Go 语言中new和make是内建的两个函数，主要用来分配内存。 这个时候，我们就需要使用new关键字来分配内存，new是一个内置的函数，它的函数签名如下： func new(Type) *Type 其中 Type表示类型，new函数只接受一个参数，这个参数是一个类型 *Type表示类型指针，new函数返回一个指向该类型内存地址的指针 实际开发中new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子： // 使用new关键字创建指针 aPoint := new(int) bPoint := new(bool) fmt.Printf(\"%T \\n\", aPoint) fmt.Printf(\"%T \\n\", bPoint) fmt.Println(*aPoint) fmt.Println(*bPoint) 类似var a *int 只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174541/:1:4","tags":null,"title":"3-1. go指针","uri":"/lang/go/go_base/20250515174541/"},{"categories":null,"content":"\r1.5 make和new的区别 两者都是用来做内存分配的； make只能用于slice、map以及channel的初始化，返回的还是这三个引用类型的本身 而new用于类型的内存分配，并且内存初始的值为类型的零值，返回的是指向类型的指针 // int byte rune float bool string 这些类型都有默认零值；在变量声明的时候系统自动会分配一块内存空间； 而 point slice、map以及channel的零值是nil 系统不会默认分配空间，所以需要初始化； ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174541/:1:5","tags":null,"title":"3-1. go指针","uri":"/lang/go/go_base/20250515174541/"},{"categories":null,"content":"\r1.6 指针易混淆示例\r1.6.1 1. 函数传参指针 demo package main import \"fmt\" type T struct { Name string } func main() { var a = \u0026T{} var b = \u0026T{} fmt.Printf(\"a addr :%p,\u0026a addr :%p, a: %v\\n\", a, \u0026a, a) f1(a) fmt.Printf(\"a addr :%p, a: %v\\n\", a, a) fmt.Printf(\"b addr :%p, b: %v\\n\", b, b) f2(b) fmt.Printf(\"b addr :%p, b: %v\\n\", b, b) } func f1(t *T) { fmt.Printf(\"f1--t addr :%p, \u0026t addr :%p:\\n\", t, \u0026t) t = \u0026T{ Name: \"aaaaaaaa\", } } func f2(t *T) { fmt.Printf(\"f2--t addr :%p, \u0026t addr :%p:\\n\", t, \u0026t) *t = T{ Name: \"bbbbbbbb\", } } /* a addr :0x14000104210,\u0026a addr :0x1400011c018, a: \u0026{} f1--t addr :0x14000104210, \u0026t addr :0x1400011c028: a addr :0x14000104210, a: \u0026{} b addr :0x14000104220, b: \u0026{} f2--t addr :0x14000104220, \u0026t addr :0x1400011c030: b addr :0x14000104220, b: \u0026{bbbbbbbb} */ 最终a没有发生改变，而b发生了改变； 在f1函数中，通过将t重新赋值为指向新的T结构体的指针，你改变了t的指针目标。这种方式只在函数内部有效，不会对原始指针产生影响。这是因为函数参数是按值传递的，当你将t重新赋值时，只是修改了函数内部的一个副本，不会影响原始指针。\u0026a addr 是0x1400011c018，而f1中 \u0026t addr :0x1400011c028； 这两个对象不同；在main函数中调用f1(a)后，a的值仍然是原始的空指针，因为f1函数中的重新分配操作只影响了函数内部的t副本。 在f2函数中，通过解引用指针并修改解引用后的结构体的字段，你可以改变指针所指向的T结构体的内容。这种方式会影响原始指针，因为你直接修改了指针所指向的内存。 1.6.2 2. 函数传参数组 demo package main import \"fmt\" func main() { l1 := make([]int, 0, 10) l1 = append(l1, 0) fmt.Printf(\"%p,%p\\n\", l1, \u0026l1) f1(l1) fmt.Println(l1) l2 := make([]int, 0, 10) l2 = append(l2, 0) fmt.Printf(\"%p,%p\\n\", l2, \u0026l2) f2(\u0026l2) fmt.Println(l2) } func f1(l []int) { fmt.Printf(\"%p,%p\\n\", l, \u0026l) l = append(l, 1) } func f2(l *[]int) { fmt.Printf(\"%p,%p,%p\\n\", l, \u0026l, *l) *l = append(*l, 1) } f1 并未改变l1，是因为在函数 f() 中，切片 l 是按值传递的，而不是按引用传递的。当你将切片 l1 传递给函数 f() 时，它会创建一个新的切片 l，并将其初始化为与 l1 相同的底层数组。然后，使用 append() 函数将元素 1 添加到新切片 l 中。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174541/:1:6","tags":null,"title":"3-1. go指针","uri":"/lang/go/go_base/20250515174541/"},{"categories":null,"content":"\rGo中的指针要搞明白Go语言中的指针需要先知道三个概念 指针地址 指针类型 指针取值 Go语言中的指针操作非常简单，我们只需要记住两个符号：\u0026：取地址，*：根据地址取值 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:0","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.1 关于指针 我们知道变量是用来存储数据的，变量的本质是给存储数据的内存地址起了一个好记的别名。比如我们定义了一个变量a:=10，这个时候可以直接通过a这个变量来读取内存中保存的10这个值。在计算机底层a这个变量其实对应了一个内存地址。 指针也是一个变量，但它是一种特殊的变量，它存储的数据不是一个普通的值，而是另一个变量的内存地址。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:1","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.2 指针地址和指针类型 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。 Go 语言中使用\u0026字符放在变量前面对变量进行取地址操作。Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如： *int、，*int64、*string等 取变量指针的语法如下： ptr := \u0026v 其中： v：代表被取地址的变量，类型为T ptr：用于接收地址的变量，ptr的类型就为*T，被称做T的指针类型。* 代表指针 举个例子： package main func main() { var a = 10 var b = \u0026a println(\u0026a) //0xc00003df60 println(\u0026b) //0xc00003df68 println(b) //0xc00003df60 println(*(\u0026b)) //0xc00003df60 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:2","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.3 指针取值在对普通变量进行\u0026操作符取地址后，会获得这个变量指针，然后可以对指针使用*操作，也就是指针取值 // 指针取值 var c = 20 // 得到c的地址，赋值给d var d = \u0026c // 打印d的值，也就是c的地址 fmt.Println(d) // 取出d指针所对应的值 fmt.Println(*d) // c对应地址的值，改成30 *d = 30 // c已经变成30了 fmt.Println(c) 改变内存中的值，会直接改变原来的变量值 // 这个类似于值传递 func fn4(x int) { x = 10 } // 这个类似于引用数据类型 func fn5(x *int) { *x = 20 } func main() { x := 5 fn4(x) fmt.Println(x) fn5(\u0026x) fmt.Println(x) } 我们创建了两个方法，一个是传入局部变量，一个是传入指针类型，最后运行得到的结果 5 20 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:3","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.4 new和make函数需要注意的是，指针必须在创建内存后才可以使用，这个和 slice 和 map是一样的 // 引用数据类型map、slice等，必须使用make分配空间，才能够使用 var userInfo = make(map[string]string) userInfo[\"userName\"] = \"zhangsan\" fmt.Println(userInfo) var array = make([]int, 4, 4) array[0] = 1 fmt.Println(array) 对于指针变量来说 // 指针变量初始化 var a *int *a = 100 fmt.Println(a) 执行上面的代码会引发panic，为什么呢？在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。Go 语言中new和make是内建的两个函数，主要用来分配内存。 这个时候，我们就需要使用new关键字来分配内存，new是一个内置的函数，它的函数签名如下： func new(Type) *Type 其中 Type表示类型，new函数只接受一个参数，这个参数是一个类型 *Type表示类型指针，new函数返回一个指向该类型内存地址的指针 实际开发中new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子： // 使用new关键字创建指针 aPoint := new(int) bPoint := new(bool) fmt.Printf(\"%T \\n\", aPoint) fmt.Printf(\"%T \\n\", bPoint) fmt.Println(*aPoint) fmt.Println(*bPoint) 本节开始的示例代码中 var a *int 只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:4","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.5 make和new的区别 两者都是用来做内存分配的 make只能用于slice、map以及channel的初始化，返回的还是这三个引用类型的本身 而new用于类型的内存分配，并且内存赌赢的值为类型的零值，返回的是指向类型的指针 函数 函数是基本的代码块，Go 语言最少有个 main() 函数。 函数如果使用参数，该变量可称为函数的形参。 形参就像定义在函数体内的局部变量。 调用函数，可以通过两种方式来传递参数： 传递类型 描述 值传递 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 引用传递 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:5","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.6 匿名函数 函数也是一种类型, 可以定义一个函数类型的变量 匿名函数就是一个没有名字的函数 f1 := func(a,b int) { fmt.Println(a+b) } f1(1,2) ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:6","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.7 值传递 传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。 package main import \"fmt\" func main() { /* 定义局部变量 */ var a int = 100 var b int = 200 fmt.Printf(\"交换前 a 的值为 : %d\\n\", a ) fmt.Printf(\"交换前 b 的值为 : %d\\n\", b ) /* 通过调用函数来交换值 */ swap(a, b) fmt.Printf(\"交换后 a 的值 : %d\\n\", a ) fmt.Printf(\"交换后 b 的值 : %d\\n\", b ) } /* 定义相互交换值的函数 */ func swap(x, y int) int { var temp int temp = x /* 保存 x 的值 */ x = y /* 将 y 值赋给 x */ y = temp /* 将 temp 值赋给 y*/ return temp; } /** 输出 交换前 a 的值为 : 100 交换前 b 的值为 : 200 交换后 a 的值 : 100 交换后 b 的值 : 200 */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:7","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.8 引用传递 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 package main import \"fmt\" func main() { /* 定义局部变量 */ var a int = 100 var b int= 200 fmt.Printf(\"交换前，a 的值 : %d\\n\", a ) fmt.Printf(\"交换前，b 的值 : %d\\n\", b ) /* 调用 swap() 函数 * \u0026a 指向 a 指针，a 变量的地址 * \u0026b 指向 b 指针，b 变量的地址 */ swap(\u0026a, \u0026b) fmt.Printf(\"交换后，a 的值 : %d\\n\", a ) fmt.Printf(\"交换后，b 的值 : %d\\n\", b ) } func swap(x *int, y *int) { var temp int temp = *x /* 保存 x 地址上的值 */ *x = *y /* 将 y 值赋给 x */ *y = temp /* 将 temp 值赋给 y */ } /** 交换前，a 的值 : 100 交换前，b 的值 : 200 交换后，a 的值 : 200 交换后，b 的值 : 100 */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:8","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.9 变量作用域 局部变量:在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 全局变量:在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。 可通过花括号来控制变量的作用域，花括号中的变量是单独的作用域，同名变量会覆盖外层。 a := 5 { a := 3 fmt.Println(\"in a = \", a) } fmt.Println(\"out a = \", a) /** in a = 3 out a = 5 */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:9","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.10 defer关键字 defer 定义的语句不会立即执行, 会在函数return之前执行 一般用作资源释放 多个defer 语句会以栈的规则执行, 先进后出 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:10","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.11 内置函数 close:主要用来关闭 channel len:用来求长度,比如 string、 array、 slice、map、 channe cap: 获取容器的容量大小 new:用来分配内存,主要用来分配值类型,比如iηt、 struct。返回的是指针 make:用来分配内存,主要用来分配引用类型,比如chan、map、 slice append:用来追加元素到数组、slice中 copy: 将一个slice拷贝到另一个slice中 delete: 删除map中的键值对 panic和 recover:用来做错误处理 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:11","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.12 闭包函数 闭包函数的两个必要条件: 1.嵌套函数 2. 外部引用 闭包函数的机制类似于面向对象的实例; 每一个实例对象内部的变量在实例生命周期内一直存在,只有重新创建实例时,内部变量才会被重置 package main import \"fmt\" func getSequence() func() int { i:=0 return func() int { i+=1 return i } } func main(){ /* nextNumber 为一个函数，函数 i 为 0 */ nextNumber := getSequence() /* 调用 nextNumber 函数，i 变量自增 1 并返回 */ fmt.Println(nextNumber()) fmt.Println(nextNumber()) fmt.Println(nextNumber()) /* 创建新的函数 nextNumber1，并查看结果 */ nextNumber1 := getSequence() fmt.Println(nextNumber1()) fmt.Println(nextNumber1()) } /** 1 2 3 1 2 */ 数组 数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。 声明数组的时候必须声明长度或者用[…], 不然就是切片. 初始化数组: var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度： balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 如果设置了数组的长度，我们还可以通过指定下标来初始化元素： // 将索引为 1 和 3 的元素初始化 balance := [5]float32{1:2.0,3:7.0} 切片(slice) Go 语言切片是对数组的抽象。也可以被看做为\"动态数组\",数组的长度不可改变,切片长度可变 在做函数调用时，slice 按引用传递，array 按值传递： 切片是对数组的引用,切片本身并不包含任何元素 切片的结构包括三个部分: 地址: 切片的地址一般指切片中的第一个元素所指向的内存地址, 用十六进制表示; 长度: 切片实际存在元素的个数; 容量: 从切片的起始元素开始到其底层数组中最后一个元素的个数; 切片的长度和容量都不是固定的,追加元素会使切片的长度和容量都增大 切片如果是从其他数组或者切片中来的话, 切片容量增加但是所引用数组容量不变 切片如果是从其他数组或者切片中来的话, 当切片长度大于多引用的数组容量时; 切片容量会以 切片新容量=2*切片当前容量 的速度扩容 切片如果是从其他数组或者切片中来的话, 当前片长量大于所引用数组的容量时, 切片中的第一个元素所指向的内存地址会发生改变; 定义切片 声明一个未指定大小的数组来定义切片(切片不需要说明长度)： var identifier []type 使用 make() 函数来创建切片: var slice1 []type = make([]type, len) 也可以简写为 slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 make([]T, length, capacity) //这里 len 是数组的长度并且也是切片的初始长度。 特殊 a := []int{2: 1} // 声明切片索引为2的写入1 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:12","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.13 切片函数 len() 获取长度 cap() 获取切片容量,即最大长度 append() 往切片尾部添加一个元素 copy() 拷贝 numbers 的内容到 numbers1 /* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) 合并多个数组： package main import \"fmt\" func main() { var arr1 = []int{1,2,3} var arr2 = []int{4,5,6} var arr3 = []int{7,8,9} var s1 = append(append(arr1, arr2...), arr3...) fmt.Printf(\"s1: %v\\n\", s1) } // s1: [1 2 3 4 5 6 7 8 9] 从切片中删除元素 package main import \"fmt\" func main() { sli1:=[]int{1,2,3} c:=append(sli1[0:1],sli1[2:]...) fmt.Println(c) } // [1 3] 映射(map) Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。 Map 是无序的，这是因为 Map 是使用 hash 表来实现的。 类似python中的字典dict, 可以使用内建函数 make 也可以使用 map 关键字来定义 Map: /* 声明变量，默认 map 是 nil */ var map_variable map[key_data_type]value_data_type /* 使用 make 函数 */ map_variable := make(map[key_data_type]value_data_type) 如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对 map 取值 通过[]v,ok:= someMap[\"key\"] ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:13","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.14 删除键值对 delete(map,key) 删除键值对 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:14","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.15 sync.Mapmap不是携程安全的,在同一时刻只能由一个携程操作map; 并发操作map时要加锁; 因为加锁会消耗性能, 所以推荐使用go1.9中的sync.Map sync.Map的特点 内部通过冗余的数据结构降低加锁对性能的影响; 使用前无需初始化, 直接声明即可 sync.Map不使用map中的方式进行读取和赋值等操作 package main import ( \"fmt\" \"sync\" ) func main() { var GoMap sync.Map for i := 0; i \u003c 10000; i++ { fmt.Println(i, \"\\n\") go writeMap(GoMap, i, i) go readMap(GoMap, i) } } func readMap(goMap sync.Map, key int) int { res, ok := goMap.Load(key) //线程安全提取 if ok == true { fmt.Println(1) return res.(int) } else { return 0 } } func writeMap(goMap sync.Map, key int, value int) { goMap.Store(key, value) } Sync.Map 不能使用make()方法创建 Load() 方法的第一个返回值是一个接口类型,需要将其转换为map值得类型 syny.mao为了保证安全还是会有性能损耗,单线程推荐使用map range range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。 range表达式 第一分返回值 第二返回值 数组 index value 切片 index value 映射 key value 通道 value N/A 结构体 Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型; lgo语言没有class类，只是个结构体struct; 结构体传参以值方式传递; 结构体注意要点: 同一个包内结构体名称不能重复 同一个结构体内成员名不能重复 同类型的成员可以写在同一行 结构体|方法名|变量名的首字母大写时可以在当前包外使用 结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下： type struct_variable_type struct { member definition member definition ... member definition } 一旦定义了结构体类型，它就能用于变量的声明，语法格式如下： variable_name := structure_variable_type {value1, value2...valuen} 或 variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen} ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:15","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.16 结构体指针 你可以定义指向结构体的指针类似于其他指针变量，格式如下： var struct_pointer *Books 以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 \u0026 符号放置于结构体变量前： struct_pointer = \u0026Book1 使用结构体指针访问结构体成员，使用 “.” 操作符： struct_pointer.title ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:16","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.17 实例化结构体 实例化的方式: 标准实例化 new()函数实例化 取地址实例化 package main import \"fmt\" type Boy struct{ name string age int } func main() { // 标准实例化 var boy Boy boy.name=\"Evan\" fmt.Println(boy.name) //Evan //new() 函数实例化 newBoy := new(Boy) newBoy.age = 1 fmt.Println(newBoy) //取地址实例化 addrBoy := \u0026Boy{} addrBoy.name = \"Evan\" fmt.Println(addrBoy) //\u0026{Evan 0} fmt.Println(addrBoy.name) //Evan } 取值方式: 无论哪种取值方式都可以通过.的方式取值 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:17","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.18 初始化结构体 初始化方式初始化成员最后一定要有逗号 键值对初始化 类似map 列表初始化 必须按顺序初始化结构体中的全部成员 与键值对初始化方法不能混用 package main import \"fmt\" type Boy struct{ name string age int } func main() { // 初始化实例 boy :=Boy{ name: \"evan\", } boy2 :=Boy{ \"bigox\", 18, } fmt.Println(boy) fmt.Println(boy2) } /** {evan 0} {bigox 18} */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:18","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.19 结构体方法 方法: 包含了接收者的函数 结构体方法: 接收者可以使结构体类型的值后者指针 package main import \"fmt\" type Boy struct{ name string age int } // 指针类型接收 func (boy *Boy) changeName(){ boy.name = \"bigox\" } // 值类型接收 func (boy Boy) changeAge(){ boy.age = 18 } func main() { // 初始化实例 boy :=Boy{ \"evan\",17, } fmt.Println(boy) boy.changeName() fmt.Println(boy) boy.changeAge() fmt.Println(boy) } /** {evan 17} {bigox 17} {bigox 17} */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:19","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.20 结构体内嵌 结构体内嵌可以构建面向对象编程思想中的继承关系, 结构体实例化之后可以直接访问内嵌结构体中的所有成员变量和方法 package main import \"fmt\" type Book struct { title string author string num int id int } type BookBorrow struct { Book borrowTime string } type BookNotBorrow struct { Book readTime string } func main() { bookBorrow := \u0026BookBorrow{ } bookNotBorrow := \u0026BookNotBorrow{ } fmt.Println(bookBorrow) fmt.Println(bookNotBorrow) } 内嵌结构体实例化 package main import \"fmt\" type Book struct { title string author string num int id int } type BookBorrow struct { Book borrowTime string } type BookNotBorrow struct { Book readTime string } func main() { bookBorrow := \u0026BookBorrow{ Book:Book{ title :\"go\", author :\"Tom\", num :1, id :110, }, } fmt.Println(bookBorrow) bookBorrow.author = \"Jerry\" fmt.Println(bookBorrow) } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:20","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.21 匿名结构体 没有名字的结构体 无需使用type关键字, 但是创建匿名结构体的时候也要创建对象 book := struct { title string id int }{ \"go\", 110, } fmt.Println(book) 匿名函数一般可用于组织全局变量| 构建数据模板|和解析JSON使用; 经常使用匿名结构体来临时存储经过解析后的JSON数据; ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:21","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r0.22 结构体匿名字段 创建结构体时, 字敦可以只有类型, 而没有字段名, 这样的字段成为匿名字段; type Person struct { Name string Age int `json:\"age\"` string // 匿名字段 } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174536/:0:22","tags":null,"title":"3-0. 函数\u0026复合类型","uri":"/lang/go/go_base/20250515174536/"},{"categories":null,"content":"\r1 位-字节-字符-编码 1、位：数据存储的最小单位。每个二进制数字0或者1就是1个位； 2、字节：8个位构成一个字节；即：1 byte (字节)= 8 bit(位)； 1 KB = 1024 B(字节)； 1 MB = 1024 KB; (2^10 B) 1 GB = 1024 MB; (2^20 B) 1 TB = 1024 GB; (2^30 B) 3、字符：a、A、中、+、*、の......均表示一个字符 ； unioncode 一个汉字4个字节表示 一般 utf-8 编码下，一个汉字 字符 占用 3 个 字节； 一般 gbk 编码下，一个汉字 字符 占用 2 个 字节； ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:1:0","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r2 assic码 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 \" 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 \u0026 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 \u003c 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 \u003e 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:2:0","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r3 命名 go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则 一个名字必须以一个字母或下划线开头，后面可以跟任意数量的字母、数字或下划线 go语言中有25个关键字，不能用于自定义名字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 还有30多个预定义的名字，用于内建的常量、类型和函数 //内建常量: true false iota nil //内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error //内建函数: make len cap new append copy close delete complex real imag panic recover ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:3:0","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r4 变量 package main import \"fmt\" func main() { var a int var b , c string var (/* */ d int e string f bool ) fmt.Println(a,b,c,d,e,f) // 0 0 false } 第一种，指定变量类型，如果没有初始化，则变量默认为零值。 零值就是变量没有做初始化时系统默认设置的值。 数值类型（包括complex64/128）为 0 布尔类型为 false 字符串为 \"\"（空字符串） 以下几种类型为 nil： var a *int var a []int var a map[string] int var a chan int var a func(string) int var a error // error 是接口 第二种，根据值自行判定变量类型。 package main import \"fmt\" func main() { var d = true fmt.Println(d) } 第三种，省略 var, 注意 := 左侧如果没有声明新的变量，就产生编译错误，格式： v_name := value //可以将 var f string = \"Runoob\" 简写为 f := \"Runoob\"： ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:4:0","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r5 常量常量的定义格式： const identifier [type] = value 在定义常量组时，如果不提供初始值，则表示将使用上行的表达式。 常量是一个简单值的标识符，在程序运行时，不会被修改的量。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:5:0","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r5.1 iota iota，特殊常量，可以认为是一个可以被编译器修改的常量, 变量中不可使用。 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。 iota 可以被用作枚举值： const ( a = iota //0 b = iota //1 c = iota //2 ) 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式： const ( a = iota b c ) iota 只是在同一个 const 常量组内递增，每当有新的 const 关键字时，iota 计数会重新开始。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:5:1","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r5.2 iota 用法 package main import \"fmt\" func main() { const ( a = iota *//0* b *//1* c *//2* d = \"ha\" *//独立值，iota += 1* e *//\"ha\" iota += 1* f = 100 *//iota +=1* g *//100 iota +=1* h = iota *//7,恢复计数* i *//8* ) fmt.Println(a,b,c,d,e,f,g,h,i) } // 0 1 2 ha ha 100 100 7 8 iota 只是在同一个 const 常量组内递增，每当有新的 const 关键字时，iota 计数会重新开始。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:5:2","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r5.3 Iota 和左右运算符 package main import \"fmt\" const ( i=1\u003c\u003ciota j=3\u003c\u003ciota k l ) func main() { fmt.Println(\"i=\",i) fmt.Println(\"j=\",j) fmt.Println(\"k=\",k) fmt.Println(\"l=\",l) } /* i= 1 j= 6 k= 12 l= 24 */ iota 表示从 0 开始自动加 1，所以 i=1«0, j=3«1（« 表示左移的意思），即：i=1, j=6，这没问题，关键在 k 和 l，从输出结果看 k=3«2，l=3«3。 简单表述: i=1：左移 0 位,不变仍为 1; j=3：左移 1 位,变为二进制 110, 即 6; k=3：左移 2 位,变为二进制 1100, 即 12; l=3：左移 3 位,变为二进制 11000,即 24。 注：«n==*(2^n)。 // 左移运算符 \u003c\u003c 是双目运算符。左移 n 位就是乘以 2 的 n 次方。 其功能把 \u003c\u003c 左边的运算数的各二进位全部左移若干位，由 \u003c\u003c 右边的数指定移动的位数，高位丢弃，低位补 0。 //右移运算符 \u003e\u003e 是双目运算符。右移 n 位就是除以 2 的 n 次方。 其功能是把 \u003e\u003e 左边的运算数的各二进位全部右移若干位， \u003e\u003e 右边的数指定移动的位数。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:5:3","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r6 数据类型Go 语言按类别有以下几种数据类型： 序号 类型和描述 1 布尔型布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 2 数字类型整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 3 **字符串类型:**字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 4 派生类型: 指针类型（Pointer） /数组类型 /结构化类型(struct) / Channel 类型 / 函数类型 /切片类型 /接口类型（interface） /Map 类型 字符串格式化 %v是万能的 %T查看数据类型,类似reflect.typeOf() ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:6:0","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r6.1 字符串类型 a := \"hello\" unsafe.Sizeof(a) /* 输出结果为：16 字符串类型在 go 里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节。 */ 关键字string,用\"“或者``反引号表示(’““支持控制符号,反引号所有的都会原样输出) 占位符 ‘%s 万能占位符’%v’ 6.1.1 字符串常用操作 长度 **len(str) ** ,返回一个int, 返回的是字节的长度, 中文的字节长3 拼接: 使用**+或者fmt.Sprintf()** 分割: strings.Split(str,‘分割标识’), 返回一个切片 是否存在: 函数|返回值 作用 strconv 包： Atoi(s string) (int, error) 字符串转整型 strings 包： Count(s, substr string) int 计算子串substr在字符串s中出现的次数 Compare(a, b string) int 比较字符串大小 Contains(s, substr string) bool 判断字符串s中是否包含子串substr ContainsAny(s, chars string) bool 判断字符串s中是否包含chars中的某个Unicode字符 ContainsRune(s string, r rune) bool 判断字符串s中是否包含rune型值为r的字符 Index(s, substr string) int 查找子串substr在字符串s中第一次出现的位置，如果找不到则返回 -1，如果substr为空，则返回 0 LastIndex(s, substr string) int 查找子串substr在字符串s中最后出现的位置 IndexRune(s string, r rune) int 查找rune型值为r的字符在字符串s中出现的起始位置 IndexAny(s, chars string) int 查找字符串chars中字符，在字符串s中出现的起始位置 LastIndexAny(s, chars string) int 查找字符串s中出现chars中字符的最后位置 LastIndexByte(s string, c byte) int 查找byte型字符c在字符串s中的位置 SplitN(s, sep string, n int) []string 以字符串sep为分隔符，将字符串s切分成n个子串，结果中不包含sep本身。如果sep为空则将s切分为 Unicode 字符列表，如果s中没有sep子串则整个s作为切片 []string 中的第一个元素返回。参数n表示最多切出几个子串，s超出切分大小时，超出部分不再切分。n超出切分子串个数时，返回实际切分子串数。如果n为 0，则返回 nil；如果n小于 0，则不限制切分个数，全部切分 SplitAfterN(s, sep string, n int) []string 以字符串sep为分隔符，将字符串s切分成n个子串，结果中包含sep本身。如果sep为空则将s切分为 Unicode 字符列表，如果s中没有sep子串则整个s作为切片 []string 中的第一个元素返回。参数n表示最多切出几个子串，s超出切分大小时，超出部分不再切分。n超出切分子串个数时，返回实际切分子串数。如果n为 0，则返回 nil；如果n小于 0，则不限制切分个数，全部切分 Split(s, sep string) []string 以字符串sep为分隔符，将s切分成多个子串，结果中不包含sep本身。如果sep为空，则将s切分成 Unicode 字符列表，如果s中没有sep子串，则将整个s作为 []string 的第一个元素返回 SplitAfter(s, sep string) []string 以字符串sep为分隔符，将s切分成多个子串，结果中包含sep本身。如果sep为空则将s切分为 Unicode 字符列表，如果s中没有sep子串则整个s作为切片 []string 中的第一个元素返回。 Fields(s string) []string 以连续的空白字符为分隔符，将s切分成多个子串，结果中不包含空白字符本身。空白字符有：\\t, \\n, \\v, \\f, \\r, ‘’, U+0085 (NEL), U+00A0 (NBSP) 。如果s中只包含空白字符，则返回一个空切片 FieldsFunc(s string, f func(rune) bool) []string 以一个或多个满足函数f(rune)的字符为分隔符，将s切分成多个子串，结果中不包含分隔符本身。如果s中没有满足f(rune)的字符，则返回一个空切片 Join(a []string, sep string) string 以sep为拼接符，拼接切片a中的字符串 HasPrefix(s, prefix string) bool 判断字符串s是否以prefix字符串开头，是返回 true，否则返回 false HasSuffix(s, suffix string) bool 判断字符串s是否以suffix字符串结尾，是返回 true，否则返回 false Map(f func(rune) rune, s string) string 将字符串s中满足函数f(rune)的字符替换为f(rune)的返回值。如果f(rune)返回负数，则相应的字符将被删除 Repeat(s string, count int) string 返回字符串s重复count次数后的结果 ToUpper(s string) string 将字符串s中的小写字符转为大写 ToLower(s string) string 将字符串s中的大写字符转为小写 ToTitle(s string) string 将字符串s中的首个单词转为Title形式，大部分字符的Title格式就是Upper格式 ToUpperSpecial(c unicode.SpecialCase, s string) string 将字符串s中的所有字符修改为其大写格式，优先使用c中的规则进行转换 ToLowerSpecial(c unicode.SpecialCase, s string) string 将字符串s中的所有字符修改为其小写格式，优先使用c中的规则进行转换 ToTitleSpecial(c unicode.SpecialCase, s string) string 将字符串s中的所有字符修改为其Title格式，优先使用c中的规则进行转换 Title(s string) string 将字符串s中的所有单词的首字母修改为其Title格式（BUG: Title 规则不能正确处理 Unicode 标点符号） TrimLeftFunc(s string, f func(rune) bool) string 删除字符串s左边连续满足f(rune)的字符 TrimRightFunc(s string, f func(rune) bool) string 删除字符串s右边连续满足f(rune)的字符 TrimFunc(s string, f func(rune) bool) string 删除字符串s左右两边连续满足f(rune)的字符 IndexFunc(s string, f func(rune) bool) int 查找字符串s中第一个满足f(rune)的字符的字节位置，没有返回 -1 LastIndexFunc(s string, f func(rune) bool) int 查找字符串s中最后一个满足f(rune)的字符的字节位置，没有返回 -1 Trim(s string, cutset string) string 删除字符串s左右两边连续包含cutset的字符 TrimLeft(s string, cutset string) string 删除字符串s左边连续包含cutset的字符 TrimRight(s string, cutset string) string 删除字符串s右边连续包含cutset的字符 TrimSpace(s string) string 删除字符串s左右两边连续的空白字符 TrimPrefix(s, prefix string) string 删除字符串s 头部的prefix字符串 TrimSuffix(s, suffix string) string 删除字符串s 尾部的suffix字符串 Replace(s, old, new string, n int) string 替换字符串s中的old为new，如果old为空则在s中的每个字符间插入new包括首尾，n为替换次数， -1 时替换所有 EqualFold(s, t string) bool 忽略大小写比较字符串s和t，相同返回 true，反之返回 false 1. 字符串转数字 strconv.Atoi： package main import ( \"fmt\" \"strconv\" ) func main() { var str = \"111\" i, _ := strconv.Atoi(str) fmt.Printf(\"%d\\n\", i) // 输出：111 } 2. 大小写规则转换 strings.ToUpperSpecial：将字符串s中的所有字符修改为其大写格式，优先使用c中的规则进行转换 strings.ToLowerSp","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:6:1","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r6.2 字符串原理 单引号是字符,双引号是字符串 字符串的底层就是一个byte数组,所以可以和 []byte 类型互相转换 字符串是由byte字节组成的,所以字符串的长度是byte字节的长度 rune类型用来表示utf8字符,一个rune字符由1个或多个byte组成 对包含中文的字符串排序 package main import ( \"fmt\" ) func main() { str := \"ABCDEFGH你好\" strRune := []rune(str) for i:=0 ; i\u003clen(strRune)/2;i++{ item := strRune[i] strRune[i] = strRune[len(strRune)-1-i] strRune[len(strRune)-1-i] = item } fmt.Println(len(str)) // 14 fmt.Println(strRune) // [22909 20320 72 71 70 69 68 67 66 65] fmt.Println(string(strRune)) //好你HGFEDCBA } 扩展 //1、位： 数据存储的最小单位。每个二进制数字0或者1就是1个位； //2、字节： 8个位构成一个字节；即：1 byte (字节)= 8 bit(位)； 1 KB = 1024 B(字节)； 1 MB = 1024 KB; (2^10 B) 1 GB = 1024 MB; (2^20 B) 1 TB = 1024 GB; (2^30 B) //3、字符： a、A、中、+、*、の......均表示一个字符； unicode,万国码,32位既4个字节表示一个字符; 一般 utf-8 编码下，一个汉字 字符 占用 3 个 字节； 一般 gbk 编码下，一个汉字 字符 占用 2 个 字节； //4、字节和字符： 字节是计算机传输数据的格式，供计算识别的。 字符是供人类观看的内容 //5、编码： 编码（encoding）:把…译成密码。==》二进制 解码（decoding）：破译(尤指密码) ==》破解密码成可以看的懂的 //6.编码格式： 字节和字符之间转换，参照的规则就是编码格式。 Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节。 Unicode码的前128个字符就是ASCII码，之后是ASCII码的扩展码。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:6:2","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r6.3 数字类型 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 所有整数初始化为0,所有浮点数初始化为0.0,布尔类型初始化为 false 序号 类型和描述 1 uint8无符号 8 位整型 (0 到 255) 2 uint16无符号 16 位整型 (0 到 65535) 3 uint32无符号 32 位整型 (0 到 4294967295) 4 uint64无符号 64 位整型 (0 到 18446744073709551615) 5 int8有符号 8 位整型 (-128 到 127) 6 int16有符号 16 位整型 (-32768 到 32767) 7 int32有符号 32 位整型 (-2147483648 到 2147483647) 8 int64有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 6.3.1 浮点型 序号 类型和描述 1 float32IEEE-754 32位浮点型数 2 float64IEEE-754 64位浮点型数 3 complex6432 位实数和虚数 4 complex12864 位实数和虚数 6.3.2 其他数字类型以下列出了其他更多的数字类型： 序号 类型和描述 1 byte类似 uint8 2 rune类似 int32 3 uint32 或 64 位 4 int与 uint 一样大小 5 uintptr无符号整型，用于存放一个指针 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:6:3","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r7 时间和日期time 包 时间 now := time.Now() fmt.Println(now) // 分别获取年月日等 year := now.Year() month := now.Month() day := now.Day() hour := now.Hour() minute := now.Minute() send := now.Second() // 时间格式化 timer := time.Now() res := timer.Format(“2006-01-02 15:04:05”) - `%02d 不足两位的数字在前面补0` - 时间戳 ```go // 获取时间戳 timeStamp := time.Now().Unix() fmt.Println(timeStamp) // 时间戳转时间 nowObj := time.Unix(timeStamp,0) year =nowObj.Year() month =nowObj.Month() day =nowObj.Day() fmt.Printf(\"%02d-%02d-%02d \",year,month,day) // %02d 不足两位的数字在前面补0 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:7:0","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r8 运算符Go 语言内置的运算符有： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:8:0","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r8.1 算术运算符下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 + 相加 A + B 输出结果 30 - 相减 A - B 输出结果 -10 * 相乘 A * B 输出结果 200 / 相除 B / A 输出结果 2 % 求余 B % A 输出结果 0 ++ 自增 A++ 输出结果 11 – 自减 A– 输出结果 9 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:8:1","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r8.2 关系运算符下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 == 检查两个值是否相等，如果相等返回 True 否则返回 False。 (A == B) 为 False != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 (A != B) 为 True \u003e 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 (A \u003e B) 为 False \u003c 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 (A \u003c B) 为 True \u003e= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 (A \u003e= B) 为 False \u003c= 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 (A \u003c= B) 为 True ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:8:2","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r8.3 逻辑运算符下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。 运算符 描述 实例 \u0026\u0026 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 (A \u0026\u0026 B) 为 False || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 (A || B) 为 True ! 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 !(A \u0026\u0026 B) 为 True ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:8:3","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r8.4 位运算符位运算符对整数在内存中的二进制位进行操作。 下表列出了位运算符 \u0026, |, 和 ^ 的计算： p q p \u0026 q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假定 A = 60; B = 13; 其二进制数转换为： A = 0011 1100 B = 0000 1101 ----------------- A\u0026B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13： 运算符 描述 实例 \u0026 按位与运算符”\u0026“是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 (A \u0026 B) 结果为 12, 二进制为 0000 1100 | 按位或运算符”|“是双目运算符。 其功能是参与运算的两数各对应的二进位相或 (A | B) 结果为 61, 二进制为 0011 1101 ^ 按位异或运算符”^“是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 (A ^ B) 结果为 49, 二进制为 0011 0001 « 左移运算符”«“是双目运算符。左移n位就是乘以2的n次方。 其功能把”«“左边的运算数的各二进位全部左移若干位，由”«“右边的数指定移动的位数，高位丢弃，低位补0。 A « 2 结果为 240 ，二进制为 1111 0000 » 右移运算符”»“是双目运算符。右移n位就是除以2的n次方。 其功能是把”»“左边的运算数的各二进位全部右移若干位，\"»“右边的数指定移动的位数。 A » 2 结果为 15 ，二进制为 0000 1111 以下实例演示了位运算符的用法： package main import \"fmt\" func main() { var a uint = 60 /* 60 = 0011 1100 */ var b uint = 13 /* 13 = 0000 1101 */ var c uint = 0 c = a \u0026 b */\\* 12 = 0000 1100 \\*/* fmt.Printf(\"第一行 - c 的值为 %d**\\n**\", c ) c = a | b */\\* 61 = 0011 1101 \\*/* fmt.Printf(\"第二行 - c 的值为 %d**\\n**\", c ) c = a ^ b */\\* 49 = 0011 0001 \\*/* fmt.Printf(\"第三行 - c 的值为 %d**\\n**\", c ) c = a \u003c\u003c 2 */\\* 240 = 1111 0000 \\*/* fmt.Printf(\"第四行 - c 的值为 %d**\\n**\", c ) c = a \u003e\u003e 2 */\\* 15 = 0000 1111 \\*/* fmt.Printf(\"第五行 - c 的值为 %d**\\n**\", c ) } /* 第一行 - c 的值为 12 第二行 - c 的值为 61 第三行 - c 的值为 49 第四行 - c 的值为 240 第五行 - c 的值为 15 */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:8:4","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r8.5 赋值运算符下表列出了所有Go语言的赋值运算符。 运算符 描述 实例 = 简单的赋值运算符，将一个表达式的值赋给一个左值 C = A + B 将 A + B 表达式结果赋值给 C += 相加后再赋值 C += A 等于 C = C + A -= 相减后再赋值 C -= A 等于 C = C - A *= 相乘后再赋值 C *= A 等于 C = C * A /= 相除后再赋值 C /= A 等于 C = C / A %= 求余后再赋值 C %= A 等于 C = C % A «= 左移后赋值 C «= 2 等于 C = C « 2 »= 右移后赋值 C »= 2 等于 C = C » 2 \u0026= 按位与后赋值 C \u0026= 2 等于 C = C \u0026 2 ^= 按位异或后赋值 C ^= 2 等于 C = C ^ 2 |= 按位或后赋值 C |= 2 等于 C = C | 2 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:8:5","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r8.6 其他运算符下表列出了Go语言的其他运算符。 运算符 描述 实例 \u0026 返回变量存储地址 \u0026a; 将给出变量的实际地址。 * 指针变量。 *a; 是一个指针变量 package main import \"fmt\" func main() { var a int = 4 var b int32 var c float32 var ptr *int /* 运算符实例 */ fmt.Printf(\"第 1 行 - a 变量类型为 = %T\\n\", a ); fmt.Printf(\"第 2 行 - b 变量类型为 = %T\\n\", b ); fmt.Printf(\"第 3 行 - c 变量类型为 = %T\\n\", c ); /* \u0026 和 * 运算符实例 */ ptr = \u0026a /* 'ptr' 包含了 'a' 变量的地址 */ fmt.Printf(\"a 的值为 %d\\n\", a); fmt.Printf(\"*ptr 为 %d\\n\", *ptr); } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:8:6","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r8.7 运算符优先级有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 优先级 运算符 5 * / % « » \u0026 \u0026^ 4 + - | ^ 3 == != \u003c \u003c= \u003e \u003e= 2 \u0026\u0026 1 || ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:8:7","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r9 Golang代码执行步骤 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174529/:9:0","tags":null,"title":"2-5. 基础语法","uri":"/lang/go/go_base/20250515174529/"},{"categories":null,"content":"\r一. 数据互相转换 int 转string string := strconv.Itoa(int) string到int int,err := strconv.Atoi(string) string到int64 int64, err := strconv.ParseInt(string, 10, 64) int64到string string := strconv.FormatInt(int64,10) map 到json字符串 m := map[string]string{} mjson,_ :=json.Marshal(m) mString :=string(mjson) json到struct 如果是单层可以直接用interface转为map jsonStr = `{}` var jsonStruct interface{} JSON.Unmarshal([]byte(jsonStr), \u0026jsonStruct) 有嵌套，把需要解析的字段一一列出，这里注意要首字母大写，否则无法解析。 type MyStruct struct{ Name string `json:\"name\"` } jsonStr = `{name: 12}` var jsonStruct MyStruct{} JSON.Unmarshal([]byte(jsonStr), \u0026jsonStruct) 纯字符串拼接 a := \"hello\" b := \"world\" // 使用操作符 result := a + b // 使用Sprintf result := fmt.Sprintf(\"s%s%\", a, b) // 使用join result := strings.Join([]string{a, b}, \"\") // 使用buffer var buffer bytes.Buffer buffer.WriteString(a) buffer.WriteString(b) result := buffer.String() // 以上四种方式性能最好是buffer，实际开发中自行调节即可 /* BenchmarkAddStringWithJoin-8 20785686 51.5 ns/op BenchmarkAddStringWithBuffer-8 1000000000 0.000123 ns/op BenchmarkAddStringWithSprintf-8 5727165 196 ns/op BenchmarkAddStringWithOperator-8 39417948 29.1 ns/op */ package main import ( \"fmt\" \"strconv\" ) func IntToString() { //todo :int to string v := 456 vS := strconv.Itoa(v) fmt.Println(vS) //方法1，简便版 //todo :int64 to string var vI64 int64 = 789 vInt64S := strconv.FormatInt(vI64, 10) //方法2，int64转string，可指定几进制 fmt.Println(vInt64S) //todo :uint64 to string var vUI64 uint64 = 91011 vUI64S := strconv.FormatUint(vUI64, 10) //方法3， uint64转string，可指定几进制 fmt.Println(vUI64S) } func StringToInt() { //todo :string to int/int64 s := \"123\" vInt, _ := strconv.Atoi(s) //方法1，便捷版 fmt.Println(vInt) vInt64, _ := strconv.ParseInt(s, 10, 64) //方案2，有符号整型，可以指定几进制，整数长度 fmt.Println(vInt64) vUInt64, _ := strconv.ParseUint(s, 10, 64) //方案3，无符号整型，可以指定几进制，整数长度 fmt.Println(vUInt64) } func StringToFloat() { //todo :string to float f64, _ := strconv.ParseFloat(\"123.456\", 64) //方法1，可以指定长度 fmt.Println(f64) } func FloatToString() { //todo :float to string f64 := 1223.13252 sF64 := strconv.FormatFloat(f64, 'f', 5, 64) //方法1，可以指定输出格式、精度、长度 fmt.Println(sF64) } func StringToBool() { //todo :string to bool 接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False 等字符串； 其他形式的字符串会返回错误 b, _ := strconv.ParseBool(\"1\") fmt.Println(b) } func BoolToString() { //todo :bool to string sBool := strconv.FormatBool(true) //方法1 fmt.Println(sBool) } func main() { StringToInt() IntToString() StringToFloat() FloatToString() BoolToString() StringToBool() } 二. fmt占位符 占位符 说明 举例 输出 %v 相应值的默认格式。 Printf(\"%v\", people) {zhangsan} %+v 打印结构体时，会添加字段名 Printf(\"%+v\", people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(\"#v\", people) main.Human{Name:“zhangsan”} %T 相应值的类型的Go语法表示 Printf(\"%T\", people) main.Human %% 字面上的百分号，并非值的占位符 Printf(\"%%\") % %t true 或 false。 Printf(\"%t\", true) true %b 二进制表示 Printf(\"%b\", 5) 101 %c 相应Unicode码点所表示的字符 Printf(\"%c\", 0x4E2D) 中 %d 十进制表示 Printf(\"%d\", 0x12) 18 %o 八进制表示 Printf(\"%d\", 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(\"%q\", 0x4E2D) ‘中’ %x 十六进制表示，字母形式为小写 a-f Printf(\"%x\", 13) d %X 十六进制表示，字母形式为大写 A-F Printf(\"%x\", 13) D %U Unicode格式：U+1234，等同于 “U+%04X” Printf(\"%U\", 0x4E2D) U+4E2D %b 无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat 的 ‘b’ 转换格式一致。 %e 科学计数法，例如 -1234.456e+78 Printf(\"%e\", 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(\"%e\", 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(\"%f\", 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\"%g\", 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\"%G\", 10.20+2i) (10.2+2i) %s 输出字符串表示（string类型或[]byte) Printf(\"%s\", []byte(“Go语言”)) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(\"%q\", “Go语言”) “Go语言” %x 十六进制，小写字母，每字节两个字符 Printf(\"%x\", “golang”) 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(\"%X\", “golang”) 676F6C616E67 %p 十六进制表示，前缀 0x Printf(\"%p\", \u0026people) 0x4f57f0 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174522/:0:0","tags":null,"title":"2-4. 数据类型相关操作","uri":"/lang/go/go_base/20250515174522/"},{"categories":null,"content":"\r1 运算符Go 语言内置的运算符有： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174514/:1:0","tags":null,"title":"2-3. 运算符","uri":"/lang/go/go_base/20250515174514/"},{"categories":null,"content":"\r1.1 算术运算符下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 + 相加 A + B 输出结果 30 - 相减 A - B 输出结果 -10 * 相乘 A * B 输出结果 200 / 相除 B / A 输出结果 2 % 求余 B % A 输出结果 0 ++ 自增 A++ 输出结果 11 – 自减 A– 输出结果 9 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174514/:1:1","tags":null,"title":"2-3. 运算符","uri":"/lang/go/go_base/20250515174514/"},{"categories":null,"content":"\r1.2 关系运算符下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 == 检查两个值是否相等，如果相等返回 True 否则返回 False。 (A == B) 为 False != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 (A != B) 为 True \u003e 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 (A \u003e B) 为 False \u003c 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 (A \u003c B) 为 True \u003e= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 (A \u003e= B) 为 False \u003c= 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 (A \u003c= B) 为 True ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174514/:1:2","tags":null,"title":"2-3. 运算符","uri":"/lang/go/go_base/20250515174514/"},{"categories":null,"content":"\r1.3 逻辑运算符下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。 运算符 描述 实例 \u0026\u0026 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 (A \u0026\u0026 B) 为 False || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 (A || B) 为 True ! 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 !(A \u0026\u0026 B) 为 True ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174514/:1:3","tags":null,"title":"2-3. 运算符","uri":"/lang/go/go_base/20250515174514/"},{"categories":null,"content":"\r1.4 位运算符位运算符对整数在内存中的二进制位进行操作。 下表列出了位运算符 \u0026, |, 和 ^ 的计算： p q p \u0026 q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假定 A = 60; B = 13; 其二进制数转换为： A = 0011 1100 B = 0000 1101 ----------------- A\u0026B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13： 运算符 描述 实例 \u0026 按位与运算符\"\u0026“是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 (A \u0026 B) 结果为 12, 二进制为 0000 1100 | 按位或运算符”|“是双目运算符。 其功能是参与运算的两数各对应的二进位相或 (A | B) 结果为 61, 二进制为 0011 1101 ^ 按位异或运算符”^“是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 (A ^ B) 结果为 49, 二进制为 0011 0001 « 左移运算符”«“是双目运算符。左移n位就是乘以2的n次方。 其功能把”«“左边的运算数的各二进位全部左移若干位，由”«“右边的数指定移动的位数，高位丢弃，低位补0。 A « 2 结果为 240 ，二进制为 1111 0000 » 右移运算符”»“是双目运算符。右移n位就是除以2的n次方。 其功能是把”»“左边的运算数的各二进位全部右移若干位，\"»“右边的数指定移动的位数。 A » 2 结果为 15 ，二进制为 0000 1111 以下实例演示了位运算符的用法： package main import \"fmt\" func main() { var a uint = 60 /* 60 = 0011 1100 */ var b uint = 13 /* 13 = 0000 1101 */ var c uint = 0 c = a \u0026 b */\\* 12 = 0000 1100 \\*/* fmt.Printf(\"第一行 - c 的值为 %d**\\n**\", c ) c = a | b */\\* 61 = 0011 1101 \\*/* fmt.Printf(\"第二行 - c 的值为 %d**\\n**\", c ) c = a ^ b */\\* 49 = 0011 0001 \\*/* fmt.Printf(\"第三行 - c 的值为 %d**\\n**\", c ) c = a \u003c\u003c 2 */\\* 240 = 1111 0000 \\*/* fmt.Printf(\"第四行 - c 的值为 %d**\\n**\", c ) c = a \u003e\u003e 2 */\\* 15 = 0000 1111 \\*/* fmt.Printf(\"第五行 - c 的值为 %d**\\n**\", c ) } /* 第一行 - c 的值为 12 第二行 - c 的值为 61 第三行 - c 的值为 49 第四行 - c 的值为 240 第五行 - c 的值为 15 */ ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174514/:1:4","tags":null,"title":"2-3. 运算符","uri":"/lang/go/go_base/20250515174514/"},{"categories":null,"content":"\r1.5 赋值运算符下表列出了所有Go语言的赋值运算符。 运算符 描述 实例 = 简单的赋值运算符，将一个表达式的值赋给一个左值 C = A + B 将 A + B 表达式结果赋值给 C += 相加后再赋值 C += A 等于 C = C + A -= 相减后再赋值 C -= A 等于 C = C - A *= 相乘后再赋值 C *= A 等于 C = C * A /= 相除后再赋值 C /= A 等于 C = C / A %= 求余后再赋值 C %= A 等于 C = C % A «= 左移后赋值 C «= 2 等于 C = C « 2 »= 右移后赋值 C »= 2 等于 C = C » 2 \u0026= 按位与后赋值 C \u0026= 2 等于 C = C \u0026 2 ^= 按位异或后赋值 C ^= 2 等于 C = C ^ 2 |= 按位或后赋值 C |= 2 等于 C = C | 2 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174514/:1:5","tags":null,"title":"2-3. 运算符","uri":"/lang/go/go_base/20250515174514/"},{"categories":null,"content":"\r1.6 其他运算符下表列出了Go语言的其他运算符。 运算符 描述 实例 \u0026 返回变量存储地址 \u0026a; 将给出变量的实际地址。 * 指针变量。 *a; 是一个指针变量 package main import \"fmt\" func main() { var a int = 4 var b int32 var c float32 var ptr *int /* 运算符实例 */ fmt.Printf(\"第 1 行 - a 变量类型为 = %T\\n\", a ); fmt.Printf(\"第 2 行 - b 变量类型为 = %T\\n\", b ); fmt.Printf(\"第 3 行 - c 变量类型为 = %T\\n\", c ); /* \u0026 和 * 运算符实例 */ ptr = \u0026a /* 'ptr' 包含了 'a' 变量的地址 */ fmt.Printf(\"a 的值为 %d\\n\", a); fmt.Printf(\"*ptr 为 %d\\n\", *ptr); } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174514/:1:6","tags":null,"title":"2-3. 运算符","uri":"/lang/go/go_base/20250515174514/"},{"categories":null,"content":"\r1.7 运算符优先级有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 优先级 运算符 5 * / % « » \u0026 \u0026^ 4 + - | ^ 3 == != \u003c \u003c= \u003e \u003e= 2 \u0026\u0026 1 || ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174514/:1:7","tags":null,"title":"2-3. 运算符","uri":"/lang/go/go_base/20250515174514/"},{"categories":null,"content":"\r2 Golang代码执行步骤 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174514/:2:0","tags":null,"title":"2-3. 运算符","uri":"/lang/go/go_base/20250515174514/"},{"categories":null,"content":"\r1 数据类型Go 语言按类别有以下几种数据类型： 序号 类型和描述 1 布尔型布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 2 数字类型整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 3 **字符串类型:**字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 4 派生类型: 指针类型（Pointer） /数组类型 /结构化类型(struct) / Channel 类型 / 函数类型 /切片类型 /接口类型（interface） /Map 类型 字符串格式化 %v是万能的 %T查看数据类型,类似reflect.typeOf() 普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式。 Printf(\"%v\", people) {zhangsan}， %+v 打印结构体时，会添加字段名 Printf(\"%+v\", people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(\"#v\", people) main.Human{Name:\"zhangsan\"} %T 相应值的类型的Go语法表示 Printf(\"%T\", people) main.Human %% 字面上的百分号，并非值的占位符 Printf(\"%%\") % 布尔占位符 占位符 说明 举例 输出 %t true 或 false。 Printf(\"%t\", true) true 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(\"%b\", 5) 101 %c 相应Unicode码点所表示的字符 Printf(\"%c\", 0x4E2D) 中 %d 十进制表示 Printf(\"%d\", 0x12) 18 %o 八进制表示 Printf(\"%d\", 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(\"%q\", 0x4E2D) '中' %x 十六进制表示，字母形式为小写 a-f Printf(\"%x\", 13) d %X 十六进制表示，字母形式为大写 A-F Printf(\"%x\", 13) D %U Unicode格式：U+1234，等同于 \"U+%04X\" Printf(\"%U\", 0x4E2D) U+4E2D 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %b 无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat 的 'b' 转换格式一致。例如 -123456p-78 %e 科学计数法，例如 -1234.456e+78 Printf(\"%e\", 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(\"%e\", 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(\"%f\", 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\"%g\", 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(\"%G\", 10.20+2i) (10.2+2i) 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(\"%s\", []byte(\"Go语言\")) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(\"%q\", \"Go语言\") \"Go语言\" %x 十六进制，小写字母，每字节两个字符 Printf(\"%x\", \"golang\") 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(\"%X\", \"golang\") 676F6C616E67 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(\"%p\", \u0026people) 0x4f57f0 %4s 表示输出当前字符串宽度: (\"|%4s|,|%6s|\", \"aa\", \"dd\") ==\u003e | aa|,| dd| 示例 // Go 在传统的`printf` 中对字符串格式化提供了优异的支持。 // 这里是一些基本的字符串格式化的人物的例子。 package main import \"fmt\" import \"os\" type point struct { x, y int } func main() { // Go 为常规 Go 值的格式化设计提供了多种打印方式。例 // 如，这里打印了 `point` 结构体的一个实例。 p := point{1, 2} fmt.Printf(\"%v\\n\", p) // 输出：{1 2} // 如果值是一个结构体，`%+v` 的格式化输出内容将包括 // 结构体的字段名。 fmt.Printf(\"%+v\\n\", p) // 输出：{x:1 y:2} // `%#v` 形式则输出这个值的 Go 语法表示。例如，值的 // 运行源代码片段。 fmt.Printf(\"%#v\\n\", p) // 输出：main.point{x:1, y:2} // 需要打印值的类型，使用 `%T`。 fmt.Printf(\"%T\\n\", p) // 输出：main.point // 格式化布尔值是简单的。 fmt.Printf(\"%t\\n\", true) // 输出：true // 格式化整形数有多种方式，使用 `%d`进行标准的十进 // 制格式化。 fmt.Printf(\"%d\\n\", 123) // 输出：123 // 这个输出二进制表示形式。 fmt.Printf(\"%b\\n\", 14) // 输出：1110 // 这个输出给定整数的对应字符。 fmt.Printf(\"%c\\n\", 33) // 输出：! // `%x` 提供十六进制编码。 fmt.Printf(\"%x\\n\", 456) // 输出：1c8 // 对于浮点型同样有很多的格式化选项。使用 `%f` 进 // 行最基本的十进制格式化。 fmt.Printf(\"%f\\n\", 78.9) // 输出：78.900000 // `%e` 和 `%E` 将浮点型格式化为（稍微有一点不 // 同的）科学技科学记数法表示形式。 fmt.Printf(\"%e\\n\", 123400000.0) // 输出：1.234000e+08 fmt.Printf(\"%E\\n\", 123400000.0) // 输出：1.234000E+08 // 使用 `%s` 进行基本的字符串输出。 fmt.Printf(\"%s\\n\", \"\\\"string\\\"\") // 输出：\"string\" // 像 Go 源代码中那样带有双引号的输出，使用 `%q`。 fmt.Printf(\"%q\\n\", \"\\\"string\\\"\") // 输出：\"\\\"string\\\"\" // 和上面的整形数一样，`%x` 输出使用 base-16 编码的字 // 符串，每个字节使用 2 个字符表示。 fmt.Printf(\"%x\\n\", \"hex this\") // 输出：6865782074686973 // 要输出一个指针的值，使用 `%p`。 fmt.Printf(\"%p\\n\", \u0026p) // 输出：0x42135100 // 当输出数字的时候，你将经常想要控制输出结果的宽度和 // 精度，可以使用在 `%` 后面使用数字来控制输出宽度。 // 默认结果使用右对齐并且通过空格来填充空白部分。 fmt.Printf(\"|%6d|%6d|\\n\", 12, 345) // 输出：| 12| 345| // 你也可以指定浮点型的输出宽度，同时也可以通过 宽度. // 精度 的语法来指定输出的精度。 fmt.Printf(\"|%6.2f|%6.2f|\\n\", 1.2, 3.45) // 输出：| 1.20| 3.45| // 要左对齐，使用 `-` 标志。 fmt.Printf(\"|%-6.2f|%-6.2f|\\n\", 1.2, 3.45) // 输出：|1.20 |3.45 | // 你也许也想控制字符串输出时的宽度，特别是要确保他们在 // 类表格输出时的对齐。这是基本的右对齐宽度表示。 fmt.Printf(\"|%6s|%6s|\\n\", \"foo\", \"b\") // 输出：| foo| b| // 要左对齐，和数字一样，使用 `-` 标志。 fmt.Printf(\"|%-6s|%-6s|\\n\", \"foo\", \"b\") // 输出：|foo |b | // 到目前为止，我们已经看过 `Printf`了，它通过 `os.Stdout` // 输出格式化的字符串。`Sprintf` 则格式化并返回一个字 // 符串而不带任何输出。 s := fmt.Sprintf(\"a %s\", \"string\") fmt.Println(s) // 输出：a string // 你可以使用 `Fprintf` 来格式化并输出到 `io.Writers` // 而不是 `os.Stdout`。 fmt.Fprintf(os.Stderr, \"an %s\\n\", \"error\") // 输出：an error } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174507/:1:0","tags":null,"title":"2-2. 数据类型","uri":"/lang/go/go_base/20250515174507/"},{"categories":null,"content":"\r1.1 字符串类型 a := \"hello\" unsafe.Sizeof(a) /* 输出结果为：16 字符串类型在 go 里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节。 */ 关键字string,用\"“或者``反引号表示(’““支持控制符号,反引号所有的都会原样输出) 占位符 ‘%s 万能占位符’%v’ 1.1.1 字符串常用操作 长度 **len(str) ** ,返回一个int, 返回的是字节的长度, 中文的字节长3 拼接: 使用**+或者fmt.Sprintf()** 分割: strings.Split(str,‘分割标识’), 返回一个切片 是否存在: 函数|返回值 作用 strconv 包： Atoi(s string) (int, error) 字符串转整型 strings 包： Count(s, substr string) int 计算子串substr在字符串s中出现的次数 Compare(a, b string) int 比较字符串大小 Contains(s, substr string) bool 判断字符串s中是否包含子串substr ContainsAny(s, chars string) bool 判断字符串s中是否包含chars中的某个Unicode字符 ContainsRune(s string, r rune) bool 判断字符串s中是否包含rune型值为r的字符 Index(s, substr string) int 查找子串substr在字符串s中第一次出现的位置，如果找不到则返回 -1，如果substr为空，则返回 0 LastIndex(s, substr string) int 查找子串substr在字符串s中最后出现的位置 IndexRune(s string, r rune) int 查找rune型值为r的字符在字符串s中出现的起始位置 IndexAny(s, chars string) int 查找字符串chars中字符，在字符串s中出现的起始位置 LastIndexAny(s, chars string) int 查找字符串s中出现chars中字符的最后位置 LastIndexByte(s string, c byte) int 查找byte型字符c在字符串s中的位置 SplitN(s, sep string, n int) []string 以字符串sep为分隔符，将字符串s切分成n个子串，结果中不包含sep本身。如果sep为空则将s切分为 Unicode 字符列表，如果s中没有sep子串则整个s作为切片 []string 中的第一个元素返回。参数n表示最多切出几个子串，s超出切分大小时，超出部分不再切分。n超出切分子串个数时，返回实际切分子串数。如果n为 0，则返回 nil；如果n小于 0，则不限制切分个数，全部切分 SplitAfterN(s, sep string, n int) []string 以字符串sep为分隔符，将字符串s切分成n个子串，结果中包含sep本身。如果sep为空则将s切分为 Unicode 字符列表，如果s中没有sep子串则整个s作为切片 []string 中的第一个元素返回。参数n表示最多切出几个子串，s超出切分大小时，超出部分不再切分。n超出切分子串个数时，返回实际切分子串数。如果n为 0，则返回 nil；如果n小于 0，则不限制切分个数，全部切分 Split(s, sep string) []string 以字符串sep为分隔符，将s切分成多个子串，结果中不包含sep本身。如果sep为空，则将s切分成 Unicode 字符列表，如果s中没有sep子串，则将整个s作为 []string 的第一个元素返回 SplitAfter(s, sep string) []string 以字符串sep为分隔符，将s切分成多个子串，结果中包含sep本身。如果sep为空则将s切分为 Unicode 字符列表，如果s中没有sep子串则整个s作为切片 []string 中的第一个元素返回。 Fields(s string) []string 以连续的空白字符为分隔符，将s切分成多个子串，结果中不包含空白字符本身。空白字符有：\\t, \\n, \\v, \\f, \\r, ‘’, U+0085 (NEL), U+00A0 (NBSP) 。如果s中只包含空白字符，则返回一个空切片 FieldsFunc(s string, f func(rune) bool) []string 以一个或多个满足函数f(rune)的字符为分隔符，将s切分成多个子串，结果中不包含分隔符本身。如果s中没有满足f(rune)的字符，则返回一个空切片 Join(a []string, sep string) string 以sep为拼接符，拼接切片a中的字符串 HasPrefix(s, prefix string) bool 判断字符串s是否以prefix字符串开头，是返回 true，否则返回 false HasSuffix(s, suffix string) bool 判断字符串s是否以suffix字符串结尾，是返回 true，否则返回 false Map(f func(rune) rune, s string) string 将字符串s中满足函数f(rune)的字符替换为f(rune)的返回值。如果f(rune)返回负数，则相应的字符将被删除 Repeat(s string, count int) string 返回字符串s重复count次数后的结果 ToUpper(s string) string 将字符串s中的小写字符转为大写 ToLower(s string) string 将字符串s中的大写字符转为小写 ToTitle(s string) string 将字符串s中的首个单词转为Title形式，大部分字符的Title格式就是Upper格式 ToUpperSpecial(c unicode.SpecialCase, s string) string 将字符串s中的所有字符修改为其大写格式，优先使用c中的规则进行转换 ToLowerSpecial(c unicode.SpecialCase, s string) string 将字符串s中的所有字符修改为其小写格式，优先使用c中的规则进行转换 ToTitleSpecial(c unicode.SpecialCase, s string) string 将字符串s中的所有字符修改为其Title格式，优先使用c中的规则进行转换 Title(s string) string 将字符串s中的所有单词的首字母修改为其Title格式（BUG: Title 规则不能正确处理 Unicode 标点符号） TrimLeftFunc(s string, f func(rune) bool) string 删除字符串s左边连续满足f(rune)的字符 TrimRightFunc(s string, f func(rune) bool) string 删除字符串s右边连续满足f(rune)的字符 TrimFunc(s string, f func(rune) bool) string 删除字符串s左右两边连续满足f(rune)的字符 IndexFunc(s string, f func(rune) bool) int 查找字符串s中第一个满足f(rune)的字符的字节位置，没有返回 -1 LastIndexFunc(s string, f func(rune) bool) int 查找字符串s中最后一个满足f(rune)的字符的字节位置，没有返回 -1 Trim(s string, cutset string) string 删除字符串s左右两边连续包含cutset的字符 TrimLeft(s string, cutset string) string 删除字符串s左边连续包含cutset的字符 TrimRight(s string, cutset string) string 删除字符串s右边连续包含cutset的字符 TrimSpace(s string) string 删除字符串s左右两边连续的空白字符 TrimPrefix(s, prefix string) string 删除字符串s 头部的prefix字符串 TrimSuffix(s, suffix string) string 删除字符串s 尾部的suffix字符串 Replace(s, old, new string, n int) string 替换字符串s中的old为new，如果old为空则在s中的每个字符间插入new包括首尾，n为替换次数， -1 时替换所有 EqualFold(s, t string) bool 忽略大小写比较字符串s和t，相同返回 true，反之返回 false 1. 字符串转数字 strconv.Atoi： package main import ( \"fmt\" \"strconv\" ) func main() { var str = \"111\" i, _ := strconv.Atoi(str) fmt.Printf(\"%d\\n\", i) // 输出：111 } 2. 大小写规则转换 strings.ToUpperSpecial：将字符串s中的所有字符修改为其大写格式，优先使用c中的规则进行转换 strings.ToLowerSp","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174507/:1:1","tags":null,"title":"2-2. 数据类型","uri":"/lang/go/go_base/20250515174507/"},{"categories":null,"content":"\r1.2 字符串原理 单引号是字符,双引号是字符串 字符串的底层就是一个byte数组,所以可以和 []byte 类型互相转换 字符串是由byte字节组成的,所以字符串的长度是byte字节的长度 rune类型用来表示utf8字符,一个rune字符由1个或多个byte组成 对包含中文的字符串排序 package main import ( \"fmt\" ) func main() { str := \"ABCDEFGH你好\" strRune := []rune(str) for i:=0 ; i\u003clen(strRune)/2;i++{ item := strRune[i] strRune[i] = strRune[len(strRune)-1-i] strRune[len(strRune)-1-i] = item } fmt.Println(len(str)) // 14 fmt.Println(strRune) // [22909 20320 72 71 70 69 68 67 66 65] fmt.Println(string(strRune)) //好你HGFEDCBA } 扩展 //1、位： 数据存储的最小单位。每个二进制数字0或者1就是1个位； //2、字节： 8个位构成一个字节；即：1 byte (字节)= 8 bit(位)； 1 KB = 1024 B(字节)； 1 MB = 1024 KB; (2^10 B) 1 GB = 1024 MB; (2^20 B) 1 TB = 1024 GB; (2^30 B) //3、字符： a、A、中、+、*、の......均表示一个字符； unicode,万国码,32位既4个字节表示一个字符; 一般 utf-8 编码下，一个汉字 字符 占用 3 个 字节； 一般 gbk 编码下，一个汉字 字符 占用 2 个 字节； //4、字节和字符： 字节是计算机传输数据的格式，供计算识别的。 字符是供人类观看的内容 //5、编码： 编码（encoding）:把…译成密码。==》二进制 解码（decoding）：破译(尤指密码) ==》破解密码成可以看的懂的 //6.编码格式： 字节和字符之间转换，参照的规则就是编码格式。 Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节。 Unicode码的前128个字符就是ASCII码，之后是ASCII码的扩展码。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174507/:1:2","tags":null,"title":"2-2. 数据类型","uri":"/lang/go/go_base/20250515174507/"},{"categories":null,"content":"\r1.3 数字类型 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 所有整数初始化为0,所有浮点数初始化为0.0,布尔类型初始化为 false 序号 类型和描述 1 uint8无符号 8 位整型 (0 到 255) 2 uint16无符号 16 位整型 (0 到 65535) 3 uint32无符号 32 位整型 (0 到 4294967295) 4 uint64无符号 64 位整型 (0 到 18446744073709551615) 5 int8有符号 8 位整型 (-128 到 127) 6 int16有符号 16 位整型 (-32768 到 32767) 7 int32有符号 32 位整型 (-2147483648 到 2147483647) 8 int64有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 1.3.1 浮点型 序号 类型和描述 1 float32IEEE-754 32位浮点型数 2 float64IEEE-754 64位浮点型数 3 complex6432 位实数和虚数 4 complex12864 位实数和虚数 1.3.2 其他数字类型以下列出了其他更多的数字类型： 序号 类型和描述 1 byte类似 uint8 2 rune类似 int32 3 uint32 或 64 位 4 int与 uint 一样大小 5 uintptr无符号整型，用于存放一个指针 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174507/:1:3","tags":null,"title":"2-2. 数据类型","uri":"/lang/go/go_base/20250515174507/"},{"categories":null,"content":"\r1 位-字节-字符-编码 1、位：数据存储的最小单位。每个二进制数字0或者1就是1个位； 2、字节：8个位构成一个字节；即：1 byte (字节)= 8 bit(位)； 1 KB = 1024 B(字节)； 1 MB = 1024 KB; (2^10 B) 1 GB = 1024 MB; (2^20 B) 1 TB = 1024 GB; (2^30 B) 3、字符：a、A、中、+、*、の......均表示一个字符 ； unioncode 一个汉字 4 个字节表示 一般 utf-8 编码下，一个汉字 字符 占用 3 个 字节； 一般 gbk 编码下，一个汉字 字符 占用 2 个 字节； ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174450/:1:0","tags":null,"title":"2-1. 变量","uri":"/lang/go/go_base/20250515174450/"},{"categories":null,"content":"\r2 assic码 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 \" 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 \u0026 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 \u003c 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 \u003e 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174450/:2:0","tags":null,"title":"2-1. 变量","uri":"/lang/go/go_base/20250515174450/"},{"categories":null,"content":"\r3 命名 go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则 一个名字必须以一个字母或下划线开头，后面可以跟任意数量的字母、数字或下划线 go语言中有25个关键字，不能用于自定义名字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 还有30多个预定义的名字，用于内建的常量、类型和函数 //内建常量: true false iota nil //内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error //内建函数: make len cap new append copy close delete complex real imag panic recover ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174450/:3:0","tags":null,"title":"2-1. 变量","uri":"/lang/go/go_base/20250515174450/"},{"categories":null,"content":"\r4 变量 package main import \"fmt\" func main() { var a int var b , c string var (/* */ d int e string f bool ) fmt.Println(a,b,c,d,e,f) // 0 0 false } 第一种，指定变量类型，如果没有初始化，则变量默认为零值。 零值就是变量没有做初始化时系统默认设置的值。 数值类型（包括complex64/128）为 0 布尔类型为 false 字符串为 \"\"（空字符串） 以下几种类型为 nil： var a *int var a []int var a map[string] int var a chan int var a func(string) int var a error // error 是接口 第二种，根据值自行判定变量类型。 package main import \"fmt\" func main() { var d = true fmt.Println(d) } 第三种，省略 var, 注意 := 左侧如果没有声明新的变量，就产生编译错误，格式： v_name := value //可以将 var f string = \"Runoob\" 简写为 f := \"Runoob\"： ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174450/:4:0","tags":null,"title":"2-1. 变量","uri":"/lang/go/go_base/20250515174450/"},{"categories":null,"content":"\r5 常量常量的定义格式： const identifier [type] = value 在定义常量组时，如果不提供初始值，则表示将使用上行的表达式。 常量是一个简单值的标识符，在程序运行时，不会被修改的量。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174450/:5:0","tags":null,"title":"2-1. 变量","uri":"/lang/go/go_base/20250515174450/"},{"categories":null,"content":"\r5.1 iota iota，特殊常量，可以认为是一个可以被编译器修改的常量, 变量中不可使用。 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。 iota 可以被用作枚举值： const ( a = iota //0 b = iota //1 c = iota //2 ) 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式： const ( a = iota b c ) iota 只是在同一个 const 常量组内递增，每当有新的 const 关键字时，iota 计数会重新开始。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174450/:5:1","tags":null,"title":"2-1. 变量","uri":"/lang/go/go_base/20250515174450/"},{"categories":null,"content":"\r5.2 iota 用法 package main import \"fmt\" func main() { const ( a = iota *//0* b *//1* c *//2* d = \"ha\" *//独立值，iota += 1* e *//\"ha\" iota += 1* f = 100 *//iota +=1* g *//100 iota +=1* h = iota *//7,恢复计数* i *//8* ) fmt.Println(a,b,c,d,e,f,g,h,i) } // 0 1 2 ha ha 100 100 7 8 iota 只是在同一个 const 常量组内递增，每当有新的 const 关键字时，iota 计数会重新开始。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174450/:5:2","tags":null,"title":"2-1. 变量","uri":"/lang/go/go_base/20250515174450/"},{"categories":null,"content":"\r5.3 Iota 和左右运算符 package main import \"fmt\" const ( i=1\u003c\u003ciota j=3\u003c\u003ciota k l ) func main() { fmt.Println(\"i=\",i) fmt.Println(\"j=\",j) fmt.Println(\"k=\",k) fmt.Println(\"l=\",l) } /* i= 1 j= 6 k= 12 l= 24 */ iota 表示从 0 开始自动加 1，所以 i=1«0, j=3«1（« 表示左移的意思），即：i=1, j=6，这没问题，关键在 k 和 l，从输出结果看 k=3«2，l=3«3。 简单表述: i=1：左移 0 位,不变仍为 1; j=3：左移 1 位,变为二进制 110, 即 6; k=3：左移 2 位,变为二进制 1100, 即 12; l=3：左移 3 位,变为二进制 11000,即 24。 注：«n==*(2^n)。 // 左移运算符 \u003c\u003c 是双目运算符。左移 n 位就是乘以 2 的 n 次方。 其功能把 \u003c\u003c 左边的运算数的各二进位全部左移若干位，由 \u003c\u003c 右边的数指定移动的位数，高位丢弃，低位补 0。 //右移运算符 \u003e\u003e 是双目运算符。右移 n 位就是除以 2 的 n 次方。 其功能是把 \u003e\u003e 左边的运算数的各二进位全部右移若干位， \u003e\u003e 右边的数指定移动的位数。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174450/:5:3","tags":null,"title":"2-1. 变量","uri":"/lang/go/go_base/20250515174450/"},{"categories":null,"content":"\rGOPATH1、为什么要配置GOPATH 配置GOPATH的用意是为了方便项目的部署和构建，以及可以直接使用go get 命令下载第三方的包到自己的项目的src下和相关的执行文件bin目录，和中间文件pkg src ：项目的源代码 pkg ：编译后的生成文件 bin ： 编译后的可执行文件 如果你只是想单独的写个go代码可以不设置GOPATH 2、结合GoLand来讲解GOPATH 2.1：使用goland创建一个gose项目，（可以不配置GOPATH） * 环境变量中我没有配置 * 新建gose项目 问1：index entire GOPATH:如果你选中那么我就把你在环境变量中配置的GOPATH信息加到你的项目中，没必要，点取消吧，我们如果真的需要也可以在项目配置中在进行设置 * 打开项目的File——\u003esettings 问2：Global GOPATH 选则你在环境变量中配置的GOPATH路径 问3：Project GOPATH 项目的GOPATH,最好不好设置Global GOPATH,因为那你的项目将会使用到所用配置到GOPATH的文件 问4：Use GOPATH that`s defined in system environment 如果选中这个，他将使用系统定义的环境变量，并设置到Global GOPATH 问5：Index entire GOPATH: 会将当前项目作为gopath * 最终的项目结构，也可以使用 go mod","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:0:0","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r1 简单操作 go modules 是 golang 1.11 新加的特性。现在1.12 已经发布了，是时候用起来了。Modules官方定义为： 模块是相关Go包的集合。modules是源代码交换和版本控制的单元。 go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。 设置go mod和go proxy go env -w GOBIN=/Users/youdi/go/bin go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct // 使用七牛云的 注意： go env -w会将配置写到 GOENV=\"/Users/youdi/Library/Application Support/go/env\" 下面看下我的配置 GO111MODULE=\"on\" GOARCH=\"amd64\" GOBIN=\"/Users/youdi/go/bin\" GOCACHE=\"/Users/youdi/Library/Caches/go-build\" GOENV=\"/Users/youdi/Library/Application Support/go/env\" GOEXE=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"darwin\" GOINSECURE=\"\" GONOPROXY=\"\" GONOSUMDB=\"\" GOOS=\"darwin\" GOPATH=\"/Users/youdi/go\" GOPRIVATE=\"\" GOPROXY=\"https://goproxy.cn,direct\" GOROOT=\"/usr/local/go\" GOSUMDB=\"off\" GOTMPDIR=\"\" GOTOOLDIR=\"/usr/local/go/pkg/tool/darwin_amd64\" GCCGO=\"gccgo\" AR=\"ar\" CC=\"clang\" CXX=\"clang++\" CGO_ENABLED=\"1\" GOMOD=\"/dev/null\" CGO_CFLAGS=\"-g -O2\" CGO_CPPFLAGS=\"\" CGO_CXXFLAGS=\"-g -O2\" CGO_FFLAGS=\"-g -O2\" CGO_LDFLAGS=\"-g -O2\" PKG_CONFIG=\"pkg-config\" GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/8m/v_1j4dgs7rzgqq4p_4_8k_nr0000gn/T/go-build221113671=/tmp/go-build -gno-record-gcc-switches -fno-common\" 我们看一下，我修改的内容 cat /Users/youdi/Library/Application Support/go/env GO111MODULE=on GOBIN=/Users/youdi/go/bin GOPROXY=https://goproxy.cn,direct GOSUMDB=offGO111MODULE GO111MODULE 有三个值：off, on和auto（默认值）。 GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。 GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。 GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形： 当前目录在GOPATH/src之外且该目录包含go.mod文件 当前文件在包含go.mod文件的目录下面。 当modules功能启用时，依赖包的存放位置变更为$GOPATH/pkg，允许同一个package多个版本并存，且多个项目可以共享缓存的 module 我们看下目录： cd /Users/youdi/go/pkg ├── darwin_amd64 │ ├── github.com │ ├── go.etcd.io │ ├── golang │ ├── golang.org │ ├── gopkg.in │ ├── quickstart │ └── uc.a ├── mod │ ├── cache │ ├── github.com │ ├── golang.org │ ├── google.golang.org │ └── gopkg.in └── sumdb └── sum.golang.org ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:1:0","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r2 go mod命令 golang 提供了 go mod命令来管理包。 go help mod Go mod provides access to operations on modules. Note that support for modules is built into all the go commands, not just 'go mod'. For example, day-to-day adding, removing, upgrading, and downgrading of dependencies should be done using 'go get'. See 'go help modules' for an overview of module functionality. Usage: go mod \u003ccommand\u003e [arguments] The commands are: download download modules to local cache edit edit go.mod from tools or scripts graph print module requirement graph init initialize new module in current directory tidy add missing and remove unused modules vendor make vendored copy of dependencies verify verify dependencies have expected content why explain why packages or modules are needed Use \"go help mod \u003ccommand\u003e\" for more information about a command. go mod 有以下命令： 命令 说明 download download modules to local cache(下载依赖包) edit edit go.mod from tools or scripts（编辑go.mod) graph print module requirement graph (打印模块依赖图) verify initialize new module in current directory（在当前目录初始化mod） tidy add missing and remove unused modules(拉取缺少的模块，移除不用的模块) vendor make vendored copy of dependencies(将依赖复制到vendor下) verify verify dependencies have expected content (验证依赖是否正确） why explain why packages or modules are needed(解释为什么需要依赖) 比较常用的是 init,tidy, edit ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:2:0","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r3 使用go mod管理一个新项目","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:3:0","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r3.1 1. 初始化项目可以随便找一个目录创建项目，我使用习惯用IDEA进行创建 mkdir Gone cd Gone go mod init Gone 查看一下 go.mod文件 module Gone go 1.14 go.mod文件一旦创建后，它的内容将会被go toolchain全面掌控。go toolchain会在各类命令执行时，比如go get、go build、go mod等修改和维护go.mod文件。 go.mod 提供了module, require、replace和exclude 四个命令 module 语句指定包的名字（路径） require 语句指定的依赖项模块 replace 语句可以替换依赖项模块 exclude 语句可以忽略依赖项模块 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:3:1","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r3.2 2. 添加依赖 创建 main.go文件 package main import ( \"github.com/gin-gonic/gin\" ) func main() { r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"pong\", }) }) r.Run() // listen and serve on 0.0.0.0:8080 (for windows \"localhost:8080\") } 执行 go run main.go 运行代码会发现 go mod 会自动查找依赖自动下载, 再查看 go.mod module Gone go 1.14 require github.com/gin-gonic/gin v1.6.3 go module 安装 package 的原則是先拉最新的 release tag，若无tag则拉最新的commit go 会自动生成一个 go.sum 文件来记录 dependency tree 再次执行脚本 go run main.go发现跳过了检查并安装依赖的步骤。 可以使用命令 go list -m -u all 来检查可以升级的package，使用go get -u need-upgrade-package 升级后会将新的依赖版本更新到go.mod * 也可以使用 go get -u 升级所有依赖 去mod包缓存下看看 /Users/youdi/go/pkg/mod/github.com/gin-gonic/gin@v1.6.3 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:3:2","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r4 go get升级 运行 go get -u 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号) 运行 go get -u=patch 将会升级到最新的修订版本 运行 go get package@version 将会升级到指定的版本号version 运行go get如果有版本的更改，那么go.mod文件也会更改 使用replace替换无法直接获取的package 由于某些已知的原因，并不是所有的package都能成功下载，比如：golang.org下的包。 modules 可以通过在 go.mod 文件中使用 replace 指令替换成github上对应的库，比如： replace ( golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =\u003e github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a ) ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:4:0","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r5 go mod发布和使用","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:5:0","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r5.1 Creating a Module如果你设置好go mod了，那你就可以在任何目录下随便创建 $mkdir gomodone $cd gomodone 在这个目录下创建一个文件say.go package gomodone import \"fmt\" // say Hi to someone func SayHi(name string) string { return fmt.Sprintf(\"Hi, %s\", name) } 初始化一个 go.mod文件 $ go mod init github.com/jacksonyoudi/gomodone go: creating new go.mod: module github.com/jacksonyoudi/gomodone 查看 go.mod内容如下： github.com/jacksonyoudi/gomodone go 1.14 下面我们要将这个module发布到github上，然后在另外一个程序使用 $git init $vim .gitiiignore $git commit -am \"init\" // github创建对应的repo $git remote add origin git@github.com:jacksonyoudi/gomodone.git $git push -u origin master 执行完，上面我们就相当于发布完了。 如果有人需要使用，就可以使用 go get github.com/jacksonyoudi/gomodone 这个时候没有加tag，所以，没有版本的控制。默认是v0.0.0后面接上时间和commitid。如下： gomodone@v0.0.0-20200517004046-ee882713fd1e 官方不建议这样做，没有进行版本控制管理。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:5:1","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r5.2 module versioning使用tag，进行版本控制 5.2.1 making a release git tag v1.0.0 git push --tags 操作完，我们的module就发布了一个v1.0.0的版本了。 推荐在这个状态下，再切出一个分支，用于后续v1.0.0的修复推送,不要直接在master分支修复 $git checkout -b v1 $git push -u origin v1 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:5:2","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r5.3 use our module上面已经发布了一个v1.0.0的版本，我们可以在另一个项目中使用，创建一个go的项目 $mkdir Gone $cd Gone $vim main.go package main import ( \"fmt\" \"github.com/jacksonyoudi/gomodone\" ) func main() { fmt.Println(gomodone.SayHi(\"Roberto\")) } 代码写好了，我们生成 go mod文件 go mod init Gone 上面命令执行完，会生成 go mod文件 看下mod文件： module Gone go 1.14 require ( github.com/jacksonyoudi/gomodone v1.0.0 ) $go mod tidy go: finding module for package github.com/jacksonyoudi/gomodone go: found github.com/jacksonyoudi/gomodone in github.com/jacksonyoudi/gomodone v1.0.0 同时还生成了go.sum, 其中包含软件包的哈希值，以确保我们具有正确的版本和文件。 github.com/jacksonyoudi/gomodone v1.0.1 h1:jFd+qZlAB0R3zqrC9kwO8IgPrAdayMUS0rSHMDc/uG8= github.com/jacksonyoudi/gomodone v1.0.1/go.mod h1:XWi+BLbuiuC2YM8Qz4yQzTSPtHt3T3hrlNN2pNlyA94= github.com/jacksonyoudi/gomodone/v2 v2.0.0 h1:GpzGeXCx/Xv2ueiZJ8hEhFwLu7xjxLBjkOYSmg8Ya/w= github.com/jacksonyoudi/gomodone/v2 v2.0.0/go.mod h1:L8uFPSZNHoAhpaePWUfKmGinjufYdw9c2i70xtBorSw= 这个内容是下面的，需要操作执行的结果 go run main.go就可以运行了 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:5:3","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r5.4 Making a bugfix release假如fix一个bug,我们在v1版本上进行修复 修改代码如下： // say Hi to someone func SayHi(name string) string { - return fmt.Sprintf(\"Hi, %s\", name) + return fmt.Sprintf(\"Hi, %s!\", name) } 修复好，我们开始push $ git commit -m \"Emphasize our friendliness\" say.go $ git tag v1.0.1 $ git push --tags origin v1 5.4.1 Updating modules刚才fix bug，所以要在我们使用项目中更新 这个需要我们手动执行更新module操作 我们通过使用我们的好朋友来做到这一点go get： 运行 go get -u 以使用最新的 minor 版本或修补程序版本（即它将从1.0.0更新到例如1.0.1，或者，如果可用，则更新为1.1.0） 运行 go get -u=patch 以使用最新的 修补程序 版本（即，将更新为1.0.1但不更新 为1.1.0） 运行go get package@version 以更新到特定版本（例如github.com/jacksonyoudi/gomodone@v1.0.1） 目前module最新的也是v1.0.1 // 更新最新 $go get -u $go get -u=patch //指定包，指定版本 $go get github.com/jacksonyoudi/gomodone@v1.0.1 操作完，go.mod文件会修改如下: module Gone go 1.14 require ( github.com/jacksonyoudi/gomodone v1.0.1 ) 5.4.2 Major versions根据语义版本语义，主要版本与次要版本 不同。主要版本可能会破坏向后兼容性。从Go模块的角度来看，主要版本是 完全不同的软件包。乍一看这听起来很奇怪，但这是有道理的：两个不兼容的库版本是两个不同的库。 比如下面修改，完全破坏了兼容性。 package gomodone import ( \"errors\" \"fmt\" ) // Hi returns a friendly greeting // Hi returns a friendly greeting in language lang func SayHi(name, lang string) (string, error) { switch lang { case \"en\": return fmt.Sprintf(\"Hi, %s!\", name), nil case \"pt\": return fmt.Sprintf(\"Oi, %s!\", name), nil case \"es\": return fmt.Sprintf(\"¡Hola, %s!\", name), nil case \"fr\": return fmt.Sprintf(\"Bonjour, %s!\", name), nil default: return \"\", errors.New(\"unknown language\") } } 如上，我们需要不同的大版本，这种情况下 修改 go.mod如下 module github.com/jacksonyoudi/gomodone/v2 go 1.14 然后，重新tag，push $ git commit say.go -m \"Change Hi to allow multilang\" $ git checkout -b v2 # 用于v2版本，后续修复v2 $ git commit go.mod -m \"Bump version to v2\" $ git tag v2.0.0 $ git push --tags origin v2 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:5:4","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r5.5 Updating to a major version即使发布了库的新不兼容版本，现有软件 也不会中断，因为它将继续使用现有版本1.0.1。go get -u 将不会获得版本2.0.0。 如果想使用v2.0.0,代码改成如下： package main import ( \"fmt\" \"github.com/jacksonyoudi/gomodone/v2\" ) func main() { g, err := gomodone.SayHi(\"Roberto\", \"pt\") if err != nil { panic(err) } fmt.Println(g) } 执行 go mod tidy go: finding module for package github.com/jacksonyoudi/gomodone/v2 go: downloading github.com/jacksonyoudi/gomodone/v2 v2.0.0 go: found github.com/jacksonyoudi/gomodone/v2 in github.com/jacksonyoudi/gomodone/v2 v2.0.0 当然，两个版本都可以同时使用, 使用别名 如下： package main import ( \"fmt\" \"github.com/jacksonyoudi/gomodone\" mv2 \"github.com/jacksonyoudi/gomodone/v2\" ) func main() { g, err := mv2.SayHi(\"Roberto\", \"pt\") if err != nil { panic(err) } fmt.Println(g) fmt.Println(gomodone.SayHi(\"Roberto\")) } 执行一下 go mod tidy ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:5:5","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r5.6 Vendoring默认是忽略vendor的，如果想在项目目录下有vendor可以执行下面命令 $go vendor 当然，如果构建程序的时候，希望使用vendor中的依赖， $ go build -mod vendor ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:5:6","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\r5.7 IDEA下开发GO 创建go项目 创建完项目，会自动生成go mod文件 如果需要修改，可以手动修改，加入git等操作 写业务逻辑代码 解决依赖，更新go.mod ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174437/:5:7","tags":null,"title":"1-1. GoPath和GoMod","uri":"/lang/go/go_base/20250515174437/"},{"categories":null,"content":"\rGolang - 环境配置","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174347/:0:0","tags":null,"title":"1-0. 环境配置","uri":"/lang/go/go_base/20250515174347/"},{"categories":null,"content":"\r1 认识go语言 go语言（或 Golang）是Google开发的开源编程语言，诞生于2006年1月2日下午15点4分5秒，于2009年11月开源，2012年发布go稳定版 go是非常年轻的一门语言，它的主要目标是“兼具Python 等动态语言的开发速度和C/C++等编译型语言的性能与安全性 可以粗略的认为go = c + python 从C语言中继承了很多理念，尤其是指针的运用 func testPtr(num *int) { *num = 20 } 引入包的概念，用于组织程序结构。单独的go文件必须存在于package中 垃圾回收制度，内存自动回收。 语言层面天然支持高并发 使用了goroutine的语法，轻量级线程，高效利用多核 吸收了管道通信机制，有管道的写法，channel的写法，通过管道实现不同goroute之间的相互通信。 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174347/:1:0","tags":null,"title":"1-0. 环境配置","uri":"/lang/go/go_base/20250515174347/"},{"categories":null,"content":"\r2 go的优势 做高并发有巨大的优势 垃圾自动回收 开发简单，开发效率堪比python 运行效率高，很适合用作中央服务器的系统编程语言 是项目转型的首选语言，很多公司在用go重构代码 提供了海量并行的支持，很适合处理游戏相关数据 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174347/:2:0","tags":null,"title":"1-0. 环境配置","uri":"/lang/go/go_base/20250515174347/"},{"categories":null,"content":"\r3 环境准备 安装golang jdk –中文在线文档：https://studygolang.com/pkgdoc 选择安装,一路next…. 配置环境变量(可选) 安装开发工具 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174347/:3:0","tags":null,"title":"1-0. 环境配置","uri":"/lang/go/go_base/20250515174347/"},{"categories":null,"content":"\r4 创建第一个项目 GOPATH：go的代码存这里面 src: 存放源代码 pkg:存一些中间文件 bin:存放二进制文件的目录 // 单行注释 /*多行 注释*/ // 每个go源代码文件开头必须package声明，代表属于哪个包 // 声明main，代表可以编译 // 下面会对应有且仅有一个main函数，主函数 package main // 引入的包，必须用，不然报错 // 自动导包 import ( \"fmt\" ) // 左括号不能单起一行，会报错 // 同一个包中，只有一个main func main() { fmt.Println(\"hello word\") } ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174347/:4:0","tags":null,"title":"1-0. 环境配置","uri":"/lang/go/go_base/20250515174347/"},{"categories":null,"content":"\r5 常见的go命令 go run test.go // 执行go文件，相当于 先编译生成可执行文件后接着执行它 go build test.go //编译生成可执行文件 //注意：windows平台生成exe,但是mac就是一个test,无后缀，使用方式./test即可 go run 运行当个.go文件 go install 在编译源代码之后还安装到指定的目录 go build 加上可编译的go源文件可以得到一个可执行文件 go get = git clone + go install 从指定源上面下载或者更新指定的代码和依赖，并对他们进行编译和安装 两者的三个主要区别： go bulid编译后生成的可执行文件，可以直接拿到同平台下但是没有go开发环境的机器下运行。 go run不会编译生成可执行文件，不能在没有go开发环境下的其它机器上运行。 .go的源文件虽然很小，但是编译后会将源代码所依赖的库文件编译进来，导致生成的可执行文件很大。 关于编译的几个参数： 编译时可以改变生成的可执行文件的名字 go build -o hello-new hello.go 可执行文件就会叫hello-new ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174347/:5:0","tags":null,"title":"1-0. 环境配置","uri":"/lang/go/go_base/20250515174347/"},{"categories":null,"content":"\r6 在一个平台下生成多个平台运行包 编译之后直接可执行，使用起来非常方便 Mac Mac下编译Linux, Windows平台的64位可执行程序： CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build test.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go Linux Linux下编译Mac, Windows平台的64位可执行程序： CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build test.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go Windows Windows下编译Mac, Linux平台的64位可执行程序： SET CGO_ENABLED=0 SET GOOS=darwin3 SET GOARCH=amd64 go build main.go SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go GOOS：目标可执行程序运行操作系统，支持 darwin，freebsd，linux，windows GOARCH：目标可执行程序操作系统构架，包括 386，amd64，arm ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174347/:6:0","tags":null,"title":"1-0. 环境配置","uri":"/lang/go/go_base/20250515174347/"},{"categories":null,"content":"\r7 Golang的项目目录结构 个人 公司 ","date":"2025-05-15","objectID":"/lang/go/go_base/20250515174347/:7:0","tags":null,"title":"1-0. 环境配置","uri":"/lang/go/go_base/20250515174347/"},{"categories":null,"content":" 配置了这么多次go开发环境，每次都踩坑，记录下使用windows系统开发go语言的环境配置，了解go语言的开发环境特点 开发环境： VSCode go 1.24 多版本管理 ","date":"2025-05-10","objectID":"/lang/go/20250510143746/:0:0","tags":null,"title":"go开发环境配置","uri":"/lang/go/20250510143746/"},{"categories":null,"content":"\r1 下载安装 官方下载安装 建议安装到 默认路径下面 C:\\Program Files\\Go 安装完成后，会发现多了些东西 GOPATH : %USERPROFILE%\\go 在用户根目录下 bin 下面是go的一些插件 用vscode开发的时候 会依赖这些插件 pkg 下面是各个项目下载的第三方包，都会存到这个路径下 PATH %USERPROFILE%\\go\\bin 系统环境变量 PATH C:\\Program Files\\Go\\bin 这个是下载的go程序的安装路径 ","date":"2025-05-10","objectID":"/lang/go/20250510143746/:1:0","tags":null,"title":"go开发环境配置","uri":"/lang/go/20250510143746/"},{"categories":null,"content":"\r2 源配置go第三方包的源在国外，下载速度会比较慢，更换为国内源 推荐使用 go env 命令 # 启用 Go Modules 模式 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 扩展 go env 命令 配置写到哪个地方了 $HOME/.config/go/env # Linux/macOS %USERPROFILE%\\AppData\\Roaming\\go\\env # Windows ","date":"2025-05-10","objectID":"/lang/go/20250510143746/:2:0","tags":null,"title":"go开发环境配置","uri":"/lang/go/20250510143746/"},{"categories":null,"content":"\r3 使用vscode开发 go配置 插件市场 搜索 安装 go插件 安装 工具 ctrl + shift + p 搜索 go install 安装 工具 gopls是必须的 安装完后插件 也放到了 GOPATH下面 扩展 介绍下这些插件的作用 工具名称 版本信息 作用描述 主要用途/使用场景 gopls latest Go 语言服务器（Language Server Protocol） 提供代码补全、跳转定义、重构等编辑器功能，提升编码效率 gotests v1.6.0 自动生成单元测试代码 快速生成函数或方法的测试框架，提高测试覆盖率 gomodifytags v1.7.0 修改结构体字段标签（如 JSON、XML、SQL 等） 自动添加、删除或修改结构体中的标签，方便序列化处理 impl v1.4.0 为接口生成实现模板 快速生成接口的方法骨架，减少手动编写工作量 goplay v1.0.0 类似 Go Playground 的本地代码运行环境 快速运行小段代码片段，验证逻辑无需创建完整项目 dlv latest Go 调试工具（Delve） 设置断点、查看变量、调试程序行为，适合复杂问题排查 staticcheck latest 静态代码分析工具（Linter） 检查潜在错误、优化代码质量，遵循最佳实践 ","date":"2025-05-10","objectID":"/lang/go/20250510143746/:3:0","tags":null,"title":"go开发环境配置","uri":"/lang/go/20250510143746/"},{"categories":null,"content":"\r4 多版本管理经常会存在一些情况，不同的项目依赖不同的go版本，官方有自己的go 多版本管理方式，挺好用的 官方go多版本管理 # 先安装一个 go1.10.7 的命令 go install golang.org/dl/go1.10.7@latest # 再使用这个命令下载 这个版本的go go1.10.7 download 第一步 下载 go1.10.7 命令 放在了 GOPATH bin下面 第二步 使用 go1.10.7 命令下载这个版本的go 存放的位置 当前用户根目录 的 C:\\Users\\admin\\sdk 路径下 多版本的go 放到哪个地方了呢？ 后续用VSCode开发的时候，就可以很好的切换到不同的go版本了 也可以通过 go1.10.7 env GOROOT 命令查看安装到哪个地方了 ","date":"2025-05-10","objectID":"/lang/go/20250510143746/:4:0","tags":null,"title":"go开发环境配置","uri":"/lang/go/20250510143746/"},{"categories":null,"content":"\r4.1 vscode 中切换不同版本的go 选择切换成不同的go版本 在左侧项目文件夹 也有 go的一些快捷操作 ","date":"2025-05-10","objectID":"/lang/go/20250510143746/:4:1","tags":null,"title":"go开发环境配置","uri":"/lang/go/20250510143746/"},{"categories":null,"content":"\r5 go常用的命令别死记了！ 用的不熟练的时候， go help看下 相信了解这些细节之后，安装 配置你都能很清楚了 ","date":"2025-05-10","objectID":"/lang/go/20250510143746/:5:0","tags":null,"title":"go开发环境配置","uri":"/lang/go/20250510143746/"},{"categories":["github"],"content":"本地拉取github老是失败，可通过全局配置代理，或只给github.com配置代理 前言：本地拉取github老是失败，可通过全局配置代理，或只给github.com配置代理 git 配置代理","date":"2025-04-25","objectID":"/lang/git/20250425152252/:0:0","tags":null,"title":"多平台GitHub配置代理","uri":"/lang/git/20250425152252/"},{"categories":["github"],"content":"\r1 windows 设置代理","date":"2025-04-25","objectID":"/lang/git/20250425152252/:1:0","tags":null,"title":"多平台GitHub配置代理","uri":"/lang/git/20250425152252/"},{"categories":["github"],"content":"\r1.1 http || https协议 //设置全局代理 git config --global https.proxy http://127.0.0.1:7897 git config --global https.proxy https://127.0.0.1:7897 // socks git config --global http.proxy socks5://127.0.0.1:7897 git config --global https.proxy socks5://127.0.0.1:7897 //只对github.com使用代理，其他仓库不走代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:7897 git config --global https.https://github.com.proxy socks5://127.0.0.1:7897 //取消github代理 git config --global --unset http.https://github.com.proxy git config --global --unset https.https://github.com.proxy //取消全局代理 git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2025-04-25","objectID":"/lang/git/20250425152252/:1:1","tags":null,"title":"多平台GitHub配置代理","uri":"/lang/git/20250425152252/"},{"categories":["github"],"content":"\r1.2 SSH协议 //对于使用git@协议的，可以配置socks5代理 //在~/.ssh/config 文件后面添加几行，没有可以新建一个 //socks5 Host github.com User git ProxyCommand connect -S 127.0.0.1:7897 %h %p //http || https Host github.com User git ProxyCommand connect -H 127.0.0.1:7897 %h %p ","date":"2025-04-25","objectID":"/lang/git/20250425152252/:1:2","tags":null,"title":"多平台GitHub配置代理","uri":"/lang/git/20250425152252/"},{"categories":["github"],"content":"\r2 WSL2设置代理在 Ubuntu 子系统中，通过 cat /etc/resolv.conf 查看 DNS 服务器 IP cat /etc/resolv.conf # This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf: # [network] # generateResolvConf = false nameserver 172.23.64.1 其实上面地址就是windows下面这个ip地址 win11-\u003e设置-\u003e网络和Internet-\u003e高级网络设置-\u003e硬件和连接属性 名称：vEthernet (WSL) ipv4地址：172.23.64.1/20 我们要为WSL配置ssh代理和http代理 touch ~/.ssh/config vim ~/.ssh/config Host github.com HostName github.com User git # 走 socks5 代理 ProxyCommand nc -v -x 172.28.32.1:7897 %h %p 使用下面命令检查ssh代理配置是否成功 ssh -T github.com Connection to github.com 22 port [tcp/ssh] succeeded! Hi wq-zhijun! You've successfully authenticated, but GitHub does not provide shell access. 可以将上面ip地址配置代理写入到.bashrc文件中，这样就可以自己用户开机永久生效， 另外apt要单独在/etc/apt/apt.conf设置代理 export u_host=`cat /etc/resolv.conf|grep nameserver|awk '{print $2}'` sed -i \"/.*ProxyCommand*/c\\ ProxyCommand nc -v -x $u_host:7897 %h %p\" ~/.ssh/config proxy () { export ALL_PROXY=\"http://$u_host:7897\" export all_proxy=\"http://$u_host:7897\" export {http,https,ftp}_proxy=$ALL_PROXY export {HTTP,HTTPS,FTP}_PROXY=$ALL_PROXY echo -e \"Acquire::http::Proxy \\\"http://$u_host:7897\\\";\" | sudo tee -a /etc/apt/apt.conf \u003e /dev/null echo -e \"Acquire::https::Proxy \\\"http://$u_host:7897\\\";\" | sudo tee -a /etc/apt/apt.conf \u003e /dev/null curl ip.gs } proxy # default call proxy noproxy () { unset ALL_PROXY unset all_proxy sudo sed -i -e '/Acquire::http::Proxy/d' /etc/apt/apt.conf sudo sed -i -e '/Acquire::https::Proxy/d' /etc/apt/apt.conf curl ip.gs } 7897端口 是clash for windows端口，另外将 Allow LAN 打开。 还需要将防火墙打开 win+r 输入 control到如下目录 控制面板\\系统和安全\\Windows Defender 防火墙 放行clash* ","date":"2025-04-25","objectID":"/lang/git/20250425152252/:2:0","tags":null,"title":"多平台GitHub配置代理","uri":"/lang/git/20250425152252/"},{"categories":["github"],"content":"\r3 git push失败或者卡住不动问题原因是有的节点22端口被服务端封锁了，要么改服务端端口要么改自己本地更换443端口（~/.ssh/config) # 可以先使用如下测试下 ssh -T -p 443 git@ssh.github.com # Hi USERNAME! You've successfully authenticated, but GitHub does not provide shell access. # 更换端口后再测试下 ssh -T git@github.com # Hi USERNAME! You've successfully authenticated, but GitHub does not provide shell access. # .ssh目录的config文件添加如下内容 vim ~/.ssh/config Host github.com HostName github.com User git # set socks5 proxy ProxyCommand nc -v -x 172.23.64.1:7897 %h %p ","date":"2025-04-25","objectID":"/lang/git/20250425152252/:3:0","tags":null,"title":"多平台GitHub配置代理","uri":"/lang/git/20250425152252/"},{"categories":["github"],"content":"\r4 修改配置文件的方式 windows系统的配置 文件在 C:\\Users\\admin\\.gitconfig 配置文件如下 [http \"https://github.com\"] proxy = http://127.0.0.1:7897 [https \"https://github.com\"] proxy = https://127.0.0.1:7897 ","date":"2025-04-25","objectID":"/lang/git/20250425152252/:4:0","tags":null,"title":"多平台GitHub配置代理","uri":"/lang/git/20250425152252/"},{"categories":null,"content":"\rsqoop介绍 Sqoop 是一个设计用于在 Hadoop 和关系数据库或大型机之间传输数据的工具。您可以使用 Sqoop 将数据从关系数据库管理系统 (RDBMS)（例如 MySQL 或 Oracle）或大型机导入 Hadoop 分布式文件系统 (HDFS)，在 Hadoop MapReduce 中转换数据，然后将数据导出回 RDBMS 。 Hadoop生态包括： HDFS，Hive，Hbase等 RDBMS体系包括：Mysql、Oracle、DB2等 sqoop是一些工具的集合, 使用的语法如下 sqoop tool-name [tool-arguments] ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:1:0","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r命令工具可用的命令工具如下 可以使用 –help 查看命令工具的使用方法 sqoop import --help sqoop help import 命令 作用描述 使用方法 codegen 生成与数据库记录交互的代码 sqoop codegen --connect \u003c连接字符串\u003e --table \u003c表名\u003e create-hive-table 将表定义导入到 Hive 中 sqoop create-hive-table --connect \u003c连接字符串\u003e --table \u003c表名\u003e eval 执行 SQL 语句并显示结果 sqoop eval --connect \u003c连接字符串\u003e --query \u003cSQL 语句\u003e export 将 HDFS 目录导出到数据库表 sqoop export --connect \u003c连接字符串\u003e --table \u003c表名\u003e --export-dir \u003cHDFS 目录\u003e help 列出可用命令 sqoop help import 将数据库表导入到 HDFS sqoop import --connect \u003c连接字符串\u003e --table \u003c表名\u003e import-all-tables 将数据库中的所有表导入到 HDFS sqoop import-all-tables --connect \u003c连接字符串\u003e import-mainframe 将主机服务器上的数据集导入到 HDFS sqoop import-mainframe --connect \u003c连接字符串\u003e --dataset \u003c数据集\u003e job 使用已保存的作业 sqoop job --create \u003c作业名\u003e --import --connect \u003c连接字符串\u003e --table \u003c表名\u003e list-databases 列出服务器上的可用数据库 sqoop list-databases --connect \u003c连接字符串\u003e list-tables 列出数据库中的可用表 sqoop list-tables --connect \u003c连接字符串\u003e merge 合并增量导入的结果 sqoop merge --new-data \u003c新数据目录\u003e --onto \u003c旧数据目录\u003e metastore 运行独立的 Sqoop 元数据存储服务 sqoop metastore version 显示版本信息 sqoop version ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:2:0","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\rimport 功能 将关系型数据表导入到HDFS中，可以设置存储格式为Avro 或者 SequenceFiles sqoop import --help 查看该命令工具的用法 参数可以按功能来分组，包括：Common参数、Hive参数、Import control 参数、HBase 参数、HCatalog 参数、Accumulo 参数、 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:3:0","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\rcommon参数 Argument Description --connect \u003cjdbc-uri\u003e Specify JDBC connect string --connection-manager \u003cclass-name\u003e Specify connection manager class to use --driver \u003cclass-name\u003e Manually specify JDBC driver class to use --hadoop-mapred-home \u003cdir\u003e Override $HADOOP_MAPRED_HOME --help Print usage instructions --password-file Set path for a file containing the authentication password -P Read password from console --password \u003cpassword\u003e Set authentication password --username \u003cusername\u003e Set authentication username --verbose Print more information while working --connection-param-file \u003cfilename\u003e Optional properties file that provides connection parameters --relaxed-isolation Set connection transaction isolation to read uncommitted for the mappers. ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:3:1","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r验证参数可以验证同步之后的表的数据量是否一致 参数 描述 --validate 启用复制数据的验证，仅支持单表复制。 --validator \u003cclass-name\u003e 指定要使用的验证器类。 --validation-threshold \u003cclass-name\u003e 指定要使用的验证阈值类。 --validation-failurehandler \u003cclass-name\u003e 指定要使用的验证失败处理程序类。 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:3:2","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\rimport control 参数 参数 描述 --append 将数据附加到 HDFS 中的现有数据集 --as-avrodatafile 将数据导入 Avro 数据文件 --as-sequencefile 将数据导入 SequenceFiles --as-textfile 以纯文本形式导入数据（默认） --as-parquetfile 将数据导入 Parquet 文件 --boundary-query \u003cstatement\u003e 用于创建分割的边界查询 --columns \u003ccol,col,col…\u003e 从表中导入的列 --delete-target-dir 如果存在则删除导入目标目录 --direct 如果数据库存在，则使用直接连接器 --fetch-size \u003cn\u003e 一次从数据库读取的条目数。 --inline-lob-limit \u003cn\u003e 设置内联 LOB 的最大大小 -m,--num-mappers \u003cn\u003e 使用_n个_map任务并行导入 -e,--query \u003cstatement\u003e 导入的结果_statement_。 --split-by \u003ccolumn-name\u003e 用于分割工作单元的表格列。不能与 --autoreset-to-one-mapper选项一起使用。 --split-limit \u003cn\u003e 每个分割大小的上限。这仅适用于整数和日期列。对于日期或时间戳字段，以秒为单位计算。 --autoreset-to-one-mapper 如果表没有主键且未提供拆分列，则导入应使用一个映射器。不能与 --split-by \u003ccol\u003e选项一起使用。 --table \u003ctable-name\u003e 表格阅读 --target-dir \u003cdir\u003e HDFS 目标目录 --temporary-rootdir \u003cdir\u003e 导入期间创建的临时文件的 HDFS 目录（覆盖默认的“_sqoop”） --warehouse-dir \u003cdir\u003e 表目标的 HDFS 父级 --where \u003cwhere clause\u003e 导入期间使用的 WHERE 子句 -z,--compress 启用压缩 --compression-codec \u003cc\u003e 使用 Hadoop 编解码器（默认 gzip），parquet格式需要加这个配置 --null-string \u003cnull-string\u003e 为字符串列写入空值的字符串 --null-non-string \u003cnull-string\u003e 对于非字符串列，要写入空值的字符串 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:3:3","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r增量导入参数 参数 描述 --check-column (col) 指定在确定要导入哪些行时要检查的列。（该列不应为 CHAR/NCHAR/VARCHAR/VARNCHAR/LONGVARCHAR/LONGNVARCHAR 类型） --incremental (mode) 指定 Sqoop 如何确定哪些行是新行。include和 的mode 合法 值。 append``lastmodified --last-value (value) 指定上次导入的检查列的最大值。 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:3:4","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r输出行格式化参数，写入到hdfs中的行数据 参数 描述 --enclosed-by \u003cchar\u003e 设置必填字段括字符 --escaped-by \u003cchar\u003e 设置转义字符 --fields-terminated-by \u003cchar\u003e 设置字段分隔符，hive默认分隔符 是‘\\001’, 如果行数据以，分割，需设置这个 --lines-terminated-by \u003cchar\u003e 设置行尾字符 --mysql-delimiters 使用 MySQL 的默认分隔符集：字段：, 行：\\n 转义符：\\ 可选封闭符：' --optionally-enclosed-by \u003cchar\u003e 设置字段包围字符 支持的转义字符 \\b (backspace) \\n (newline) \\r (carriage return) \\t (tab) \\\" (double-quote) \\\\' (single-quote) \\\\ (backslash) \\0 (NUL) ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:3:5","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r输入解析参数 参数 描述 --input-enclosed-by \u003cchar\u003e 设置必填字段 --input-escaped-by \u003cchar\u003e 设置输入转义字符 --input-fields-terminated-by \u003cchar\u003e 设置输入字段分隔符 --input-lines-terminated-by \u003cchar\u003e 设置输入行尾字符 --input-optionally-enclosed-by \u003cchar\u003e 设置字段包围字符 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:3:6","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\rhive参数(常用) 参数 描述 --hive-home \u003cdir\u003e 覆盖$HIVE_HOME --hive-import 将表导入 Hive（如果未设置分隔符，则使用 Hive 的默认分隔符。） --hive-overwrite 覆盖 Hive 表中的现有数据。 --create-hive-table true,目标表存在会报错，默认 false。 --hive-table \u003ctable-name\u003e 设置导入到 Hive 时使用的表名。 --hive-drop-import-delims 导入到 Hive 时从字符串字段中 删除_\\n_、\\r_和\\01 。_ --hive-delims-replacement 导入 Hive 时，将字符串字段中的 \\n、\\r_和\\01_ 替换为用户定义的字符串。 --hive-partition-key 要进行分区的 Hive 字段的名称 --hive-partition-value \u003cv\u003e 在此作业中，作为导入到 Hive 中的分区键的字符串值。 --map-column-hive \u003cmap\u003e 覆盖配置列从 SQL 类型到 Hive 类型的默认映射。如果在此参数中指定逗号，请使用 URL 编码的键和值，例如，使用 DECIMAL(1%2C%201) 而不是 DECIMAL(1, 1)。 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:3:7","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\rHBase 参数 --column-family \u003cfamily\u003e 设置导入的目标列族 --hbase-create-table 如果指定，则创建缺失的 HBase 表 --hbase-row-key \u003ccol\u003e 指定使用哪个输入列作为行键 如果输入表包含复合 则 \u003ccol\u003e 必须采用 逗号分隔的复合键列表 属性 --hbase-table \u003ctable-name\u003e 指定要用作目标的 HBase表（而不是 HDFS） --hbase-bulkload 启用批量加载 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:3:8","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r使用例子\rmysql数据导入到hive，txt格式 分区表 sqoop import --connect jdbc:mysql://192.168.8.1:3306/{mysql_db}?tinyInt1isBit=false \\ --username user001 \\ --password passwd001 \\ --query \"{query}\" \\ --fields-terminated-by ',' \\ --hive-drop-import-delims \\ --null-string '\\\\\\\\N' \\ --null-non-string '\\\\\\\\N' \\ --lines-terminated-by \"\\\\n\" \\ --hive-overwrite \\ --hive-import \\ --target-dir /tmp/{hive_table} \\ --delete-target-dir \\ # 分区相关 --hive-partition-key {partition_key} \\ --hive-partition-value {partition_value} \\ --hive-database {hive_db} \\ --hive-table {hive_table} \\ --split-by '{split}' \\ -m {m} \\ mysql导入到hive，parquet格式 sqoop import -D mapred.job.name=ETL-${table_name} \\ --connect jdbc:mysql://192.168.8.61:3306/CN_Proj_DB?tinyInt1isBit=false \\ --username user001 \\ --password passwd001 \\ --query \"select * from ${table_name} where 1=1 and \\$CONDITIONS\" \\ --fields-terminated-by '\\001' \\ --hive-drop-import-delims \\ --delete-target-dir \\ --null-string '\\\\N' \\ --null-non-string '\\\\N' \\ --lines-terminated-by \"\\n\" \\ --target-dir /yyq_test/${table_name} \\ --hive-import \\ --hive-database bigworktest \\ --hive-table ${table_name} \\ --split-by id \\ -m 3 \\ # 压缩格式 parquet文件 --compress \\ --compression-codec org.apache.hadoop.io.compress.SnappyCodec \\ --hive-overwrite \\ --as-parquetfile mysql导入到hdfs文件 sqoop import \\ --connect jdbc:mysql://192.168.109.1:3306/userdb \\ --username root \\ --password root \\ --delete-target-dir \\ --fields-terminated-by '\\t' # 分隔符 --target-dir /sqoopresult \\ # 导入的hdfs目录 --table emp --m 1 mysql增量导入append模式 sqoop import \\ --connect jdbc:mysql://192.168.109.1:3306/userdb \\ --username root --password root \\ --table emp --m 1 \\ --target-dir /appendresult \\ --incremental append \\ --check-column id \\ # 主键 --last-value 1205 # 追加的id Lastmodified模式 按照时间戳字段 sqoop import \\ --connect jdbc:mysql://192.168.109.1:3306/userdb \\ --username root \\ --password root \\ --table customertest \\ --target-dir /lastmodifiedresult \\ --check-column last_mod \\ --incremental lastmodified \\ --last-value \"2019-09-03 22:59:45\" \\ --m 1 \\ # --merge-key id 修改旧的，新增新的 --append ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:3:9","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\rimport-all-tables 将一组表从关系型数据库导入到HDFS中 语法 sqoop import-all-tables (generic-args) (import-args) 每个组的参数参考官方文档 Sqoop User Guide (v1.4.7) (apache.org) ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:4:0","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\rexport HDFS数据 到 RDBMS 语法 sqoop export (generic-args) (export-args) ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:5:0","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\rcommon参数 争论 描述 --connect \u003cjdbc-uri\u003e 指定 JDBC 连接字符串 --connection-manager \u003cclass-name\u003e 指定要使用的连接管理器类 --driver \u003cclass-name\u003e 手动指定要使用的 JDBC 驱动程序类 --hadoop-mapred-home \u003cdir\u003e 覆盖 $HADOOP_MAPRED_HOME --help 打印使用说明 --password-file 设置包含身份验证密码的文件路径 -P 从控制台读取密码 --password \u003cpassword\u003e 设置认证密码 --username \u003cusername\u003e 设置认证用户名 --verbose 工作时打印更多信息 --connection-param-file \u003cfilename\u003e 提供连接参数的可选属性文件 --relaxed-isolation 将连接事务隔离设置为映射器读取未提交。 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:5:1","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r验证参数 参数 描述 --validate 启用复制数据的验证，仅支持单表复制。 --validator \u003cclass-name\u003e 指定要使用的验证器类。 --validation-threshold \u003cclass-name\u003e 指定要使用的验证阈值类。 --validation-failurehandler \u003cclass-name\u003e 指定要使用的验证失败处理程序类。 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:5:2","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r导出控制参数 参数 描述 --columns \u003ccol,col,col…\u003e 要导出到表的列 --direct 使用直接导出快速路径 --export-dir \u003cdir\u003e 导出的 HDFS 源路径 -m,--num-mappers \u003cn\u003e 使用_n个_map任务并行导出 --table \u003ctable-name\u003e 要填充的表格 --call \u003cstored-proc-name\u003e 要调用的存储过程 --update-key \u003ccol-name\u003e 用于更新的锚点列。如果有多个列，请使用逗号分隔的列表。 --update-mode \u003cmode\u003e 指定当数据库中发现具有不匹配键的新行时如何执行更新。 updateonly（默认）和 allowinsert。不存在会插入数据 --input-null-string \u003cnull-string\u003e 对于字符串列，将被解释为空的字符串 --input-null-non-string \u003cnull-string\u003e 对于非字符串列，将被解释为空的字符串 --staging-table \u003cstaging-table-name\u003e 数据在插入目标表之前将暂存于其中的表。 --clear-staging-table 指示可以删除暂存表中的所有数据。 --batch 使用批处理模式执行底层语句。 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:5:3","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r输入解析参数 争论 描述 --input-enclosed-by \u003cchar\u003e 设置必填字段 --input-escaped-by \u003cchar\u003e 设置输入转义字符 --input-fields-terminated-by \u003cchar\u003e 设置输入字段分隔符 --input-lines-terminated-by \u003cchar\u003e 设置输入行尾字符 --input-optionally-enclosed-by \u003cchar\u003e 设置字段包围字符 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:5:4","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r输出行格式化参数 争论 描述 --enclosed-by \u003cchar\u003e 设置必填字段括字符 --escaped-by \u003cchar\u003e 设置转义字符 --fields-terminated-by \u003cchar\u003e 设置字段分隔符 --lines-terminated-by \u003cchar\u003e 设置行尾字符 --mysql-delimiters 使用 MySQL 的默认分隔符集：字段：, 行：\\n 转义符：\\ 可选封闭符：' --optionally-enclosed-by \u003cchar\u003e 设置字段包围字符 Sqoop 会自动生成代码来解析和解释包含要导出回数据库的数据的文件记录。如果这些文件是使用非默认分隔符创建的（逗号分隔的字段和换行符分隔的记录），则应再次指定相同的分隔符，以便 Sqoop 可以解析您的文件。 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:5:5","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r代码生成参数 争论 描述 --bindir \u003cdir\u003e 编译对象的输出目录 --class-name \u003cname\u003e 设置生成的类名。这将覆盖 --package-name。与 结合使用时 --jar-file，设置输入类。 --jar-file \u003cfile\u003e 禁用代码生成；使用指定的 jar --outdir \u003cdir\u003e 生成代码的输出目录 --package-name \u003cname\u003e 将自动生成的类放入此包中 --map-column-java \u003cm\u003e 覆盖配置列的从 SQL 类型到 Java 类型的默认映射。 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:5:6","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":null,"content":"\r使用例子\rHDFS导出到MySQL sqoop export \\ --connect jdbc:mysql://192.168.109.1:3306/userdb \\ --username root \\ --password root \\ --table employee \\ --export-dir /emp/emp_data 更新导出只更新操作 sqoop export \\ --connect jdbc:mysql://192.168.109.1:3306/userdb \\ --username root --password root \\ --table updateonly \\ --export-dir /updateonly_2/ \\ # 更新导出 --update-key id \\ --update-mode updateonly # 只更新操作 更新插入模式 sqoop export \\ --connect jdbc:mysql://192.168.8.108:3306/ipv6_locate?serverTimezone=Asia/Shanghai\\\u0026useUnicode=true\\\u0026characterEncoding=utf8\\\u0026autoReconnect=true\\\u0026failOverReadOnly=false \\ # 有时候可能会出现中文乱码问题，需要添加编码集 --username root \\ --password passwd01 \\ --table mall_rpt_ip_with_scene \\ # 目标mysql中的表名 --update-key \"id\" \\ # 指定目标表的主键 --update-mode allowinsert \\ # 指定目标表的更新模式 --input-null-string '\\\\N' \\ --input-null-non-string '\\\\N' \\ --input-fields-terminated-by '\\001' \\ # hive中字段间的分隔符 --input-lines-terminated-by \"\\n\" \\ # hive中行与行之间的分隔符 --export-dir hdfs://cdh1.host.com:8020/user/hive/warehouse/wsp_test.db/mall_rpt_ip_with_scene \\ # hive表存放的位置 --m 1 # 并行度 ","date":"2024-06-06","objectID":"/bigdata/hadoop/20240606150541/:5:7","tags":["sqoop"],"title":"sqoop使用文档","uri":"/bigdata/hadoop/20240606150541/"},{"categories":["大数据"],"content":"Kerberos 是一种身份认证协议，被广泛运用在大数据生态中，甚至可以说是大数据身份认证的事实标准。本文将详细说明 Kerberos 原理。 ","date":"2024-05-11","objectID":"/lang/docker/20240511160713/:0:0","tags":null,"title":"一文搞懂Kerberos","uri":"/lang/docker/20240511160713/"},{"categories":["大数据"],"content":"\r1 二、Kerberos 是什么？Kerberos 一词来源于古希腊神话中的 Cerberus —— 守护地狱之门的三头犬。 一句话来说，Kerberos是一种基于加密Ticket的身份认证协议。 主要有三部分组成： Key Distribution Center (即KDC) Client Service ![[asserts/Pasted image 20240511160914.png]]客户端会先访问两次KDC，然后再访问目标Service，如：HTTP服务。 ","date":"2024-05-11","objectID":"/lang/docker/20240511160713/:1:0","tags":null,"title":"一文搞懂Kerberos","uri":"/lang/docker/20240511160713/"},{"categories":["大数据"],"content":"\r2 三、Kerberos 基本概念","date":"2024-05-11","objectID":"/lang/docker/20240511160713/:2:0","tags":null,"title":"一文搞懂Kerberos","uri":"/lang/docker/20240511160713/"},{"categories":["大数据"],"content":"\r2.1 3.1 基本概念 Principal：大致可以认为是 Kerberos 世界的用户名，用于标识身份。principal 主要由三部分构成：primary，instance(可选) 和 realm。包含 instance 的principal，一般会作为server端的principal，如：NameNode，HiverServer2，Presto Coordinator等；不含有 instance 的principal，一般会作为 客户端的principal，用于身份认证。例子如下图所示： Keytab：“密码本”。包含了多个 principal 与密码的文件，用户可以利用该文件进行身份认证。 Ticket Cache：客户端与 KDC 交互完成后，包含身份认证信息的文件，短期有效，需要不断renew。 Realm：Kerberos 系统中的一个namespace。不同 Kerberos 环境，可以通过 realm 进行区分。 ","date":"2024-05-11","objectID":"/lang/docker/20240511160713/:2:1","tags":null,"title":"一文搞懂Kerberos","uri":"/lang/docker/20240511160713/"},{"categories":["大数据"],"content":"\r2.2 3.2 KDCKey Distribution Center（即 KDC）, 是 Kerberos 的核心组件，主要由三个部分组成： Kerberos Database: 包含了一个 Realm 中所有的 principal、密码与其他信息。（默认：Berkeley DB） Authentication Service(AS): 进行用户信息认证，为客户端提供 Ticket Granting Tickets(TGT)。 Ticket Granting Service(TGS): 验证 TGT 与 Authenticator，为客户端提供 Service Tickets。 ","date":"2024-05-11","objectID":"/lang/docker/20240511160713/:2:2","tags":null,"title":"一文搞懂Kerberos","uri":"/lang/docker/20240511160713/"},{"categories":["大数据"],"content":"\r3 四、Kerberos 原理在深入了解 Kerberos 原理之前，先介绍一下 Kerberos 协议的几个大前提，帮助大家理解： Kerberos 基于 Ticket 实现身份认证，而非密码。如果客户端无法利用本地密钥，解密出 KDC 返回的加密Ticket，认证将无法通过。 客户端将依次与 Authentication Service, Ticket Granting Service 以及目标Service进行交互，共三次交互。 客户端与其他组件交互是，都将获取到两条信息，其中一条可以通过本地密钥解密出，另外一条将无法解密出。 客户端想要访问的目标服务，将不会直接与KDC交互，而是通过能否正确解密出客户端的请求来进行认证。 5. KDC Database 包含有所有 principal 对应的密码。 6. Kerberos 中信息加密方式一般是对称加密（可配置成非对称加密）。 下面，我们将以客户端访问 http 服务为例，解释整个认证过程。 ","date":"2024-05-11","objectID":"/lang/docker/20240511160713/:3:0","tags":null,"title":"一文搞懂Kerberos","uri":"/lang/docker/20240511160713/"},{"categories":["大数据"],"content":"\r3.1 4.1 客户端与 Authentication Service第一步，客户端通过kinit USERNAME或其他方式，将客户端ID, 目标HTTP服务ID, 网络地址（可能是多个机器的IP地址列表，如果想在任何机器上使用，则可能为空），以及TGT有效期的寿命等信息发送给 Authentication Service。 第二步，Authentication Server 将检查客户端ID是否在KDC数据库中。 如果 Authentication Server 检查操作没有异常，那么KDC将随机生成一个 key，用于客户端与 Ticket Granting Service(TGS) 通信。这个Key，一般被称为 TGS Session Key。随后 Authentication Server 将发送两条信息给客户端。示意图如下： 其中一条信息被称为TGT，由TGS的密钥加密，客户端无法解密，包含客户端ID, TGS Session Key等信息。另一条信息由客户端密钥加密，客户端可以正常解密，包含目标 HTTP 服务ID，TGS Session Key等信息。 第三步，客户端利用本地的密钥解密出第二条信息。如果本地密钥无法解密出信息，那么认证失败。示意图如下： ","date":"2024-05-11","objectID":"/lang/docker/20240511160713/:3:1","tags":null,"title":"一文搞懂Kerberos","uri":"/lang/docker/20240511160713/"},{"categories":["大数据"],"content":"\r3.2 4.2 客户端与 Ticket Granting Service这时候，客户端有了 TGT（由于本地没有TGS的密钥，导致无法解密出其数据）与 TGS Session Key。 第四步，客户端将: “无脑”将 AS 发送过来的TGT（由TGS密钥加密）转发给TGS 将包含自身信息的Authenticator(由TGS Session Key加密)发送给TGS 第五步，TGS 将利用 自身的密钥从TGT中解密出TGS Session Key，然后利用TGS Session Key从Authenticator 中解密出客户端的信息。 TGS 解密出所有信息后，将进行身份检查，进行认证： 将客户端ID与TGT的客户端ID进行比较 比较来自 Authenticator 的时间戳和TGT的时间戳 (典型的Kerberos系统的容忍度是2分钟，但也可以另行配置) 检查TGT是否过期 检查Authenticator是否已经在TGS的缓存中（为了避免重放攻击） 当所有检查都通过后， TGS 随机生成一个 Key 用于后续客户端与 HTTP 服务交互时进行通信加密使用，即 HTTP Session Key。同样地，TGS 将发送两条信息给客户端: 其中一条是 HTTP Ticket，由 HTTP 服务的密钥进行加密；另一条则由TGS Session Key加密，包含了客户端信息与时间戳。 第六步，客户端将利用TGS Session Key解密出其中一条信息，另一条信息由于是由目标HTTP服务加密，无法解密。 ","date":"2024-05-11","objectID":"/lang/docker/20240511160713/:3:2","tags":null,"title":"一文搞懂Kerberos","uri":"/lang/docker/20240511160713/"},{"categories":["大数据"],"content":"\r3.3 4.3 客户端与 HTTP Service这时候，客户端有了HTTP Ticket（由于本地没有HTTP服务的密钥，导致无法解密出其数据）与 HTTP Session Key。 第七步，客户端将: “无脑”将 AS 发送过来的 HTTP Ticket（由HTTP 密钥加密）转发给目标 http 服务。 将包含自身信息的Authenticator(由HTTP Session Key加密)发送给 http 服务。 第八步，HTTP服务首先利用自身的密钥解密出 HTTP Ticket 的信息，得到 HTTP Session Key；随后，利用HTTP Session Key解密出用户的Authenticator信息。 信息解密完成后，HTTP 服务同样需要做一些信息检查： 将 Authenticator 中的客户端ID与HTTP Ticket中的客户端ID进行比较 比较来自 Authenticator 的时间戳和 HTTP Ticket 的时间戳 (典型的 Kerberos 系统对差异的容忍度是 2 分钟，但也可以另行配置) 检查Ticket是否过期 检查 Authenticator 是否已经在HTTP服务器的缓存中（为了避免重播攻击） 至此，所有的认证过程通过，客户端即可与远程HTTP服务完成了身份认证，可以进行后续的信息通信。 ","date":"2024-05-11","objectID":"/lang/docker/20240511160713/:3:3","tags":null,"title":"一文搞懂Kerberos","uri":"/lang/docker/20240511160713/"},{"categories":["大数据"],"content":"\r4 五、Kerberos 的优势 密码无需进行网络传输。基于 Ticket 实现身份认证，保障密钥安全性。 双向认证。整个认证过程中，不仅需要客户端进行认证，待访问的服务也需要进行身份认证。 高性能。一旦Client获得用过访问某个Server的Ticket，该Server就能根据这个Ticket实现对Client的验证，而无须KDC的再次参与。 ","date":"2024-05-11","objectID":"/lang/docker/20240511160713/:4:0","tags":null,"title":"一文搞懂Kerberos","uri":"/lang/docker/20240511160713/"},{"categories":null,"content":"\r0.1 docker命令官方文档docker | Docker Docs ","date":"2024-05-10","objectID":"/lang/docker/20240510103849/:0:1","tags":["docker"],"title":"docker使用常用命令","uri":"/lang/docker/20240510103849/"},{"categories":null,"content":"\r0.2 代理配置/etc/docker/daemon.json 文件写入下面内容(文件不存在新建) { \"registry-mirrors\": [ \"https://hub-mirror.c.163.com\", \"https://mirror.baidubce.com\" ] } 重启docker服务 sudo systemctl daemon-reload sudo systemctl restart docker sudo service docker stop sudo service docker start ","date":"2024-05-10","objectID":"/lang/docker/20240510103849/:0:2","tags":["docker"],"title":"docker使用常用命令","uri":"/lang/docker/20240510103849/"},{"categories":null,"content":"\r1 docker基础命令","date":"2024-05-10","objectID":"/lang/docker/20240510103849/:1:0","tags":["docker"],"title":"docker使用常用命令","uri":"/lang/docker/20240510103849/"},{"categories":null,"content":"\r1.1 增 docker pull 镜像文件名 #下载docker镜像 docker run hello-world #运行镜像文件,生成docker容器实例,docker run命令,会自动下载不存在的镜像 #容器是随时创建,随时删除的,轻量级,每次docker run 都会生成新的容器记录 #docker容器进程,如果没有在后台运行的话,就会立即挂掉, (容器中必须有正在工作的进程) #运行一个活着的容器进程 docker run -d centos /bin/sh -c \"while true;do echo '你个糟老头子,不听课,坏得很'; sleep 1;done\" #运行镜像 -d 后台运行的意思 centos 指的是镜像文件名 /bin/sh 要在这个容器内运行的命令,指定的解释器 shell解释器 -c 指定一段shell代码 #进入容器空间内的命令 docker exec -it 容器id /bin/bash #进入容器空间内 -i 交互式命令操作 -t 开启一个新的终端 exit 退出虚拟容器 #运行一个ubuntu容器 docker run -it ubuntu ","date":"2024-05-10","objectID":"/lang/docker/20240510103849/:1:1","tags":["docker"],"title":"docker使用常用命令","uri":"/lang/docker/20240510103849/"},{"categories":null,"content":"\r1.2 删 docker rmi 镜像名字/镜像id #删除镜像文件 docker rm 容器id/容器进程名字 #删除容器记录 docker rmi -f #强制删除镜像文件 docker rm `docker ps -aq` #批量删除容器记录,只能删除挂掉的容器记录 ","date":"2024-05-10","objectID":"/lang/docker/20240510103849/:1:2","tags":["docker"],"title":"docker使用常用命令","uri":"/lang/docker/20240510103849/"},{"categories":null,"content":"\r1.3 改 #docker容器进程的启停命令 docker start 容器id docker stop 容器id ","date":"2024-05-10","objectID":"/lang/docker/20240510103849/:1:3","tags":["docker"],"title":"docker使用常用命令","uri":"/lang/docker/20240510103849/"},{"categories":null,"content":"\r1.4 查 docker search 镜像文件名字 #搜索镜像文件 docker images #列出当前所有的镜像文件 docker ps #列出当前记录正在运行的容器进程 docker ps -a #列出所有的容器进程,以及挂掉的 docker logs 容器id #查看容器内的日志信息 docker logs -f 容器id #检测容器内的日志 ","date":"2024-05-10","objectID":"/lang/docker/20240510103849/:1:4","tags":["docker"],"title":"docker使用常用命令","uri":"/lang/docker/20240510103849/"},{"categories":null,"content":"\r1.5 容器镜像\r1.5.1 提交自己开发的dokcer镜像文件 docker run -it centos /bin/bash #进入一个纯净的centos容器空间内,此时是最小化安装的系统,没有vim 没有py3 在容器空间内 yum install vim ,然后退出容器 提交容器为新的镜像文件 # docker commit 容器进程id 镜像文件的名字 docker commit 419 s21docker-centos-vim 导出docker镜像 docker save 镜像文件名 \u003e /opt/s21-centos-vim.tar.gz 导入镜像文件 docker load \u003c 同事给你发的镜像文件 推送镜像只dockerhub # 仓库管理 创建dockerhub账号: # 修改镜像之后保存镜像: docker commit b573392cad1a mysql:5.7 # 修改镜像标签: docker tag mysql:5.7 bigox/mysql:5.7 # 登录docker: docker login # 推送镜像: docker push bigox/mysql:5.7 ","date":"2024-05-10","objectID":"/lang/docker/20240510103849/:1:5","tags":["docker"],"title":"docker使用常用命令","uri":"/lang/docker/20240510103849/"},{"categories":null,"content":"\r1.6 常用docker命令 1.6.1 docker容器信息 ##查看docker容器版本 docker version ##查看docker容器信息 docker info ##查看docker容器帮助 记不住docker命令可以经常使用docker --help查看 docker --help 1.6.2 镜像的操作 对镜像的操作，可使用镜像名、镜像长ID或短ID ### 镜像查看 docker image list ##只显示镜像ID docker images -q ##含中间映像层 docker images -qa ### 镜像搜索 docker search mysql # 镜像下载 docker pull redis # 下载仓库里的所有redis镜像 docker pull -a redis # 镜像删除 docker rmi redis docker rmi -f redis # 删除多个镜像 docker rmi -f redis tomcat nginx # 删除本地多个镜像 docker rmi -f $(docker images -q) # 构建镜像 ##（1）编写dockerfile cd /docker/dockerfile vim mycentos ##（2）构建docker镜像 docker build -f /docker/dockerfile/mycentos -t mycentos:1.1 ","date":"2024-05-10","objectID":"/lang/docker/20240510103849/:1:6","tags":["docker"],"title":"docker使用常用命令","uri":"/lang/docker/20240510103849/"},{"categories":null,"content":"\r1.7 容器操作 # 容器启动 ##新建并启动容器，参数：-i 以交互模式运行容器；-t 为容器重新分配一个伪输入终端；--name 为容器指定一个名称 docker run -i -t --name mycentos ##后台启动容器，参数：-d 已守护方式启动容器 docker run -d mycentos # 查看容器 ##查看正在运行的容器 docker ps ##查看正在运行的容器的ID docker ps -q ##查看正在运行+历史运行过的容器 docker ps -a ##显示运行容器总文件大小 docker ps -s ##显示最近创建容器 docker ps -l ##显示最近创建的3个容器 docker ps -n 3 ##不截断输出 docker ps --no-trunc # 容器进程 ##列出redis容器中运行进程 docker top redis ##查看所有运行容器的进程信息 for i in `docker ps |grep Up|awk '{print $1}'`;do echo \\ \u0026\u0026docker top $i; done # 容器日志 docker logs rabitmq ##查看redis容器日志，参数：-f 跟踪日志输出；-t 显示时间戳；--tail 仅列出最新N条容器日志； docker logs -f -t --tail=20 redis ##查看容器redis从2019年05月21日后的最新10条日志。 docker logs --since=\"2019-05-21\" --tail=10 redis # 容器的进入和退出 ##使用run方式在创建时进入 docker run -it centos /bin/bash ##关闭容器并退出 exit ##直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false 确保CTRL-D或CTRL-C不会关闭容器 docker attach --sig-proxy=false centos ##在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i 即使没有附加也保持STDIN 打开；-t 分配一个伪终端 docker exec -i -t centos /bin/bash ##以交互模式在容器中执行命令，结果返回到当前终端屏幕 docker exec -i -t centos ls -l /tmp ##以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端 docker exec -d centos touch cache.txt # 容器的停止和删除 ##停止一个运行中的容器 docker stop redis ##杀掉一个运行中的容器 docker kill redis ##删除一个已停止的容器 docker rm redis ##删除一个运行中的容器 docker rm -f redis ##删除多个容器 docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm ## -l 移除容器间的网络连接，连接名为 db docker rm -l db ## -v 删除容器，并删除容器挂载的数据卷 docker rm -v redis # 容器和主机间的数据拷贝 ##将rabbitmq容器中的文件copy至本地路径 docker cp rabbitmq:/[container_path] [local_path] ##将主机文件copy至rabbitmq容器 docker cp [local_path] rabbitmq:/[container_path]/ ##将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别） docker cp [local_path] rabbitmq:/[container_path] ","date":"2024-05-10","objectID":"/lang/docker/20240510103849/:1:7","tags":["docker"],"title":"docker使用常用命令","uri":"/lang/docker/20240510103849/"},{"categories":null,"content":"[TOC] ","date":"2024-05-08","objectID":"/db/20240508165000/:0:0","tags":null,"title":"软考知识点","uri":"/db/20240508165000/"},{"categories":null,"content":"\r1 嵌入式SQL嵌入式SQL中通过主变量实现主语言和SQL语言间进行参数传递； SQL语句的执行状态通过sqlca，传递给主语言来进行流程控制； 对于返回结果为多条记录的sql语句，通过游标来由主语言逐条处理。 执行类型分析和检查：分析程序的类型系统，并检查程序是否违反类型规则(程序中变量和表达式的类型)， 编译的过程： 词法分析，将源代码分解为由单词组成的符号流的过程。 语法分析，语法分析，根据语法规则检查符号流的正确性，并生成语法树的过程 语义分析，检查程序的语义是否正确，并进行类型检查，是否符合语言规范 中间代码生成，根据语法树生成中间代码的过程，中间代码是一种抽象的机器代码与目标机器无关。 DFA能识别什么？ ![[asserts/Pasted image 20240515104903.png]] 主存主要采用动态随机存储器DRAM Cache采用静态随机存储器SRAM EEPROM是电擦除可编程的只读存储器 ![[asserts/Pasted image 20240515105946.png]] 入侵检测技术 海明码 系统页面大小为 ","date":"2024-05-08","objectID":"/db/20240508165000/:1:0","tags":null,"title":"软考知识点","uri":"/db/20240508165000/"},{"categories":null,"content":"\r1.1 虚拟内存逻辑地址为 0001110100010110 逻辑地址内存分两部分：虚拟页号+页内偏移 虚拟页号：虚拟页号逻辑地址的最高位部分 页内偏移：逻辑地址的低位部分, 先根据页大小计算 页内地址长度需要多少位来表示 页大小为4K 4*2^10=2^12 低12位为页内偏移，页内地址 剩下的为页号 ![[asserts/Pasted image 20240522125000.png]] ","date":"2024-05-08","objectID":"/db/20240508165000/:1:1","tags":null,"title":"软考知识点","uri":"/db/20240508165000/"},{"categories":null,"content":"\r1.2 进程管理","date":"2024-05-08","objectID":"/db/20240508165000/:1:2","tags":null,"title":"软考知识点","uri":"/db/20240508165000/"},{"categories":null,"content":"\r1.3 数据结和算法 广义表的长度：广义表中原子或子表的数量， 广义表 {{a,b,c}} 中只有一个子表 {a,b,c}，因此它的长度为 1。 {a,{b,c,d}} 中，它包含一个原子和一个子表，因此该广义表的长度为 2 广义表的深度：观察表中所包含括号的层数间接得到 1.3.1 二叉树 堆： 通常是完全二叉树 最大堆：父节点的值比子节点要大 最小堆：父节点的值比子节点小 总结点 = 度为0 + 度为1 + 度为2(叶子节点-1) 叶子节点度为0 在二叉树中，总结点的数量等于度为0的结点数加度为1的结点数加度为2的结点数。已知二叉树中有70个叶子结点和80个度为1的结点，由于叶子结点的度数为0，度为2的结点数等于叶子结点数减1，即个。 1.3.2 排序![[asserts/Pasted image 20240522134301.png]] ","date":"2024-05-08","objectID":"/db/20240508165000/:1:3","tags":null,"title":"软考知识点","uri":"/db/20240508165000/"},{"categories":null,"content":"\r1.4 数据库\r1.4.1 数据库设计![[asserts/Pasted image 20240522141345.png]] 模式：数据库的逻辑结构和数据组织方式 外模式：数据库系统的最外层，用户与数据库系统交互的接口，不同的用户或应用程序可以有不同的外模式。 内模式：数据库系统的最内层，描述了数据在物理介质上的存储结构和存取方法 数据在磁盘上的存储结构 存储记录的格式和排列 索引，数据压缩等技术 数据的独立性： 物理独立性：数据库的内模式发生改变时，数据的逻辑结构不变 数据独立性：外模式和模式之间的映射 数据的独立性是由DBMS的二级映像功能来保证的。数据的独立性包括数据的物理独立性和数据的逻辑独立性。数据的物理独立性是指当数据库的内模式发生改变时，数据的逻辑结构不变。为了保证应用程序能够正确执行，需要通过修改概念模式/内模式之间的映像。数据的逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构发生变化后，用户程序也可以不修改。但是，为了保证应用程序能够正确执行，需要修改外模式/概念模式之间的映像。 ","date":"2024-05-08","objectID":"/db/20240508165000/:1:4","tags":null,"title":"软考知识点","uri":"/db/20240508165000/"},{"categories":null,"content":"\r1.5 关系泛式\r1.5.1 几种泛式 泛式 概念 判断方法 1NF 每一个属性都是不可分割的原子值 每一个字段仅包含一个值 每一列都是原子的，不能包含子表或数组 2NF 每一个非主属性完全依赖于主键(消除部分依赖) - 满足1NF - 非主属性完全依赖与整个主键，而不是主键的一部分 - 若存在部分依赖(某些非主属性依赖主键的一部分) 分解为更小的表 3NF 不存在非主属性对候选码的传递依赖 满足2NF 没有非主属性通过另一个非主属性，间接依赖主键 存在传递依赖，则需要将其分解我更小的表 BCNF 没有传递依赖和部分依赖， 每一个属性（或属性组合）若能决定其他属性，则该属性（或属性组合）是候选键 4NF 没有多值依赖 满足3NF 确保关系中没有多值依赖（即一个属性集的值集合与另一个属性集的值集合相互独立） 1NF：消除重复组，确保每个属性值是原子的。 2NF：在1NF的基础上，消除部分依赖，确保每个非主属性完全依赖于主键。 3NF：在2NF的基础上，消除传递依赖，确保每个非主属性直接依赖于主键。 BCNF：在3NF的基础上，消除非候选键的决定因素，确保每个决定因素都是候选键。 4NF：在BCNF的基础上，消除多值依赖，确保没有多值依赖。 1.5.2 关系代数 选择（Selection, σ）：从关系中选出满足特定条件的元组。 记号：σ条件(关系) 示例：σage \u003e 30(Employees) 投影（Projection, π）：从关系中选出特定的属性列，去除重复的元组。 记号：π属性列表(关系) 示例：πname, age(Employees) 并（Union, ∪）：合并两个关系，包含所有在两个关系中的元组，去除重复。 记号：R ∪ S 差（Difference, −）：获取属于第一个关系但不属于第二个关系的元组。 记号：R − S 笛卡尔积（Cartesian Product, ×）：将两个关系中的每一个元组合并形成一个新的元组。 记号：R × S 连接（Join, ⨝）：根据特定条件将两个关系中的元组合并形成一个新的元组。 记号：R ⨝条件 S 自然连接（Natural Join, ⨝）：在两个关系中查找相同属性名的列，并自动进行连接。 记号：R ⨝ S 除（Division, ÷）：在关系中查找那些在另一个关系中的所有元组都有匹配的元组。 记号：R ÷ S 1.5.3 关系元组演算常用的查询语言：域关系演算 元祖关系演算，关系代数 公式和符号的意思： 元组变量表示关系中的元组 如T ∈ R表示元组T属于关系R，T.A = T.B表示元组T的属性A等于属性B。 逻辑运算符 ∧(和)、∨或、¬ 非 绑定变量 在公式中被量词绑定的变量 比如，∃T (T ∈ R ∧ T.A = 5)中，T是绑定变量。 示例 # 查询年龄大于30的员工的名称和年龄 { T | T ∈ Employee ∧ T.Age \u003e 30 } **查询工资高于50000的员工的名字** { T.Name | ∃T (T ∈ Employee ∧ T.Salary \u003e 50000) } # 域关系演算 一个关系`Employee(EID, Name, Age, Salary)` -- 查询年龄大于30的员工的名称和年龄 { \u003cn, a\u003e | ∃e ∃s (Employee(e, n, a, s) ∧ a \u003e 30) } ","date":"2024-05-08","objectID":"/db/20240508165000/:1:5","tags":null,"title":"软考知识点","uri":"/db/20240508165000/"},{"categories":null,"content":"\r1.6 分布式系统CAP分布式系统的基本原理代表三个关键属性：一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance） 五个答题考点： 数据库概念结构设计 关系理论 泛式和主键候选键 函数依赖 三泛式 四泛式 泛式分解 SQL相关 事务的概念、锁死、并发 数据备份和故障恢复 数据库日志文件 ","date":"2024-05-08","objectID":"/db/20240508165000/:1:6","tags":null,"title":"软考知识点","uri":"/db/20240508165000/"},{"categories":null,"content":"\r1.7 信息安全 主动攻击 攻击者干扰系统或网络的正常运行，通过修改、破坏或伪造数据，获取未授权的访问权限或恶意操作 拒绝服务攻击 DDOS DOS: 攻击者通过发送大量请求，消耗系统资源，使系统无法正常提供服务 中间人攻击MITM: sql注入 钓鱼攻击 被动攻击 不干扰系统的正常运行，隐蔽性，无破坏性，信息收集 流量分析，窃听，被动扫描 中国自主研发的3G通信标准是 TD-SCDMA 宏病毒一般感染 doc 为扩展名的文件 数字信封技术： 生成对称密钥 数据加密 对称密钥加密 传输加密数据和加密密钥 对称密钥解密 数据解密 计算机病毒： 文件型病毒 感染可执行文件 引导型病毒 影响软盘或硬盘的引导扇区 目录型病毒 修改硬盘上的所有文件的地址 宏病毒 使用某些程序创建出来的文本文档，数据库，电子表格等文件 防火墙的工作层次： 工作层次高，效率低，安全性高 受保护程度：从高到低 内网 DMZ 外网 ","date":"2024-05-08","objectID":"/db/20240508165000/:1:7","tags":null,"title":"软考知识点","uri":"/db/20240508165000/"},{"categories":null,"content":"\r1.8 项目管理无主程序员组：适合开发小型项目 创新型项目， 确定性比较小的项目 ISO软件质量模型： 软件质量的6大特性：功能性、可靠性、易用性、效率、维护性、可移植性 软件质量的27个子特性： 功能性：适合性、准确性、互操作性、安全性、功能性的依从性 可靠性：成熟性、容错性、可恢复性、可靠性的依从性 易用性：易理解、易学习、易操作、吸引性、可使用性的依从性 效率：时间特性、资源特性、效率的依从性 维护性：易分析性、稳定性、易变更性、易测试性、可维护性的依从性 可移植性：适应性、易安装型、遵循性易替换性、可移植性的依从性 RUP：统一软件开发过程 角色、活动、制品和工作流4种重要的模型元素 统一过程模型： 关键特点：迭代和增量开发 基于用例的需求驱动 架构驱动 风险驱动 阶段 初始阶段 细化阶段 构建阶段 移交阶段 传统工程模型： 瀑布模型是最早出现的过程模型，它将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，形如瀑布流水，最终得到软件产品，主要的阶段包括需求分析、系统设计、详细设计、编码、单元测试、集成测试、系统测试、系统提交等。 v模型是对瀑布模型的一种改进模型，由于其模型构图形似字母v，所以又称为软件测试的V模型。V模型中，增加了测试环节的回溯验证，一般情况下，单元测试所对应的是详细设计环节；集成测试对应概要设计环节；系统测试对应需求分析环节；验收测试对应用户原始需求。 原型化模型:。原型化模型首先是建造一个快速原型，在充分了解和确认后，在原型基础上开发出用户满意的产品。 螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。 增量模型：把软件产品作为一系列的增量构建来设计，编码，集成和测试，可以在增量开发过程中逐步理解需求 软件设计： 概要设计阶段 详细设计阶段 结构化设计方法： 概要设计阶段：软件体系结构的设计，数据设计和接口设计 详细设计阶段：数据结构和算法的设计 面相对象的设计方法： 概要设计阶段：体系结构设计，初步的类设计、数据设计，结构设计 详细设计阶段：构件设计 数据流图： 建模的时候应遵循自顶向下，从抽象到具体的建模思想。 描述数据的处理流程 底层数据流图描述了系统的输入输出 加工描述了数据流的转换 软件工程方法：进行软件开发，涉及到方法、工具和过程等要素。 项目风险：风险的优先级根据风险暴露 指标来表示，=风险影响(当风险发生时造成的损失) * 风险概率(风险发生的可能性) 项目风险：预算，进度，人员资源以及客户相关的问题 技术风险：设计，实现，对接，测试和维护未提 业务风险：建立一个无人想要的优秀产品风险，失去预算，人员承诺的风险 商业风险：市场风险，策略风险，管理风险和预算风险 UML图： 统一建模语言 用例图 描述系统的功能需求以及系统与外部用户之间的交互 类图 描述系统中的类及其属性、方法和类之间的关系 对象图：描述系统在某一时刻的对象实例及其关系 序列图：描述对象之间的交互顺序，强调时间顺序 活动图：类似于流程图 状态图：描述对象状态变化以及时间如何导致状态的转换 组件图：描述系统 的物理组件以及相互关系 部署图：描述系统在物理硬件上的部署结构 干货！14种uml图类型及示例 (boardmix.cn) ","date":"2024-05-08","objectID":"/db/20240508165000/:1:8","tags":null,"title":"软考知识点","uri":"/db/20240508165000/"},{"categories":null,"content":"0 行首 $ 行尾 i 当前游标插入 A 行尾追加 d2w 删除两个单词 dd 删除一行 2dd 删除两行 u撤销 ctrl+r 重新执行 put ce 删除单词并修改 cc 删除某行并修改 c$ 删除到行为并修改 c0 删除到行首并修改 %快速找成对的括号 :s/thee/the/g 将一行的thee替换为 the ","date":"2024-04-28","objectID":"/posts/20240428183407/:0:0","tags":null,"title":"Vim使用技巧大全","uri":"/posts/20240428183407/"},{"categories":null,"content":"\r2 Java核心基础 我想和自己说：学习是反复的过程，学习新知识的时候要仔仔细细阅读，错过一个关键词，可能对知识就会有偏差的理解。如果现在没有心情，收藏起来，后面用到的时候再仔细看。希望有帮助。 ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:0:0","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r1 2.0 基本概念先了解","date":"2024-04-26","objectID":"/lang/java/20240426133928/:1:0","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r1.1 类 类是Java中的基本编程单元，用于描述对象的属性和行为。通过实例化类，可以创建对象 类是封装了数据和方法的结构 Java中，类概念非常核心和基础，用于组织和构建整个程序。 类名和文件名是一致的(后面讲class关键词的时候会细聊) ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:1:1","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r1.2 接口 接口是一种抽象的类型，它定义了一组方法的签名，但不提供方法的具体实现。 在后面写面向对象章节的时候，会对类和接口进行详解。 ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:1:2","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r1.3 变量 在程序执行过程中，值可以在某个范围内发生改变的量。 变量要明确保存数据的数据类型 ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:1:3","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r1.4 包 将相关的类和接口组织在一起，一个包下面可以创建很多类文件和接口文件。直接引用功能包，可能节省代码量。 ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:1:4","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r1.5 常量 在程序执行过程中，值不发生改变的量。 ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:1:5","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r2 2.1 注释什么是注释，就是对程序进行解释和说明的文字 单行注释 //单行注释 多行注释 /* 多行注释 */ 文档注释 /** * 这是一个文档注释示例 * 它通常包含有关类、方法或字段的详细信息 */ public class MyClass { // 类的成员和方法 } ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:2:0","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r3 2.2 关键字被Java语言赋予了特殊含义的单词，在idea中会高亮显示，学习完基础知识后，可以再回过头 看看，对每个关键字的用法要熟悉，不然就是没入门 关键字官方文档 https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html 用于定义数据类型的关键字 class 类的标识 class HelloWorld {}, class是Java程序的基本构建块，它包含了数据和方法(死记就行)。Java文件名必须和类名保持一致，为了编译时能够正确识别和定位类(规定，死记就行); 如果一个文件中包含多个类，只能有一个类声明为 public，并且文件名必须与public类一致 public class MyClass { // 主类 文件名必须是 MyClass.java，程序入口点所在的类，必须要用public修饰，为了执行程序的时候，能够被jvm虚拟机访问到 public static void main(String[] args) { // 入口点 } } class AnotherClass {// 非公共类，在同一个文件中可以有多个} class YetAnotherClass {// 非公共类，建议每个类都存储在独立的文件中，提高代码可读性，如果有多个相关的类，放在同一个包内} interface 接口的标识 interface MyInterface {} enum 枚举 enum Day { SUNDAY, MONDAY, TUESDAY } byte、short、int、long、float、double、char、boolean(八大基本数据类型) void 声明方法没有返回值 流程控制关键字 if else switch case default while do for break continue return 包的关键字 package：将相关的类和接口组织在一起，一个包下面可以创建很多类文件和接口文件，在Java代码中 声明包 package com.example.myapp 包名通常是反转的域名，看到包就知道是什么功能 import 导包，引入其他包中的类 import com.otherpackage.OtherClass 访问权限修饰符关键字 访问控制权限在Java中为了管理类，方法，变量等成员在其他类中的可见性和访问权限。有利于控制代码的封装性，安全性和可维护性 private 私有的 成员只对声明它的类可见，其他类无法访问 protected 受保护访问 同一包内的类和所有子类可见 public: 成员对所有类可见，其他类可以自由访问 扩展：default（package-private）默认访问级别，没有修饰符，成员对统一包内的类可见 类，函数，变量修饰符关键字 abstract用于声明抽象类、抽象方法。抽象类不能被实例化，通常包含抽象方法，子类需要实现这些抽象方法。 什么是抽象类和抽象方法 final 用于声明不可被继承的类 final class FinalClass{};声明不可被重写的方法 final void finalMethod() {};声明不可被修改的变量 final int constantValue = 10; static表名具有静态属性。 // 静态字段属于类，所有类的实例共享相同的静态字段。 // 通过类名直接访问 class Myclass { static int staticField = 10; // 静态方法属于类，不用创建实例，通过类名直接访问 static void staticMethod() { } // 静态块 用于类加载时执行一些初始化操作 static {// 静态块} } synchronized 修饰方法或代码块，确保同一时刻只有同一个线程可以访问修饰的部分 类与类之间关系关键字 extends：用于类之间的继承关系 implements：接口的实现 实例相关关键字 new 创建对象实例 ClassName obj = new ClassName(); this：代表当前对象的引用，在类的方法中使用 this.variable指的是当前对象的成员变量 super：用于调用父类的方法或访问父类的成员 instanceof：用于检查对象是否是特定类的实例 if (obj instanceof ClassName) 异常处理关键字 try、catch、finally、throw、throws 其他修饰符关键字 native strictfp transient volatile assert：断言检查 assert age \u003e= 18 : \"必须年满18岁\"; ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:3:0","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r4 2.3 标识符标识符就是用来给类，接口，方法，变量，包等其名字的规则 类、接口 : 大驼峰命名法,第一个单词大写的是类\\接口 HelloWorld, VariableDemo 变量, 方法: 小驼峰命名法 第一个单词小写的是方法和变量 zhangSanAge, studentName 常量：所有字母都大写 包：所有字母全部都小写 com.baidu ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:4:0","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r5 2.4 数据类型Java是强类型语言，每一个数据都给出了明确的数据类型 基本数据类型(简称: 基本类型) byte, short, char, int, long, float, double, boolean 定义long类型的数据时, 数据后边要加字母L(大小写均可), 建议加L 定义float类型的数据时, 数据后边要加字母F(大小写均可), 建议加F 引用数据类型(简称: 引用类型) - String, 数组, 类, 接口 数据类型转换 不同类型的数据之间可能会进行运算，而这些数据取值范围不同，存储方式不同，直接进行运算可能会造成数据损失，所以需要类型转换 自动(隐式)类型转换 将取值范围小的类型自动提升为取值范围大的类型，byte、short、char--\u003eint--\u003elong--\u003efloat--\u003edouble 强制(显式)类型转换 将取值范围大的类型强制转换成取值范围小的类型. public static void main(String[] args) { double doubleValue = 123.456; int intValue = (int) doubleValue; // 强制将double转换为int System.out.println(\"原始double值：\" + doubleValue); System.out.println(\"强制转换后的int值：\" + intValue); /*原始double值：123.456 强制转换后的int值：123 */ } ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:5:0","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r6 2.5 常量 整数常量 1 小数常量 3.14 字符常量 A B 20(20不是字符，是有两个字符组合成的) 字符串常量 \"abcd\" 布尔常量 true false 空常量 null ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:6:0","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r7 2.6 变量 在程序执行过程中，值可以在某个范围内发生改变的量叫变量 变量要有明确的数据类型 声明方式 数据类型 变量名=初始化的值; int a=10; 先声明，再赋值 int a; a=10; //1. 定义一个类, 类名叫: VariableDemo02 public class VariableDemo02 { //2. 定义main方法, 作为程序的主入口. public static void main(String[] args) { //3. 测试byte类型. //3.1 定义一个byte类型的变量, 变量名叫b, 初始化值为10. byte b = 10; //3.2 将变量b的值打印到控制台上. System.out.println(b); //4. 测试short类型. //4.1 定义一个short类型的变量, 变量名叫s, 初始化值为20. short s = 20; //4.2 将变量s的值打印到控制台上. System.out.println(s); //5. 测试char类型. //5.1 定义一个char类型的变量, 变量名叫c, 初始化值为'A'. char c = 'A'; //5.2 将变量c的值打印到控制台上. System.out.println(c); //6. 测试int类型 int a = 10; System.out.println(a); //7. 测试long类型, 数据后记得加字母L. long lon = 100L; System.out.println(lon); //8. 测试float类型, 数据后边加字母F. float f = 10.3F; System.out.println(f); //9. 测试double类型. double d = 5.21; System.out.println(d); //10. 测试boolean类型. boolean bb = true; System.out.println(bb); } } ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:7:0","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r8 2.7 运算符","date":"2024-04-26","objectID":"/lang/java/20240426133928/:8:0","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r8.1 2.7.1分类 算术运算符 +, -, *, /, %, ++, – 变量前++ ：变量a自己加1，将加1后的结果赋值给b b=++a public static void main(String[] args) { int a = 1; int b = ++a; System.out.println(a);//计算结果是2 System.out.println(b);//计算结果是2 } 变量后++ ：变量a先把自己的值1，赋值给变量b public static void main(String[] args) { int a = 1; int b = a++; System.out.println(a);//计算结果是2 System.out.println(b);//计算结果是1 } 赋值运算符 =, +=, -=, *=, /=, %= 比较(关系)运算符 ==, !=, \u003e, \u003e=, \u003c, \u003c= 逻辑运算符 \u0026\u0026(并且), ||(或者), !(逻辑非), ^(逻辑异或) 异同的意思, 相同为false, 不同为true. public class LogicalOperatorsExample { public static void main(String[] args) { // 逻辑与运算符 (\u0026\u0026) boolean condition1 = true; boolean condition2 = false; // 如果两个条件都为true，则结果为true，否则为false boolean resultAnd = condition1 \u0026\u0026 condition2; System.out.println(\"逻辑与运算符 (\u0026\u0026) 结果：\" + resultAnd); // 逻辑或运算符 (||) // 如果至少一个条件为true，则结果为true，否则为false boolean resultOr = condition1 || condition2; System.out.println(\"逻辑或运算符 (||) 结果：\" + resultOr); // 逻辑非运算符 (!) // 如果条件为true，则结果为false；如果条件为false，则结果为true boolean resultNot = !condition1; System.out.println(\"逻辑非运算符 (!) 结果：\" + resultNot); } } 三元(三目)运算符 (关系表达式) ? 表达式1：表达式2； true执行1表达式，false执行2表达式 public class OperatorDemo04 { public static void main(String[] args) { //1. 定义两个int类型的变量a. b, 初始化值分别为10, 20 int a = 10, b = 20; //2. 通过三元运算符, 获取变量a和b的最大值. int max = a \u003c b ? b : a; //3. 将结果(最大值)打印到控制台上. System.out.println(max); } } ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:8:1","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r9 2.8 流程控制","date":"2024-04-26","objectID":"/lang/java/20240426133928/:9:0","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r9.1 2.8.1 分支结构如果我们想某些代码是在满足条件的情况下, 才能被执行, 此时就需要用到选择结构了, 选择结构也叫分支结构, 主要分为以下两种: if语句, 主要用于范围的判断 switch.case语句, 主要用于固定值的判断. if分支 public class IfExample { public static void main(String[] args) { int num = 10; if (num \u003e 0) { System.out.println(\"数字是正数\"); } else if (num \u003c 0) { System.out.println(\"数字是负数\"); } else { System.out.println(\"数字是零\"); } } } switch分支 public class SwitchExample { public static void main(String[] args) { int dayOfWeek = 3; String dayName; switch (dayOfWeek) { case 1: dayName = \"星期一\"; break; case 2: dayName = \"星期二\"; break; case 3: dayName = \"星期三\"; break; case 4: dayName = \"星期四\"; break; case 5: dayName = \"星期五\"; break; case 6: dayName = \"星期六\"; break; case 7: dayName = \"星期日\"; break; default: dayName = \"无效的日期\"; break; } System.out.println(\"今天是：\" + dayName); } } switch 分支 case穿透，在switch语句中，如果case的后面不写break，将出现case穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。 import java.util.Scanner; public class SwitchDemo08 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"请录入一个月份: \"); int month = sc.nextInt(); switch (month) { case 12: case 1: case 2: System.out.println(\"冬季\"); break; case 3: case 4: case 5: System.out.println(\"春季\"); break; case 6: case 7: case 8: System.out.println(\"夏季\"); break; case 9: case 10: case 11: System.out.println(\"秋季\"); break; default: System.out.println(\"没有这样的日期\"); break; } } } } ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:9:1","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":"\r9.2 2.8.2 循环结构for循环 for(初始化条件1; 判断条件2; 控制条件3) { //循环体4; } for循环求1-100之前偶数和 public class ForDemo04 { public static void main(String[] args) { //1. 定义变量sum, 用来记录数据和. int sum = 0; //2. 通过for循环, 依次获取到1 - 100之间的数字. for (int i = 1; i \u003c= 100; i++) { //3. 判断当前遍历到的数字是否是偶数. if (i % 2 == 0) { //4. 走到这里, 说明是偶数, 累加给变量sum. sum += i; } } //5. 打印结果. System.out.println(\"1 - 100之间的偶数之和是: \" + sum); } } while循环 初始化条件1; while(判断条件2) { //循环体3; //控制条件4; } 例子 public class WhileDemo01 { public static void main(String[] args) { int i = 0; while(i \u003c 10) { System.out.println(\"Hello World!\"); i++; } } } 死循环：永远不结束的循环，循环的判断条件是true for(;;) { } while(true){} do {} while(true) 循环跳转: break continue public class ContinueExample { public static void main(String[] args) { for (int i = 1; i \u003c= 5; i++) { // 如果i为偶数，跳过本次循环 if (i % 2 == 0) { continue; } /*if (i==3) { break; }*/ System.out.println(\"当前数字是：\" + i); } } } 嵌套循环打印99乘法表 public class ForForDemo08 { public static void main(String[] args) { for (int i = 1; i \u003c= 9; i++) { //外循环控制行 for (int j = 1; j \u003c= i; j++) { //内循环控制列 //1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 System.out.print(j + \" * \" + i + \" = \" + i * j + \"\\t\"); } System.out.println(); //内循环执行结束, 意味着一行打印完毕, 记得要换行. } } } ","date":"2024-04-26","objectID":"/lang/java/20240426133928/:9:2","tags":null,"title":"Java核心基础","uri":"/lang/java/20240426133928/"},{"categories":null,"content":" 前言：以初学着的身份，准备在该平台整理点最近学习的知识，方便后续查看相关的技术点，有兴趣的可以一块交流学习。目标用最少的文字，理解最多的知识。不说废话，字字珠玑。 ","date":"2024-04-26","objectID":"/lang/java/20240426111354/:0:0","tags":null,"title":"Java开发工具和前言","uri":"/lang/java/20240426111354/"},{"categories":null,"content":"\r1 1.1 简介 强类型语言、开源、跨平台、多态、多线程、面向对象 完善的异常处理机制，大数据必备的语言 1995年出生，父亲 詹姆斯·高斯林(James Gosling)，2009年被Sun公司收购 兄弟版本 J2SE: 标准版, 也是其他两个版本的基础. 在JDK1.5的时候正式更名为: JavaSE. J2ME: 小型版, 一般用来研发嵌入式程序. 已经被Android替代了. 在JDK1.5的时候正式更名为: JavaME. J2EE: 企业版, 一般开发企业级互联网程序. 在JDK1.5的时候正式更名为: JavaEE ","date":"2024-04-26","objectID":"/lang/java/20240426111354/:1:0","tags":null,"title":"Java开发工具和前言","uri":"/lang/java/20240426111354/"},{"categories":null,"content":"\r2 1.2 Java环境搭建 JDK和JRE区别 JRE: Java运行时环境(Java Runtime Environment) 运行Java的环境 JDK: Java development kit Java开发工具包，包含开发工具和JRE JVM：Java虚拟机(Java Virtual Machine) 和，Java运行环境里要有JVM 目录解释 bin: 存放的是编译器和工具 db: 存数数据 include: 编译本地方法. jre: Java运行时文件 lib: 存放类库文件 src.zip: 存放源代码的 对比这图片看能不能理解每个文件啥意思，不能理解，好好看看上面的介绍 怎么安装和配置path，不同的系统自己动手搜搜吧 ","date":"2024-04-26","objectID":"/lang/java/20240426111354/:2:0","tags":null,"title":"Java开发工具和前言","uri":"/lang/java/20240426111354/"},{"categories":null,"content":"\r3 1.3 程序的开发步骤Java这种静态语言的的开发步骤一般分为 编写：编写源代码，在后缀名为.java的源文件中编写，用idea开发工具 编译:把源代码，编译成计算机能看懂的文件. javacv执行生成.class文件 执行:让计算机运行指定的代码程序 java 运行 直接整idea开发工具，来个hello world的例子 ","date":"2024-04-26","objectID":"/lang/java/20240426111354/:3:0","tags":null,"title":"Java开发工具和前言","uri":"/lang/java/20240426111354/"},{"categories":null,"content":"\r4 1.4 idea开发工具 idea 下载地址 https://www.jetbrains.com/idea/ 激活方式 小程序 码叔资源 上找个激活码激活，或淘宝上买一个激活码 下载好后一路next安装，建议安装路径放D盘，软件是真大 ","date":"2024-04-26","objectID":"/lang/java/20240426111354/:4:0","tags":null,"title":"Java开发工具和前言","uri":"/lang/java/20240426111354/"},{"categories":null,"content":"\r5 1.5用idea开发一个helloworld 新建一个空项目 效果如下 我这一个空文件夹，怎么和Java关联起来呢，要和JDK关联上，才能用写Java代码是吧 打开刚刚新建的项目 有个 项目结构这个东西后面用到的挺多，配置 重点讲讲 project modules libraries的区别 项目：可以执行你刚刚创建那个空项目的名称，SDK(用Java还是什么开发),编译器输出路径 模块：我们新建一个day01的模块，后面可以在这个项目下新增day02 day03的模块，你也可以每天建一个Java项目。 建完之后项目下新增了一个day01的模块，可以在该模块下写代码了(真不容易) 删除模块 删除模块只是这个项目中看不到该模块了，在文件夹中还是存在的 依赖库 ：我这个项目想用第三方的包，咋个办，在这导入就行了，例如连接MySQL的包 搞了这么久，idea上写代码试下吧,day01模块下 src目录下新建一个 Java源代码文件,输入下面的代码 public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } idea使用小tips，idea很强大，这代码太繁琐了不会写怎么办，idea会自动补全的 输入main 按tab键，main方法出来了，sout 按tab键 print语句出来了，更多idea的技巧有机会，单独出一篇文章 运行代码初体验,直接右键run(idea会先编译，然后执行)，终端中会打印出helloworld ","date":"2024-04-26","objectID":"/lang/java/20240426111354/:5:0","tags":null,"title":"Java开发工具和前言","uri":"/lang/java/20240426111354/"},{"categories":null,"content":"\r1 网站 小林coding (xiaolincoding.com)🥓 🍳刘沙河 (bigox.wiki) 🧇爱编程的大丙 (subingwen.cn) ","date":"2024-04-25","objectID":"/web/:1:0","tags":null,"title":"fred导航","uri":"/web/"},{"categories":null,"content":"\r2 常用官方API MySQL官方文档🍕 Hive官方文档🍔 官方API- Spark 2.4.8🍟 ","date":"2024-04-25","objectID":"/web/:2:0","tags":null,"title":"fred导航","uri":"/web/"},{"categories":null,"content":"\r3 工具类 在线Cron表达式生成器 (qqe2.com) RegExr: Learn, Build, \u0026 Test RegEx The-X 在线工具箱 Base64 解码 AES RAS 解码 加密 ","date":"2024-04-25","objectID":"/web/:3:0","tags":null,"title":"fred导航","uri":"/web/"},{"categories":null,"content":"\r4 影视 BTNULL 无名小站🍿 ","date":"2024-04-25","objectID":"/web/:4:0","tags":null,"title":"fred导航","uri":"/web/"},{"categories":null,"content":"\r5 图书 安娜的档案 (annas-archive.org)🧂 ","date":"2024-04-25","objectID":"/web/:5:0","tags":null,"title":"fred导航","uri":"/web/"},{"categories":null,"content":"Hive官方操作手册 ","date":"2024-04-24","objectID":"/bigdata/hive/20240424162208/:0:0","tags":null,"title":"hive常见的命令","uri":"/bigdata/hive/20240424162208/"},{"categories":null,"content":"\r1 Hive特性 hive基于Hadoop，将结构化数据映射为一张数据库表，提供类SQL查询功能 Hive元数据存储,通常存储在关系形数据库中，Hive中的元数据包括(表的名称，列，分区，是否为外部表等属性，数据所在的路径) Hive支持MapReduce、Tez和Spark 三种计算引擎。 数据格式。数据格式用户定义，根据三个属性：列分隔符（通常为空格、”\\t”、”\\x001″）、行分隔符（”\\n”）以及读取文件数据的方法（Hive 中默认有三个文件格式 TextFile，SequenceFile 以及 RCFile） 数据更新。不支持对数据的更新，使用更新可以借助Impala引擎+kudu数据格式 索引。有hive版本支持建立索引，但是各种问题，不建议使用。 Hive中包含的数据模型，DB、Table，External Table，Partition，Bucket db：在hdfs中表现为hive.metastore.warehouse.dir目录下一个文件夹。 table：在hdfs中表现所属db目录下一个文件夹。 external table：与table类似，不过其数据存放位置可以在任意指定路径。 partition：在hdfs中表现为table目录下的子目录。 bucket：在hdfs中表现为同一个表目录下根据hash散列之后的多个文件。 ","date":"2024-04-24","objectID":"/bigdata/hive/20240424162208/:1:0","tags":null,"title":"hive常见的命令","uri":"/bigdata/hive/20240424162208/"},{"categories":null,"content":"\r2 Hive表类型","date":"2024-04-24","objectID":"/bigdata/hive/20240424162208/:2:0","tags":null,"title":"hive常见的命令","uri":"/bigdata/hive/20240424162208/"},{"categories":null,"content":"\r2.1 hive数据类型 Hive的基本数据类型有：TINYINT，SAMLLINT，INT，BIGINT，BOOLEAN，FLOAT，DOUBLE，STRING，TIMESTAMP(V0.8.0+)和BINARY(V0.8.0+)。 Hive的集合类型有：STRUCT，MAP和ARRAY。 Hive表：内部表、外部表、分区表和桶表。 表的元数据保存传统的数据库的表中，当前hive只支持Derby和MySQL数据库。 ","date":"2024-04-24","objectID":"/bigdata/hive/20240424162208/:2:1","tags":null,"title":"hive常见的命令","uri":"/bigdata/hive/20240424162208/"},{"categories":null,"content":"\r2.2 Hive内部表Hive中的内部表和传统数据库中的表在概念上是类似的，Hive的每个表都有自己的存储目录，除了外部表外，所有的表数据都存放在配置在hive-site.xml文件的${hive.metastore.warehouse.dir}/table_name目录下。 -- 创建内部表 CREATE TABLE IF NOT EXISTS students(user_no INT,name STRING,sex STRING, grade STRING COMMOT '班级'）COMMONT '学生表' ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' STORE AS TEXTFILE; ","date":"2024-04-24","objectID":"/bigdata/hive/20240424162208/:2:2","tags":null,"title":"hive常见的命令","uri":"/bigdata/hive/20240424162208/"},{"categories":null,"content":"\r2.3 Hive外部表被external修饰的为外部表（external table），外部表指向已经存在在Hadoop HDFS上的数据，除了在删除外部表时只删除元数据而不会删除表数据外，其他和内部表很像 -- 创建外部表 CREATE EXTERNAL TABLE IF NOT EXISTS students(user_no INT,name STRING,sex STRING, class STRING COMMOT '班级'）COMMONT '学生表' ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' STORE AS SEQUENCEFILE LOCATION '/usr/test/data/students.txt'; ","date":"2024-04-24","objectID":"/bigdata/hive/20240424162208/:2:3","tags":null,"title":"hive常见的命令","uri":"/bigdata/hive/20240424162208/"},{"categories":null,"content":"\r2.4 Hive分区表分区表的每一个分区都对应数据库中相应分区列的一个索引，分区表中的每一个分区对应一个目录文件，即同一个分区的数据存放一个目录下面，所以分区表如果很大，指定分区会速度快很多 比如说，分区表partitinTable有包含nation(国家)、ds(日期)和city(城市)3个分区，其中nation = china，ds = 20130506，city = Shanghai则对应HDFS上的目录为： /datawarehouse/partitinTable/nation=china/city=Shanghai/ds=20130506/。 -- 创建分区表 CREATE TABLE IF NOT EXISTS students(user_no INT,name STRING,sex STRING, class STRING COMMOT '班级'）COMMONT '学生表' PARTITIONED BY (ds STRING,country STRING) -- 分区的列不属于建表的字段中 ROW FORMAT DELIMITED --分隔符 FIELDS TERMINATED BY ',' -- 结束换行符 STORE AS SEQUENCEFILE -- 数据存储格式 ; ","date":"2024-04-24","objectID":"/bigdata/hive/20240424162208/:2:4","tags":null,"title":"hive常见的命令","uri":"/bigdata/hive/20240424162208/"},{"categories":null,"content":"\r2.5 Hive分桶表对指定列进行HASH，根据hash值进行切分数据，不同hash结果的数据写到每个桶对应的文件目录中 -- 创建分桶表 CREATE TABLE IF NOT EXISTS students(user_no INT,name STRING,sex STRING, class STRING COMMOT '班级',score SMALLINT COMMOT '总分'）COMMONT '学生表' PARTITIONED BY (ds STRING,country STRING) CLUSTERED BY(user_no) SORTED BY(score) INTO 32 BUCKETS -- 分桶 ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' STORE AS SEQUENCEFILE; ","date":"2024-04-24","objectID":"/bigdata/hive/20240424162208/:2:5","tags":null,"title":"hive常见的命令","uri":"/bigdata/hive/20240424162208/"},{"categories":null,"content":"\r2.6 Hive视图逻辑数据结构，将查询结果作为视图，简化查询操作 CREATE VIEW employee_skills AS SELECT name, skills_score['DB'] AS DB, skills_score['Perl'] AS Perl, skills_score['Python'] AS Python, skills_score['Sales'] as Sales, skills_score['HR'] as HR FROM employee; ","date":"2024-04-24","objectID":"/bigdata/hive/20240424162208/:2:6","tags":null,"title":"hive常见的命令","uri":"/bigdata/hive/20240424162208/"},{"categories":null,"content":"\r2.7 总结表的创建官方标准 LanguageManual DDL -创建表的语法结构 CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name -- (Note: TEMPORARY available in Hive 0.14.0 and later) [(col_name data_type [column_constraint_specification] [COMMENT col_comment], ... [constraint_specification])] [COMMENT table_comment] [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] [SKEWED BY (col_name, col_name, ...) -- (Note: Available in Hive 0.10.0 and later)] ON ((col_value, col_value, ...), (col_value, col_value, ...), ...) [STORED AS DIRECTORIES] [ [ROW FORMAT row_format] [STORED AS file_format] | STORED BY 'storage.handler.class.name' [WITH SERDEPROPERTIES (...)] -- (Note: Available in Hive 0.6.0 and later) ] [LOCATION hdfs_path] [TBLPROPERTIES (property_name=property_value, ...)] -- (Note: Available in Hive 0.6.0 and later) [AS select_statement]; -- (Note: Available in Hive 0.5.0 and later; not supported for external tables) -- 用另外一个表的结构来创建 CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name LIKE existing_table_or_view_name [LOCATION hdfs_path]; 删除表 DROP TABLE [IF EXISTS] table_name [PURGE]; -- (Note: PURGE available in Hive 0.14.0 and later) 清空表 TRUNCATE [TABLE] table_name [PARTITION partition_spec]; partition_spec: : (partition_column = partition_col_value, partition_column = partition_col_value, ...) ","date":"2024-04-24","objectID":"/bigdata/hive/20240424162208/:2:7","tags":null,"title":"hive常见的命令","uri":"/bigdata/hive/20240424162208/"},{"categories":null,"content":" HDFS ","date":"2024-04-24","objectID":"/bigdata/hadoop/a9bc224/:0:0","tags":["Hadoop"],"title":"HDFS文件读写过程","uri":"/bigdata/hadoop/a9bc224/"},{"categories":null,"content":"\r1 文件的写入过程HDFS把文件的数据划分成若干个块(Block)， 每个Block存放在一组 DataNode上，Namenode负责维护文件–\u003eBlock(命令空间映射)和Block–\u003eDatanode(数据块映射) 写入流程 Client发起文件上传请求，通过RPC与NameNode建立通讯，NameNode检查目标文件是否已存在，父目录是否存在，返回是否可以上传 Client请求确定第一个block 应该传输到哪些Datanode服务器上 NameNode根据配置文件指定的备份数量以及机架感知原理进行文件分配，返回可用的 DataNode地址，如：A，B，C 备份数量：默认在HDFS上存放三份，本地一份、同机架内其他节点一份、不同机架节点一份 Client 请求 3 台 DataNode 中的一台 A 上传数据（本质上是一个 RPC 调用，建立 pipeline ），A 收到请求会继续调用 B，然后 B 调用 C，将整个 pipeline 建立完成， 后逐级返回 client； Client 开始往 A 上传第一个 block（先从磁盘读取数据放到一个本地内存缓存），以 packet 为单位（默认64K），A 收到一个 packet 就会传给 B，B 传给 C。A 每传一个 packet 会放入一个应答队列等待应答； 数据被分割成一个个 packet 数据包在 pipeline 上依次传输，在 pipeline 反方向上， 逐个发送 ack（命令正确应答），最终由 pipeline 中第一个 DataNode 节点 A 将 pipelineack 发送给 Client； 当一个 block 传输完成之后，Client 再次请求 NameNode 上传第二个 block，重复步骤 2； ","date":"2024-04-24","objectID":"/bigdata/hadoop/a9bc224/:1:0","tags":["Hadoop"],"title":"HDFS文件读写过程","uri":"/bigdata/hadoop/a9bc224/"},{"categories":null,"content":"\r2 HDFS文件读取过程 Client远程调用请求NameNode，获取文件块位置列表 NameNode会视情况返回文件的部分或者全部block列表；对于每个block，NameNode返回含副本的所有DataNode 地址；计算传输最快最优的DataNode 返回的DataNode地址，会按照集群拓扑结构计算客户端的距离，然后进行排序，排序两个规则：网络拓扑结构中距离 Client 近的排靠前；心跳机制中超时汇报的 DN 状态为 STALE，这样的排靠后； Client 选取排序靠前的 DataNode建立输入流，如果客户端本身就是DataNode，那么将从本地直接获取数据(短路读取特性)； 在选定的DataNode上读取该Block的数据 当读完列表的 block 后，若文件读取还没有结束，客户端会继续向NameNode 获取下一批的 block 列表； 读取完一个 block 都会进行 checksum 验证，如果读取 DataNode 时出现错误，客户端会通知 NameNode，然后再从下一个拥有该 block 副本的DataNode 继续读。 read 方法是并行的读取 block 信息，不是一块一块的读取；NameNode 只是返回Client请求包含块的DataNode地址，并不是返回请求块的数据； 最终读取来所有的 block 会合并成一个完整的最终文件。 总结：串行写入，数据包先发给节点A，然后节点A发送给B，B在给C 并行读取，并行读取block所在的节点，最后合并 ","date":"2024-04-24","objectID":"/bigdata/hadoop/a9bc224/:2:0","tags":["Hadoop"],"title":"HDFS文件读写过程","uri":"/bigdata/hadoop/a9bc224/"},{"categories":["project"],"content":"\r1 HDFS 的命令行使用Hadoop 命令行官方doc hadoop fs: 使用面最广，可以操作任务文件系统，包括本地文件系统、HDFS、FTP、S3等 hdfs dfs: 只能操作HDFS文件系统。 # 下面两种效果是一样的 hdfs dfs -ls /user/hive hadoop fs -ls /user/hive/ 如果操作HDFS文件系统，推荐使用 hdfs dfs,如果需要操作其他系统文件，使用hadoop fs命令 help 格式: hdfs dfs -help 操作命令 作用: 查看某一个操作命令的参数信息 ls 格式：hdfs dfs -ls URI 作用：类似于Linux的ls命令，显示文件列表 lsr 格式 : hdfs dfs -lsr URI 作用 : 在整个目录下递归执行ls, 与UNIX中的ls-R类似 mkdir 格式 ： hdfs dfs -mkdir [-p] \u003cpaths\u003e 作用 : 以\u003cpaths\u003e中的URI作为参数，创建目录。使用-p参数可以递归创建目录 put 格式 ： hdfs dfs -put \u003clocalsrc \u003e ... \u003cdst\u003e 作用 ： 将单个的源文件src或者多个源文件srcs从本地文件系统拷贝到目标文件系统中（\u003cdst\u003e对应的路径）。也可以从标准输入中读取输入，写入目标文件系统中 hdfs dfs -put /rooot/bigdata.txt /dir1 moveFromLocal 格式： hdfs dfs -moveFromLocal \u003clocalsrc\u003e \u003cdst\u003e 作用: 和put命令类似，但是源文件localsrc拷贝之后自身被删除 hdfs dfs -moveFromLocal /root/bigdata.txt / copyFromLocal 格式: hdfs dfs -copyFromLocal \u003clocalsrc\u003e ... \u003cdst\u003e 作用: 从本地文件系统中拷贝文件到hdfs路径去 appendToFile 格式: hdfs dfs -appendToFile \u003clocalsrc\u003e ... \u003cdst\u003e 作用: 追加一个或者多个文件到hdfs指定文件中.也可以从命令行读取输入. hdfs dfs -appendToFile a.xml b.xml /big.xml moveToLocal 在 hadoop 2.6.4 版本测试还未未实现此方法 格式：hadoop dfs -moveToLocal [-crc] \u003csrc\u003e \u003cdst\u003e 作用：将本地文件剪切到 HDFS get 格式 hdfs dfs -get [-ignorecrc ] [-crc] \u003csrc\u003e \u003clocaldst\u003e 作用：将文件拷贝到本地文件系统。 CRC 校验失败的文件通过-ignorecrc选项拷贝。 文件和CRC校验可以通过-CRC选项拷贝 hdfs dfs -get /bigdata.txt /export/servers getmerge 格式: hdfs dfs -getmerge \u003csrc\u003e \u003clocaldst\u003e 作用: 合并下载多个文件，比如hdfs的目录 /aaa/下有多个文件:log.1, log.2,log.3,... copyToLocal 格式: hdfs dfs -copyToLocal \u003csrc\u003e ... \u003clocaldst\u003e 作用: 从hdfs拷贝到本地 mv 格式 ： hdfs dfs -mv URI \u003cdest\u003e 作用： 将hdfs上的文件从原路径移动到目标路径（移动之后文件删除），该命令不能跨文件系统 hdfs dfs -mv /dir1/bigdata.txt /dir2 rm 格式： hdfs dfs -rm [-r] 【-skipTrash】 URI 【URI 。。。】 作用： 删除参数指定的文件，参数可以有多个。 此命令只删除文件和非空目录。 如果指定-skipTrash选项，那么在回收站可用的情况下，该选项将跳过回收站而直接删除文件； 否则，在回收站可用时，在HDFS Shell 中执行此命令，会将文件暂时放到回收站中。 hdfs dfs -rm -r /dir1 cp 格式: hdfs dfs -cp URI [URI ...] \u003cdest\u003e 作用： 将文件拷贝到目标路径中。如果\u003cdest\u003e 为目录的话，可以将多个文件拷贝到该目录下。 -f 选项将覆盖目标，如果它已经存在。 -p 选项将保留文件属性（时间戳、所有权、许可、ACL、XAttr）。 hdfs dfs -cp /dir1/a.txt /dir2/bigdata.txt cat hdfs dfs -cat URI [uri ...] 作用：将参数所指示的文件内容输出到stdout hdfs dfs -cat /bigdata.txt tail 格式: hdfs dfs -tail path 作用: 显示一个文件的末尾 text 格式:hdfs dfs -text path 作用: 以字符形式打印一个文件的内容 chmod 格式:hdfs dfs -chmod [-R] URI[URI ...] 作用：改变文件权限。如果使用 -R 选项，则对整个目录有效递归执行。使用这一命令的用户必须是文件的所属用户，或者超级用户。 hdfs dfs -chmod -R 777 /bigdata.txt chown 格式: hdfs dfs -chmod [-R] URI[URI ...] 作用： 改变文件的所属用户和用户组。如果使用 -R 选项，则对整个目录有效递归执行。使用这一命令的用户必须是文件的所属用户，或者超级用户。 hdfs dfs -chown -R hadoop:hadoop /bigdata.txt df 格式: hdfs dfs -df -h path 作用: 统计文件系统的可用空间信息 du 格式: hdfs dfs -du -s -h path 作用: 统计文件夹的大小信息 count 格式: hdfs dfs -count path 作用: 统计一个指定目录下的文件节点数量 setrep expunge (慎用) 格式: hdfs dfs -setrep num filePath 作用: 设置hdfs中文件的副本数量 注意: 即使设置的超过了datanode的数量,副本的数量也最多只能和datanode的数量是一致的 ","date":"2024-04-23","objectID":"/bigdata/hadoop/hadoop%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","tags":["Hadoop"],"title":"hadoop命令行的使用","uri":"/bigdata/hadoop/hadoop%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["project"],"content":"\r2 hdfs的高级使用命令","date":"2024-04-23","objectID":"/bigdata/hadoop/hadoop%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","tags":["Hadoop"],"title":"hadoop命令行的使用","uri":"/bigdata/hadoop/hadoop%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["project"],"content":"\r2.1 HDFS文件限额配置在多人共用HDFS的环境下，配置设置非常重要。特别是在 Hadoop 处理大量资料的环境，如果没有配额管理，很容易把所有的空间用完造成别人无法存取。HDFS 的配额设定是针对目录而不是针对账号，可以让每个账号仅操作某一个目录，然后对目录设置配置。 HDFS 文件的限额配置允许我们以文件个数，或者文件大小来限制我们在某个目录下上传的文件数量或者文件内容总量，以便达到我们类似百度网盘网盘等限制每个用户允许上传的最大的文件的量。 hdfs dfs -count -q -h /user/root/dir1 #查看配额信息 2.1.1 数量限额 hdfs dfs -mkdir -p /user/root/dir #创建hdfs文件夹 hdfs dfsadmin -setQuota 2 dir # 给该文件夹下面设置最多上传两个文件，发现只能上传一个文件 hdfs dfsadmin -clrQuota /user/root/dir # 清除文件数量限制 2.1.2 空间大小限额在设置空间配额时，设置的空间至少是 block_size * 3 大小 hdfs dfsadmin -setSpaceQuota 4k /user/root/dir # 限制空间大小4KB hdfs dfs -put /root/a.txt /user/root/dir # 生成任意大小的文件 dd if=/dev/zero of=1.txt bs=1M count=2 #生成2M的文件 # 清除空间配额限制 hdfs dfsadmin -clrSpaceQuota /user/root/dir ","date":"2024-04-23","objectID":"/bigdata/hadoop/hadoop%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8/:2:1","tags":["Hadoop"],"title":"hadoop命令行的使用","uri":"/bigdata/hadoop/hadoop%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["project"],"content":"\r2.2 HDFS 的安全模式安全模式是hadoop的一种保护机制，用于保证集群中的数据块的安全性。当集群启动的时候，会首先进入安全模式。当系统处于安全模式时会检查数据块的完整性。 假设我们设置的副本数（即参数dfs.replication）是3，那么在datanode上就应该有3个副本存在，假设只存在2个副本，那么比例就是2/3=0.666。hdfs默认的副本率0.999。我们的副本率0.666明显小于0.999，因此系统会自动的复制副本到其他dataNode，使得副本率不小于0.999。如果系统中有5个副本，超过我们设定的3个副本，那么系统也会删除多于的2个副本。 在安全模式状态下，文件系统只接受读数据请求，而不接受删除、修改等变更请求。在，当整个系统达到安全标准时，HDFS自动离开安全模式。30s 安全模式操作命令 hdfs dfsadmin -safemode get #查看安全模式状态 hdfs dfsadmin -safemode enter #进入安全模式 hdfs dfsadmin -safemode leave #离开安全模式 ","date":"2024-04-23","objectID":"/bigdata/hadoop/hadoop%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8/:2:2","tags":["Hadoop"],"title":"hadoop命令行的使用","uri":"/bigdata/hadoop/hadoop%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["开发"],"content":"\rHDFS HDFS概述 Hadoop 分布式系统框架中，首要的基础功能就是文件系统，在 Hadoop 中使用 FileSystem 这个抽象类来表示我们的文件系统，这个抽象类下面有很多子实现类，究竟使用哪一种，需要看我们具体的实现类，在我们实际工作中，用到的最多的就是HDFS(分布式文件系统)以及LocalFileSystem(本地文件系统)了。 在现代的企业环境中，单机容量往往无法存储大量数据，需要跨机器存储。统一管理分布在集群上的文件系统称为分布式文件系统。 HDFS（Hadoop Distributed File System）是 Hadoop 项目的一个子项目。是 Hadoop 的核心组件之一， Hadoop 非常适于存储大型数据 (比如 TB 和 PB)，其就是使用 HDFS 作为存储系统. HDFS 使用多台计算机存储文件，并且提供统一的访问接口，像是访问一个普通文件系统一样使用分布式文件系统。 HDFS架构 HDFS是一个主/从（Mater/Slave）体系结构，由三部分组成： NameNode 和 DataNode 以及 SecondaryNamenode： ● NameNode 负责管理整个文件系统的元数据，以及每一个路径（文件）所对应的数据块信息。 ● DataNode 负责管理用户的文件数据块，每一个数据块都可以在多个 DataNode 上存储多个副本，默认为3个。 ● Secondary NameNode 用来监控 HDFS 状态的辅助后台程序，每隔一段时间获取 HDFS 元数据的快照。最主要作用是辅助 NameNode 管理元数据信息。 HDFS的特性 首先，它是一个文件系统，用于存储文件，通过统一的命名空间目录树来定位文件； 其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务器有各自的角色。 master/slave 架构（主从架构） HDFS 采用 master/slave 架构。一般一个 HDFS 集群是有一个 Namenode 和一定数目的 Datanode 组成。Namenode 是 HDFS 集群主节点，Datanode 是 HDFS 集群从节点，两种角色各司其职，共同协调完成分布式的文件存储服务。 分块存储(Block) HDFS 中的文件在物理上是分块存储（block）的，块的大小可以通过配置参数来规定，默认大小在 hadoop2.x 版本中是 128M。 名字空间（NameSpace） HDFS 支持传统的层次型文件组织结构。用户或者应用程序可以创建目录，然后将文件保存在这些目录里。文件系统名字空间的层次结构和大多数现有的文件系统类似：用户可以创建、删除、移动或重命名文件。 Namenode 负责维护文件系统的名字空间，任何对文件系统名字空间或属性的修改都将被 Namenode 记录下来。 HDFS 会给客户端提供一个统一的抽象目录树，客户端通过路径来访问文件，形如：hdfs://namenode:port/dir-a/dir-b/dir-c/file.data。 NameNode 元数据管理 我们把目录结构及文件分块位置信息叫做元数据。NameNode 负责维护整个 HDFS 文件系统的目录树结构，以及每一个文件所对应的 block 块信息（block 的 id，及所在的 DataNode 服务器）。 DataNode 数据存储 文件的各个 block 的具体存储管理由 DataNode 节点承担。每一个 block 都可以在多个 DataNode 上。DataNode 需要定时向 NameNode 汇报自己持有的 block 信息。 存储多个副本（副本数量也可以通过参数设置 dfs.replication，默认是 3） 副本机制 为了容错，文件的所有 block 都会有副本。每个文件的 block 大小和副本系数都是可配置的。应用程序可以指定某个文件的副本数目。副本系数可以在文件创建的时候指定，也可以在之后改变。 一次写入，多次读出 HDFS 是设计成适应一次写入，多次读出的场景，且不支持文件的修改。 正因为如此，HDFS 适合用来做大数据分析的底层存储服务，并不适合用来做网盘等应用，因为修改不方便，延迟大，网络开销大，成本太高。 ","date":"2024-04-23","objectID":"/bigdata/hadoop/hadoop%E6%A6%82%E8%A7%88/:0:0","tags":["Hadoop"],"title":"Hadoop概览","uri":"/bigdata/hadoop/hadoop%E6%A6%82%E8%A7%88/"},{"categories":["开发"],"content":"Configuration - Spark 2.4.8 配置参数 Spark SQL — PySpark官方API手册 ","date":"2024-04-20","objectID":"/bigdata/spark/spark%E5%85%A5%E9%97%A8/:0:0","tags":["spark"],"title":"spark简单介绍","uri":"/bigdata/spark/spark%E5%85%A5%E9%97%A8/"},{"categories":["开发"],"content":"\r1 Apache Spark A Unified engine for large-scale data analytics Apache Spark is a unified analytics engine for large-scale data processing. It provides high-level APIs in Java, Scala, Python and R, and an optimized engine that supports general execution graphs. It also supports a rich set of higher-level tools including Spark SQL for SQL and structured data processing, pandas API on Spark for pandas workloads, MLlib for machine learning, GraphX for graph processing, and Structured Streaming for incremental computation and stream processing. ","date":"2024-04-20","objectID":"/bigdata/spark/spark%E5%85%A5%E9%97%A8/:1:0","tags":["spark"],"title":"spark简单介绍","uri":"/bigdata/spark/spark%E5%85%A5%E9%97%A8/"},{"categories":["开发"],"content":"\r2 DownloadingGet Spark from the downloads page of the project website. This documentation is for Spark version 3.5.1. Spark uses Hadoop’s client libraries for HDFS and YARN. Downloads are pre-packaged for a handful of popular Hadoop versions. Users can also download a “Hadoop free” binary and run Spark with any Hadoop version by augmenting Spark’s classpath. Scala and Java users can include Spark in their projects using its Maven coordinates and Python users can install Spark from PyPI. If you’d like to build Spark from source, visit Building Spark. ","date":"2024-04-20","objectID":"/bigdata/spark/spark%E5%85%A5%E9%97%A8/:2:0","tags":["spark"],"title":"spark简单介绍","uri":"/bigdata/spark/spark%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"\r1 IntroductionThis is bold text, and this is emphasized text. Visit the Hugo website! ","date":"2024-04-20","objectID":"/posts/my-first-post/:1:0","tags":null,"title":"My First Post","uri":"/posts/my-first-post/"},{"categories":null,"content":"\r常用数据库的读写方式A blog (a truncation of “weblog”) is an informational website published on the World Wide Web consisting of discrete, often informal diary-style text entries (posts). Posts are typically displayed in reverse chronological order so that the most recent post appears first, at the top of the web page. Until 2009, blogs were usually the work of a single individual,[citation needed] occasionally of a small group, and often covered a single subject or topic. In the 2010s, “multi-author blogs” (MABs) emerged, featuring the writing of multiple authors and sometimes professionally edited. MABs from newspapers, other media outlets, universities, think tanks, advocacy groups, and similar institutions account for an increasing quantity of blog traffic. The rise of Twitter and other “microblogging” systems helps integrate MABs and single-author blogs into the news media. Blog can also be used as a verb, meaning to maintain or add content to a blog. ","date":"2024-02-20","objectID":"/posts/second_post/:1:0","tags":"测试","title":"我的第二篇文章","uri":"/posts/second_post/"},{"categories":null,"content":"\r标题二","date":"2024-02-20","objectID":"/posts/second_post/:2:0","tags":"测试","title":"我的第二篇文章","uri":"/posts/second_post/"},{"categories":null,"content":"\r标题三","date":"2024-02-20","objectID":"/posts/second_post/:3:0","tags":"测试","title":"我的第二篇文章","uri":"/posts/second_post/"},{"categories":["开发"],"content":"\rPythonpython第二篇文章扽扽 ","date":"2023-02-20","objectID":"/lang/python/first/:1:0","tags":["测试"],"title":"python第二篇文章","uri":"/lang/python/first/"},{"categories":["开发"],"content":"\r标题二","date":"2023-02-20","objectID":"/lang/python/first/:2:0","tags":["测试"],"title":"python第二篇文章","uri":"/lang/python/first/"},{"categories":["开发"],"content":"\r标题三","date":"2023-02-20","objectID":"/lang/python/first/:3:0","tags":["测试"],"title":"python第二篇文章","uri":"/lang/python/first/"},{"categories":["开发"],"content":"\rPythonpython第一篇文章扽扽 ","date":"2023-02-20","objectID":"/lang/python/second/:1:0","tags":["测试"],"title":"python第一篇文章","uri":"/lang/python/second/"},{"categories":["开发"],"content":"\r标题二","date":"2023-02-20","objectID":"/lang/python/second/:2:0","tags":["测试"],"title":"python第一篇文章","uri":"/lang/python/second/"},{"categories":["开发"],"content":"\r标题三","date":"2023-02-20","objectID":"/lang/python/second/:3:0","tags":["测试"],"title":"python第一篇文章","uri":"/lang/python/second/"},{"categories":["开发"],"content":"\r1 常用数据库的读写方式A blog (a truncation of “weblog”) is an informational website published on the World Wide Web consisting of discrete, often informal diary-style text entries (posts). Posts are typically displayed in reverse chronological order so that the most recent post appears first, at the top of the web page. Until 2009, blogs were usually the work of a single individual,[citation needed] occasionally of a small group, and often covered a single subject or topic. In the 2010s, “multi-author blogs” (MABs) emerged, featuring the writing of multiple authors and sometimes professionally edited. MABs from newspapers, other media outlets, universities, think tanks, advocacy groups, and similar institutions account for an increasing quantity of blog traffic. The rise of Twitter and other “microblogging” systems helps integrate MABs and single-author blogs into the news media. Blog can also be used as a verb, meaning to maintain or add content to a blog. ","date":"2023-02-20","objectID":"/posts/first_post/:1:0","tags":["测试"],"title":"我的第一篇文章","uri":"/posts/first_post/"},{"categories":["开发"],"content":"\r2 标题二","date":"2023-02-20","objectID":"/posts/first_post/:2:0","tags":["测试"],"title":"我的第一篇文章","uri":"/posts/first_post/"},{"categories":["开发"],"content":"\r3 标题三","date":"2023-02-20","objectID":"/posts/first_post/:3:0","tags":["测试"],"title":"我的第一篇文章","uri":"/posts/first_post/"}]